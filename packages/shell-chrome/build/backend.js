/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/backend.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@spider-rulegen/vendor/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/index.js ***!
  \******************************************************/
/*! exports provided: SelectorGadget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selectorgadget_css_selectorgadget_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selectorgadget/css/selectorgadget.css */ "./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css");
/* harmony import */ var _selectorgadget_css_selectorgadget_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_selectorgadget_css_selectorgadget_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _selectorgadget_js_jquery_bind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectorgadget/js/jquery-bind */ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/jquery-bind.js");
/* harmony import */ var _selectorgadget_js_jquery_bind__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_selectorgadget_js_jquery_bind__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _selectorgadget_js_diff_bind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectorgadget/js/diff-bind */ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/diff-bind.js");
/* harmony import */ var _selectorgadget_js_diff_bind__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_selectorgadget_js_diff_bind__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _selectorgadget_js_core_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectorgadget/js/core/core */ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/core.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectorGadget", function() { return _selectorgadget_js_core_core__WEBPACK_IMPORTED_MODULE_3__["SelectorGadget"]; });






/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css":
/*!***********************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../../css-loader!../../../../postcss-loader/src??ref--2-2!./selectorgadget.css */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/src/index.js?!./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../../vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("4bfbbf6b", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/core.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/core.js ***!
  \****************************************************************************/
/*! exports provided: SelectorGadget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectorGadget", function() { return SelectorGadget; });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/dom.js");

/*
 The MIT License
 Copyright (c) 2012 Andrew Cantino
 Copyright (c) 2009 Andrew Cantino & Kyle Maxwell
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/



function SelectorGadget() { }

SelectorGadget.prototype.border_width = 5;

SelectorGadget.prototype.border_padding = 2;

SelectorGadget.prototype.b_top = null;

SelectorGadget.prototype.b_left = null;

SelectorGadget.prototype.b_right = null;

SelectorGadget.prototype.b_bottom = null;

SelectorGadget.prototype.selected = [];

SelectorGadget.prototype.rejected = [];

SelectorGadget.prototype.special_mode = null;

SelectorGadget.prototype.path_output_field = null;

SelectorGadget.prototype.sg_div = null;

SelectorGadget.prototype.ignore_class = 'selectorgadget_ignore';

SelectorGadget.prototype.unbound = false;

SelectorGadget.prototype.prediction_helper = new _dom__WEBPACK_IMPORTED_MODULE_0__["DomPredictionHelper"]();

SelectorGadget.prototype.restricted_elements = jQuerySG.map(['html', 'body', 'head', 'base'], function (selector) {
    return jQuerySG(selector).get(0);
});

SelectorGadget.prototype.makeBorders = function (orig_elem, makeRed) {
    var elem, height, left, p, path_to_show, top, width;
    this.removeBorders();
    this.setupBorders();
    if (orig_elem.parentNode) {
        path_to_show = orig_elem.parentNode.tagName.toLowerCase() + ' ' + orig_elem.tagName.toLowerCase();
    } else {
        path_to_show = orig_elem.tagName.toLowerCase();
    }
    elem = jQuerySG(orig_elem);
    p = elem.offset();
    top = p.top;
    left = p.left;
    width = elem.outerWidth();
    height = elem.outerHeight();
    this.b_top.css('width', this.px(width + this.border_padding * 2 + this.border_width * 2)).css('top', this.px(top - this.border_width - this.border_padding)).css('left', this.px(left - this.border_padding - this.border_width));
    this.b_bottom.css('width', this.px(width + this.border_padding * 2 + this.border_width * 2 - 5)).css('top', this.px(top + height + this.border_padding)).css('left', this.px(left - this.border_padding - this.border_width)).text(path_to_show);
    this.b_left.css('height', this.px(height + this.border_padding * 2)).css('top', this.px(top - this.border_padding)).css('left', this.px(left - this.border_padding - this.border_width));
    this.b_right.css('height', this.px(height + this.border_padding * 2)).css('top', this.px(top - this.border_padding)).css('left', this.px(left + width + this.border_padding));
    this.b_right.get(0).target_elem = this.b_left.get(0).target_elem = this.b_top.get(0).target_elem = this.b_bottom.get(0).target_elem = orig_elem;
    if (makeRed || elem.hasClass("selectorgadget_suggested") || elem.hasClass("selectorgadget_selected")) {
        this.b_top.addClass('selectorgadget_border_red');
        this.b_bottom.addClass('selectorgadget_border_red');
        this.b_left.addClass('selectorgadget_border_red');
        this.b_right.addClass('selectorgadget_border_red');
    } else {
        if (this.b_top.hasClass('selectorgadget_border_red')) {
            this.b_top.removeClass('selectorgadget_border_red');
            this.b_bottom.removeClass('selectorgadget_border_red');
            this.b_left.removeClass('selectorgadget_border_red');
            this.b_right.removeClass('selectorgadget_border_red');
        }
    }
    return this.showBorders();
};

SelectorGadget.prototype.px = function (p) {
    return p + 'px';
};

SelectorGadget.prototype.showBorders = function () {
    this.b_top.show();
    this.b_bottom.show();
    this.b_left.show();
    return this.b_right.show();
};

SelectorGadget.prototype.removeBorders = function () {
    if (this.b_top) {
        this.b_top.hide();
        this.b_bottom.hide();
        this.b_left.hide();
        return this.b_right.hide();
    }
};

SelectorGadget.prototype.setupBorders = function () {
    var width;
    if (!this.b_top) {
        width = this.border_width + 'px';
        this.b_top = jQuerySG('<div>').addClass('selectorgadget_border').css('height', width).hide().bind("mousedown.sg", {
            'self': this
        }, this.sgMousedown);
        this.b_bottom = jQuerySG('<div>').addClass('selectorgadget_border').addClass('selectorgadget_bottom_border').css('height', this.px(this.border_width + 6)).hide().bind("mousedown.sg", {
            'self': this
        }, this.sgMousedown);
        this.b_left = jQuerySG('<div>').addClass('selectorgadget_border').css('width', width).hide().bind("mousedown.sg", {
            'self': this
        }, this.sgMousedown);
        this.b_right = jQuerySG('<div>').addClass('selectorgadget_border').css('width', width).hide().bind("mousedown.sg", {
            'self': this
        }, this.sgMousedown);
        return this.addBorderToDom();
    }
};

SelectorGadget.prototype.addBorderToDom = function () {
    document.body.appendChild(this.b_top.get(0));
    document.body.appendChild(this.b_bottom.get(0));
    document.body.appendChild(this.b_left.get(0));
    return document.body.appendChild(this.b_right.get(0));
};

SelectorGadget.prototype.removeBorderFromDom = function () {
    if (this.b_top) {
        this.b_top.remove();
        this.b_bottom.remove();
        this.b_left.remove();
        this.b_right.remove();
        return this.b_top = this.b_bottom = this.b_left = this.b_right = null;
    }
};

SelectorGadget.prototype.selectable = function (elem) {
    return !this.css_restriction || (this.css_restriction && jQuerySG(elem).is(this.css_restriction));
};

SelectorGadget.prototype.sgMouseover = function (e) {
    var gadget, parent, self;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    if (this === document.body || this === document.body.parentNode) {
        return false;
    }
    self = jQuerySG(this);
    gadget.unhighlightIframes();
    if (self.is("iframe")) {
        gadget.highlightIframe(self, e);
    }
    if (gadget.special_mode !== 'd') {
        parent = gadget.firstSelectedOrSuggestedParent(this);
        if (parent !== null && parent !== this && gadget.selectable(parent)) {
            gadget.makeBorders(parent, true);
        } else {
            if (gadget.selectable(self)) {
                gadget.makeBorders(this);
            }
        }
    } else {
        if (!jQuerySG('.selectorgadget_selected', this).get(0)) {
            if (gadget.selectable(self)) {
                gadget.makeBorders(this);
            }
        }
    }
    return false;
};

SelectorGadget.prototype.firstSelectedOrSuggestedParent = function (elem) {
    var orig;
    orig = elem;
    if (jQuerySG(elem).hasClass('selectorgadget_suggested') || jQuerySG(elem).hasClass('selectorgadget_selected')) {
        return elem;
    }
    while (elem.parentNode && (elem = elem.parentNode)) {
        if (jQuerySG.inArray(elem, this.restricted_elements) === -1) {
            if (jQuerySG(elem).hasClass('selectorgadget_suggested') || jQuerySG(elem).hasClass('selectorgadget_selected')) {
                return elem;
            }
        }
    }
    return null;
};

SelectorGadget.prototype.sgMouseout = function (e) {
    var elem, gadget;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    if (this === document.body || this === document.body.parentNode) {
        return false;
    }
    elem = jQuerySG(this);
    gadget.removeBorders();
    return false;
};

SelectorGadget.prototype.highlightIframe = function (elem, click) {
    var block, instructions, p, self, src, target;
    p = elem.offset();
    self = this;
    target = jQuerySG(click.target);
    block = jQuerySG('<div>').css('position', 'absolute').css('z-index', '99998').css('width', this.px(elem.outerWidth())).css('height', this.px(elem.outerHeight())).css('top', this.px(p.top)).css('left', this.px(p.left)).css('background-color', '#AAA').css('opacity', '0.6').addClass("selectorgadget_iframe").addClass('selectorgadget_clean');
    instructions = jQuerySG("<div><span>This is an iframe.  To select in it, </span></div>").addClass("selectorgadget_iframe_info").addClass("selectorgadget_iframe").addClass('selectorgadget_clean');
    instructions.css({
        width: "200px",
        border: "1px solid #888"
    }, {
        padding: "5px",
        "background-color": "white",
        position: "absolute",
        "z-index": "99999",
        top: this.px(p.top + (elem.outerHeight() / 4.0)),
        left: this.px(p.left + (elem.outerWidth() - 200) / 2.0),
        height: "150px"
    });
    src = null;
    try {
        src = elem.contents().get(0).location.href;
    } catch (e) {
        src = elem.attr("src");
    }
    instructions.append(jQuerySG("<a target='_top'>click here to open it</a>").attr("href", src));
    instructions.append(jQuerySG("<span>, then relaunch SelectorGadget.</span>"));
    document.body.appendChild(instructions.get(0));
    block.click(function () {
        if (self.selectable(target)) {
            return target.mousedown();
        }
    });
    return document.body.appendChild(block.get(0));
};

SelectorGadget.prototype.unhighlightIframes = function (elem, click) {
    return jQuerySG(".selectorgadget_iframe").remove();
};

SelectorGadget.prototype.sgMousedown = function (e) {
    var elem, gadget, potential_elem, prediction, w_elem;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    elem = this;
    w_elem = jQuerySG(elem);
    if (w_elem.hasClass('selectorgadget_border')) {
        elem = elem.target_elem || elem;
        w_elem = jQuerySG(elem);
    }
    if (elem === document.body || elem === document.body.parentNode) {
        return;
    }
    if (gadget.special_mode !== 'd') {
        potential_elem = gadget.firstSelectedOrSuggestedParent(elem);
        if (potential_elem !== null && potential_elem !== elem) {
            elem = potential_elem;
            w_elem = jQuerySG(elem);
        }
    } else {
        if (jQuerySG('.selectorgadget_selected', this).get(0)) {
            gadget.blockClicksOn(elem);
        }
    }
    if (!gadget.selectable(w_elem)) {
        gadget.removeBorders();
        gadget.blockClicksOn(elem);
        return false;
    }
    if (w_elem.hasClass('selectorgadget_selected')) {
        w_elem.removeClass('selectorgadget_selected');
        gadget.selected.splice(jQuerySG.inArray(elem, gadget.selected), 1);
    } else if (w_elem.hasClass("selectorgadget_rejected")) {
        w_elem.removeClass('selectorgadget_rejected');
        gadget.rejected.splice(jQuerySG.inArray(elem, gadget.rejected), 1);
    } else if (w_elem.hasClass("selectorgadget_suggested")) {
        w_elem.addClass('selectorgadget_rejected');
        gadget.rejected.push(elem);
    } else {
        w_elem.addClass('selectorgadget_selected');
        gadget.selected.push(elem);
    }
    gadget.clearSuggested();
    prediction = gadget.prediction_helper.predictCss(jQuerySG(gadget.selected), jQuerySG(gadget.rejected.concat(gadget.restricted_elements)));
    gadget.suggestPredicted(prediction);
    gadget.setPath(prediction);
    gadget.removeBorders();
    gadget.blockClicksOn(elem);
    w_elem.trigger("mouseover.sg", {
        'self': gadget
    });
    return false;
};

SelectorGadget.prototype.setupEventHandlers = function () {
    jQuerySG("*:not(.selectorgadget_ignore)").bind("mouseover.sg", {
        'self': this
    }, this.sgMouseover);
    jQuerySG("*:not(.selectorgadget_ignore)").bind("mouseout.sg", {
        'self': this
    }, this.sgMouseout);
    jQuerySG("*:not(.selectorgadget_ignore)").bind("mousedown.sg", {
        'self': this
    }, this.sgMousedown);
    jQuerySG("html").bind("keydown.sg", {
        'self': this
    }, this.listenForActionKeys);
    return jQuerySG("html").bind("keyup.sg", {
        'self': this
    }, this.clearActionKeys);
};

SelectorGadget.prototype.listenForActionKeys = function (e) {
    var gadget;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    if (e.keyCode === 16 || e.keyCode === 68) {
        gadget.special_mode = 'd';
        return gadget.removeBorders();
    }
};

SelectorGadget.prototype.clearActionKeys = function (e) {
    var gadget;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    gadget.removeBorders();
    return gadget.special_mode = null;
};

SelectorGadget.prototype.blockClicksOn = function (elem) {
    var block, p;
    elem = jQuerySG(elem);
    p = elem.offset();
    block = jQuerySG('<div>').css('position', 'absolute').css('z-index', '9999999').css('width', this.px(elem.outerWidth())).css('height', this.px(elem.outerHeight())).css('top', this.px(p.top)).css('left', this.px(p.left)).css('background-color', '');
    document.body.appendChild(block.get(0));
    setTimeout((function () {
        return block.remove();
    }), 400);
    return false;
};

SelectorGadget.prototype.setMode = function (mode) {
    if (mode === 'browse') {
        this.removeEventHandlers();
    } else if (mode === 'interactive') {
        this.setupEventHandlers();
    }
    return this.clearSelected();
};

SelectorGadget.prototype.suggestPredicted = function (prediction) {
    var count;
    if (prediction && prediction !== '') {
        count = 0;
        jQuerySG(prediction).each(function () {
            count += 1;
            if (!jQuerySG(this).hasClass('selectorgadget_selected') && !jQuerySG(this).hasClass('selectorgadget_ignore') && !jQuerySG(this).hasClass('selectorgadget_rejected')) {
                return jQuerySG(this).addClass('selectorgadget_suggested');
            }
        });
        if (this.clear_button) {
            if (count > 0) {
                return this.clear_button.attr('value', 'Clear (' + count + ')');
            } else {
                return this.clear_button.attr('value', 'Clear');
            }
        }
    }
};

// Modify: emit setPath event
SelectorGadget.prototype.setPath = function (prediction) {
    let path = ''
    if (prediction && prediction.length > 0) {
        path = prediction
    }
    this.path_output_field.value = path
    this.emitter && this.emitter.emit('setPath', path)
    return path
};

SelectorGadget.prototype.refreshFromPath = function (e) {
    var path, self;
    self = (e && e.data && e.data.self) || this;

    // Modify: set path from e
    if (e && e.value !== undefined) {
        self.path_output_field.value = e.value
    }

    path = self.path_output_field.value;
    self.clearSelected();
    self.suggestPredicted(path);
    return self.setPath(path);
};

SelectorGadget.prototype.showXPath = function (e) {
    var path, self;
    self = (e && e.data && e.data.self) || this;
    path = self.path_output_field.value;
    if (path === 'No valid path found.') {
        return;
    }
    return prompt("The CSS selector '" + path + "' as an XPath is shown below.  Please report any bugs that you find with this converter.", self.prediction_helper.cssToXPath(path));
};

SelectorGadget.prototype.clearSelected = function (e) {
    var self;
    self = (e && e.data && e.data.self) || this;
    self.selected = [];
    self.rejected = [];
    jQuerySG('.selectorgadget_selected').removeClass('selectorgadget_selected');
    jQuerySG('.selectorgadget_rejected').removeClass('selectorgadget_rejected');
    self.removeBorders();
    return self.clearSuggested();
};

SelectorGadget.prototype.clearEverything = function (e) {
    var self;
    self = (e && e.data && e.data.self) || this;
    self.clearSelected();
    return self.resetOutputs();
};

SelectorGadget.prototype.resetOutputs = function () {
    return this.setPath();
};

SelectorGadget.prototype.clearSuggested = function () {
    jQuerySG('.selectorgadget_suggested').removeClass('selectorgadget_suggested');
    if (this.clear_button) {
        return this.clear_button.attr('value', 'Clear');
    }
};

SelectorGadget.prototype.showHelp = function () {
    return alert("Click on a page element that you would like your selector to match (it will turn green). SelectorGadget will then generate a minimal CSS selector for that element, and will highlight (yellow) everything that is matched by the selector. Now click on a highlighted element to reject it (red), or click on an unhighlighted element to add it (green). Through this process of selection and rejection, SelectorGadget helps you to come up with the perfect CSS selector for your needs.\n\nHolding 'shift' while moving the mouse will let you select elements inside of other selected elements.");
};

SelectorGadget.prototype.useRemoteInterface = function () {
    return window.sg_options && window.sg_options.remote_interface;
};

SelectorGadget.prototype.updateRemoteInterface = function (data_obj) {
    return this.addScript(this.composeRemoteUrl(window.sg_options.remote_interface, data_obj));
};

SelectorGadget.prototype.composeRemoteUrl = function (url, data_obj) {
    var key, params;
    params = (url.split("?")[1] && url.split("?")[1].split("&")) || [];
    params.push("t=" + (new Date()).getTime());
    params.push("url=" + encodeURIComponent(window.location.href));
    if (data_obj) {
        for (key in data_obj) {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(data_obj[key]));
        }
    }
    if (this.remote_data) {
        for (key in this.remote_data) {
            params.push(encodeURIComponent("data[" + key + "]") + '=' + encodeURIComponent(this.remote_data[key]));
        }
    }
    return url.split("?")[0] + "?" + params.join("&");
};

SelectorGadget.prototype.addScript = function (src) {
    var head, s;
    s = document.createElement('script');
    s.setAttribute('type', 'text/javascript');
    s.setAttribute('src', src);
    head = document.getElementsByTagName('head')[0];
    if (head) {
        return head.appendChild(s);
    } else {
        return document.body.appendChild(s);
    }
};

// SelectorGadget.prototype.makeInterface = function () {
//     this.sg_div = jQuerySG('<div>').attr('id', 'selectorgadget_main').addClass('selectorgadget_bottom').addClass('selectorgadget_ignore');
//     if (this.useRemoteInterface()) {
//         this.path_output_field = {
//             value: null
//         };
//         this.remote_data = {};
//         this.updateRemoteInterface();
//     } else {
//         this.makeStandardInterface();
//     }
//     return jQuerySG('body').append(this.sg_div);
// };

// Modify: notify parent to show interface
SelectorGadget.prototype.makeInterface = function () {
    this.path_output_field = { value: "" }
}

SelectorGadget.prototype.makeStandardInterface = function () {
    var path, self;
    self = this;
    path = jQuerySG('<input>').attr('id', 'selectorgadget_path_field').addClass('selectorgadget_ignore').addClass('selectorgadget_input_field').keydown(function (e) {
        if (e.keyCode === 13) {
            return self.refreshFromPath(e);
        }
    }).focus(function () {
        return jQuerySG(this).select();
    });
    this.sg_div.append(path);
    this.clear_button = jQuerySG('<input type="button" value="Clear"/>').bind("click", {
        'self': this
    }, this.clearEverything).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field');
    this.sg_div.append(this.clear_button);
    this.sg_div.append(jQuerySG('<input type="button" value="Toggle Position"/>').click(function () {
        if (self.sg_div.hasClass('selectorgadget_top')) {
            return self.sg_div.removeClass('selectorgadget_top').addClass('selectorgadget_bottom');
        } else {
            return self.sg_div.removeClass('selectorgadget_bottom').addClass('selectorgadget_top');
        }
    }).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field'));
    this.sg_div.append(jQuerySG('<input type="button" value="XPath"/>').bind("click", {
        'self': this
    }, this.showXPath).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field'));
    this.sg_div.append(jQuerySG('<input type="button" value="?"/>').bind("click", {
        'self': this
    }, this.showHelp).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field'));
    this.sg_div.append(jQuerySG('<input type="button" value="X"/>').bind("click", {
        'self': this
    }, this.unbindAndRemoveInterface).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field'));
    return this.path_output_field = path.get(0);
};

SelectorGadget.prototype.removeInterface = function (e) {
    // Modify: do nothing, cause no element was insert on makeInterface
    // this.sg_div.remove();
    // return this.sg_div = null;
};

SelectorGadget.prototype.unbind = function (e) {
    var self;
    self = (e && e.data && e.data.self) || this;
    self.unbound = true;
    self.removeBorderFromDom();
    return self.clearSelected();
};

SelectorGadget.prototype.unbindAndRemoveInterface = function (e) {
    var self;
    self = (e && e.data && e.data.self) || this;
    self.unbind();
    return self.removeInterface();
};

SelectorGadget.prototype.setOutputMode = function (e, output_mode) {
    var self;
    self = (e && e.data && e.data.self) || this;
    return self.output_mode = (e && e.data && e.data.mode) || output_mode;
};

SelectorGadget.prototype.rebind = function () {
    this.unbound = false;
    this.clearEverything();
    return this.setupBorders();
};

SelectorGadget.prototype.rebindAndMakeInterface = function () {
    this.makeInterface();
    return this.rebind();
};

SelectorGadget.prototype.randBetween = function (a, b) {
    return Math.floor(Math.random() * b) + a;
};

SelectorGadget.toggle = function (options) {
    if (!window.selector_gadget) {
        window.selector_gadget = new SelectorGadget();
        window.selector_gadget.makeInterface();
        window.selector_gadget.clearEverything();
        window.selector_gadget.setMode('interactive');
        if ((options != null ? options.analytics : void 0) !== false) {
            window.selector_gadget.analytics();
        }
    } else if (window.selector_gadget.unbound) {
        window.selector_gadget.rebindAndMakeInterface();
    } else {
        window.selector_gadget.unbindAndRemoveInterface();
    }
    return jQuerySG('.selector_gadget_loading').remove();
};

// Modify: add SelectorGadget.toggleOpen
SelectorGadget.toggleOpen = function (options) {
    if (!window.selector_gadget) {
        window.selector_gadget = new SelectorGadget();
        window.selector_gadget.makeInterface();
        window.selector_gadget.clearEverything();
        window.selector_gadget.setMode('interactive');
        // if ((options != null ? options.analytics : void 0) !== false) {
        //     window.selector_gadget.analytics();
        // }
    } else if (window.selector_gadget.unbound) {
        window.selector_gadget.rebindAndMakeInterface();
    }
    jQuerySG('.selector_gadget_loading').remove();
    return window.selector_gadget
}

SelectorGadget.toggleClose = function () {
    window.selector_gadget && !window.selector_gadget.unbound && window.selector_gadget.unbindAndRemoveInterface();
    return jQuerySG('.selector_gadget_loading').remove();
}

SelectorGadget.prototype.analytics = function () {
    var cookie, random, referer, today, urchinUrl, uservar, utmac, utmhn, utmn, utmp;
    utmac = 'UA-148948-9';
    utmhn = encodeURIComponent('www.selectorgadget.com');
    utmn = this.randBetween(1000000000, 9999999999);
    cookie = this.randBetween(10000000, 99999999);
    random = this.randBetween(1000000000, 2147483647);
    today = Math.round(new Date().getTime() / 1000.0);
    referer = encodeURIComponent(window.location.href);
    uservar = '-';
    utmp = 'sg';
    urchinUrl = 'http://www.google-analytics.com/__utm.gif?utmwv=1&utmn=' + utmn + '&utmsr=-&utmsc=-&utmul=-&utmje=0&utmfl=-&utmdt=-&utmhn=' + utmhn + '&utmr=' + referer + '&utmp=' + utmp + '&utmac=' + utmac + '&utmcc=__utma%3D' + cookie + '.' + random + '.' + today + '.' + today + '.' + today + '.2%3B%2B__utmb%3D' + cookie + '%3B%2B__utmc%3D' + cookie + '%3B%2B__utmz%3D' + cookie + '.' + today + '.2.2.utmccn%3D(direct)%7Cutmcsr%3D(direct)%7Cutmcmd%3D(none)%3B%2B__utmv%3D' + cookie + '.' + uservar + '%3B';
    return document.body.appendChild(jQuerySG('<img />').attr('src', urchinUrl).get(0));
};

/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/dom.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/dom.js ***!
  \***************************************************************************/
/*! exports provided: DomPredictionHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomPredictionHelper", function() { return DomPredictionHelper; });

/*
 The MIT License
 Copyright (c) 2012 Andrew Cantino
 Copyright (c) 2009 Andrew Cantino & Kyle Maxwell
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

function DomPredictionHelper() { }

DomPredictionHelper.prototype.recursiveNodes = function (e) {
    var n;
    if (e.nodeName && e.parentNode && e !== document.body) {
        n = this.recursiveNodes(e.parentNode);
    } else {
        n = new Array();
    }
    n.push(e);
    return n;
};

DomPredictionHelper.prototype.escapeCssNames = function (name) {
    if (name) {
        try {
            return name.replace(/\bselectorgadget_\w+\b/g, '').replace(/\\/g, '\\\\').replace(/[\#\;\&\,\.\+\*\~\'\:\"\!\^\$\[\]\(\)\=\>\|\/]/g, function (e) {
                return '\\' + e;
            }).replace(/\s+/, '');
        } catch (e) {
            if (window.console) {
                console.log('---');
                console.log("exception in escapeCssNames");
                console.log(name);
                console.log('---');
            }
            return '';
        }
    } else {
        return '';
    }
};

DomPredictionHelper.prototype.childElemNumber = function (elem) {
    var count;
    count = 0;
    while (elem.previousSibling && (elem = elem.previousSibling)) {
        if (elem.nodeType === 1) {
            count++;
        }
    }
    return count;
};

DomPredictionHelper.prototype.siblingsWithoutTextNodes = function (e) {
    var filtered_nodes, node, nodes, _i, _len;
    nodes = e.parentNode.childNodes;
    filtered_nodes = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        if (node.nodeName.substring(0, 1) === "#") {
            continue;
        }
        if (node === e) {
            break;
        }
        filtered_nodes.push(node);
    }
    return filtered_nodes;
};

DomPredictionHelper.prototype.pathOf = function (elem) {
    var e, j, path, siblings, _i, _len, _ref;
    path = "";
    _ref = this.recursiveNodes(elem);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        if (e) {
            siblings = this.siblingsWithoutTextNodes(e);
            if (e.nodeName.toLowerCase() !== "body") {
                j = siblings.length - 2 < 0 ? 0 : siblings.length - 2;
                while (j < siblings.length) {
                    if (siblings[j] === e) {
                        break;
                    }
                    if (!siblings[j].nodeName.match(/^(script|#.*?)$/i)) {
                        path += this.cssDescriptor(siblings[j]) + (j + 1 === siblings.length ? "+ " : "~ ");
                    }
                    j++;
                }
            }
            path += this.cssDescriptor(e) + " > ";
        }
    }
    return this.cleanCss(path);
};

DomPredictionHelper.prototype.cssDescriptor = function (node) {
    var cssName, escaped, path, _i, _len, _ref;
    path = node.nodeName.toLowerCase();
    escaped = node.id && this.escapeCssNames(new String(node.id));
    if (escaped && escaped.length > 0) {
        path += '#' + escaped;
    }
    if (node.className) {
        _ref = node.className.split(" ");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            cssName = _ref[_i];
            escaped = this.escapeCssNames(cssName);
            if (cssName && escaped.length > 0) {
                path += '.' + escaped;
            }
        }
    }
    if (node.nodeName.toLowerCase() !== "body") {
        path += ':nth-child(' + (this.childElemNumber(node) + 1) + ')';
    }
    return path;
};

DomPredictionHelper.prototype.cssDiff = function (array) {
    var collective_common, cssElem, diff, dmp, encoded_css_array, existing_tokens, part, _i, _j, _len, _len1;
    try {
        dmp = new diff_match_patch();
    } catch (e) {
        throw "Please include the diff_match_patch library.";
    }
    if (typeof array === 'undefined' || array.length === 0) {
        return '';
    }
    existing_tokens = {};
    encoded_css_array = this.encodeCssForDiff(array, existing_tokens);
    collective_common = encoded_css_array.pop();
    for (_i = 0, _len = encoded_css_array.length; _i < _len; _i++) {
        cssElem = encoded_css_array[_i];
        diff = dmp.diff_main(collective_common, cssElem);
        collective_common = '';
        for (_j = 0, _len1 = diff.length; _j < _len1; _j++) {
            part = diff[_j];
            if (part[0] === 0) {
                collective_common += part[1];
            }
        }
    }
    return this.decodeCss(collective_common, existing_tokens);
};

DomPredictionHelper.prototype.tokenizeCss = function (css_string) {
    var char, skip, tokens, word, _i, _len, _ref;
    skip = false;
    word = '';
    tokens = [];
    _ref = this.cleanCss(css_string);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        char = _ref[_i];
        if (skip) {
            skip = false;
        } else if (char === '\\') {
            skip = true;
        } else if (char === '.' || char === ' ' || char === '#' || char === '>' || char === ':' || char === ',' || char === '+' || char === '~') {
            if (word.length > 0) {
                tokens.push(word);
            }
            word = '';
        }
        word += char;
        if (char === ' ' || char === ',') {
            tokens.push(word);
            word = '';
        }
    }
    if (word.length > 0) {
        tokens.push(word);
    }
    return tokens;
};

DomPredictionHelper.prototype.tokenizeCssForDiff = function (css_string) {
    var block, combined_tokens, token, _i, _len, _ref;
    combined_tokens = [];
    block = [];
    _ref = this.tokenizeCss(css_string);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        block.push(token);
        if (token === ' ' && block.length > 0) {
            combined_tokens = combined_tokens.concat(block);
            block = [];
        } else if (token === '+' || token === '~') {
            block = [block.join('')];
        }
    }
    if (block.length > 0) {
        return combined_tokens.concat(block);
    } else {
        return combined_tokens;
    }
};

DomPredictionHelper.prototype.decodeCss = function (string, existing_tokens) {
    var character, inverted, out, _i, _len, _ref;
    inverted = this.invertObject(existing_tokens);
    out = '';
    _ref = string.split('');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        character = _ref[_i];
        out += inverted[character];
    }
    return this.cleanCss(out);
};

DomPredictionHelper.prototype.encodeCssForDiff = function (strings, existing_tokens) {
    var codepoint, out, string, strings_out, token, _i, _j, _len, _len1, _ref;
    codepoint = 50;
    strings_out = [];
    for (_i = 0, _len = strings.length; _i < _len; _i++) {
        string = strings[_i];
        out = new String();
        _ref = this.tokenizeCssForDiff(string);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            token = _ref[_j];
            if (!existing_tokens[token]) {
                existing_tokens[token] = String.fromCharCode(codepoint++);
            }
            out += existing_tokens[token];
        }
        strings_out.push(out);
    }
    return strings_out;
};

DomPredictionHelper.prototype.tokenPriorities = function (tokens) {
    var epsilon, first, i, priorities, second, token, _i, _len;
    epsilon = 0.001;
    priorities = new Array();
    i = 0;
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        first = token.substring(0, 1);
        second = token.substring(1, 2);
        if (first === ':' && second === 'n') {
            priorities[i] = 0;
        } else if (first === '>') {
            priorities[i] = 2;
        } else if (first === '+' || first === '~') {
            priorities[i] = 3;
        } else if (first !== ':' && first !== '.' && first !== '#' && first !== ' ' && first !== '>' && first !== '+' && first !== '~') {
            priorities[i] = 4;
        } else if (first === '.') {
            priorities[i] = 5;
        } else if (first = '#') {
            priorities[i] = 6;
            if (token.match(/\d{3,}/)) {
                priorities[i] = 2.5;
            }
        } else {
            priorities[i] = 0;
        }
        priorities[i] += i * epsilon;
        i++;
    }
    return priorities;
};

DomPredictionHelper.prototype.orderFromPriorities = function (priorities) {
    var i, ordering, tmp, _i, _j, _ref, _ref1;
    tmp = new Array();
    ordering = new Array();
    for (i = _i = 0, _ref = priorities.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        tmp[i] = {
            value: priorities[i],
            original: i
        };
    }
    tmp.sort(function (a, b) {
        return a.value - b.value;
    });
    for (i = _j = 0, _ref1 = priorities.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        ordering[i] = tmp[i].original;
    }
    return ordering;
};

DomPredictionHelper.prototype.simplifyCss = function (css, selected, rejected) {
    var best_so_far, first, got_shorter, i, look_back_index, ordering, part, parts, priorities, second, selector, _i, _ref,
        _this = this;
    parts = this.tokenizeCss(css);
    priorities = this.tokenPriorities(parts);
    ordering = this.orderFromPriorities(priorities);
    selector = this.cleanCss(css);
    look_back_index = -1;
    best_so_far = "";
    if (this.selectorGets('all', selected, selector) && this.selectorGets('none', rejected, selector)) {
        best_so_far = selector;
    }
    got_shorter = true;
    while (got_shorter) {
        got_shorter = false;
        for (i = _i = 0, _ref = parts.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            part = ordering[i];
            if (parts[part].length === 0) {
                continue;
            }
            first = parts[part].substring(0, 1);
            second = parts[part].substring(1, 2);
            if (first === ' ') {
                continue;
            }
            if (this.wouldLeaveFreeFloatingNthChild(parts, part)) {
                continue;
            }
            this._removeElements(part, parts, first, function (selector) {
                if (_this.selectorGets('all', selected, selector) && _this.selectorGets('none', rejected, selector) && (selector.length < best_so_far.length || best_so_far.length === 0)) {
                    best_so_far = selector;
                    got_shorter = true;
                    return true;
                } else {
                    return false;
                }
            });
        }
    }
    return this.cleanCss(best_so_far);
};

DomPredictionHelper.prototype._removeElements = function (part, parts, firstChar, callback) {
    var j, look_back_index, selector, tmp, _i, _j;
    if (firstChar === '+' || firstChar === '~') {
        look_back_index = this.positionOfSpaceBeforeIndexOrLineStart(part, parts);
    } else {
        look_back_index = part;
    }
    tmp = parts.slice(look_back_index, part + 1);
    for (j = _i = look_back_index; look_back_index <= part ? _i <= part : _i >= part; j = look_back_index <= part ? ++_i : --_i) {
        parts[j] = '';
    }
    selector = this.cleanCss(parts.join(''));
    if (selector === '' || !callback(selector)) {
        for (j = _j = look_back_index; look_back_index <= part ? _j <= part : _j >= part; j = look_back_index <= part ? ++_j : --_j) {
            parts[j] = tmp[j - look_back_index];
        }
    }
    return parts;
};

DomPredictionHelper.prototype.positionOfSpaceBeforeIndexOrLineStart = function (part, parts) {
    var i;
    i = part;
    while (i >= 0 && parts[i] !== ' ') {
        i--;
    }
    if (i < 0) {
        i = 0;
    }
    return i;
};

DomPredictionHelper.prototype.wouldLeaveFreeFloatingNthChild = function (parts, part) {
    var i, nth_child_is_on_right, space_is_on_left;
    space_is_on_left = nth_child_is_on_right = false;
    i = part + 1;
    while (i < parts.length && parts[i].length === 0) {
        i++;
    }
    if (i < parts.length && parts[i].substring(0, 2) === ':n') {
        nth_child_is_on_right = true;
    }
    i = part - 1;
    while (i > -1 && parts[i].length === 0) {
        i--;
    }
    if (i < 0 || parts[i] === ' ') {
        space_is_on_left = true;
    }
    return space_is_on_left && nth_child_is_on_right;
};

DomPredictionHelper.prototype.cleanCss = function (css) {
    var cleaned_css, last_cleaned_css;
    cleaned_css = css;
    last_cleaned_css = null;
    while (last_cleaned_css !== cleaned_css) {
        last_cleaned_css = cleaned_css;
        cleaned_css = cleaned_css.replace(/(^|\s+)(\+|\~)/, '').replace(/(\+|\~)\s*$/, '').replace(/>/g, ' > ').replace(/\s*(>\s*)+/g, ' > ').replace(/,/g, ' , ').replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '').replace(/\s*,$/g, '').replace(/^\s*,\s*/g, '').replace(/\s*>$/g, '').replace(/^>\s*/g, '').replace(/[\+\~\>]\s*,/g, ',').replace(/[\+\~]\s*>/g, '>').replace(/\s*(,\s*)+/g, ' , ');
    }
    return cleaned_css;
};

DomPredictionHelper.prototype.getPathsFor = function (nodeset) {
    var node, out, _i, _len;
    out = [];
    for (_i = 0, _len = nodeset.length; _i < _len; _i++) {
        node = nodeset[_i];
        if (node && node.nodeName) {
            out.push(this.pathOf(node));
        }
    }
    return out;
};

DomPredictionHelper.prototype.predictCss = function (s, r) {
    var css, selected, selected_paths, simplest, union, _i, _len;
    if (s.length === 0) {
        return '';
    }
    selected_paths = this.getPathsFor(s);
    css = this.cssDiff(selected_paths);
    simplest = this.simplifyCss(css, s, r);
    if (simplest.length > 0) {
        return simplest;
    }
    union = '';
    for (_i = 0, _len = s.length; _i < _len; _i++) {
        selected = s[_i];
        union = this.pathOf(selected) + ", " + union;
    }
    union = this.cleanCss(union);
    return this.simplifyCss(union, s, r);
};

DomPredictionHelper.prototype.selectorGets = function (type, list, the_selector) {
    if (list.length === 0 && type === 'all') {
        return false;
    }
    if (list.length === 0 && type === 'none') {
        return true;
    }
    try {
        if (type === 'all') {
            return list.not(the_selector).length === 0;
        } else {
            return !(list.is(the_selector));
        }
    } catch (e) {
        if (window.console) {
            console.log("Error on selector: " + the_selector);
        }
        throw e;
    }
};

DomPredictionHelper.prototype.invertObject = function (object) {
    var key, new_object, value;
    new_object = {};
    for (key in object) {
        value = object[key];
        new_object[value] = key;
    }
    return new_object;
};

DomPredictionHelper.prototype.cssToXPath = function (css_string) {
    var css_block, out, token, tokens, _i, _len;
    tokens = this.tokenizeCss(css_string);
    if (tokens[0] && tokens[0] === ' ') {
        tokens.splice(0, 1);
    }
    if (tokens[tokens.length - 1] && tokens[tokens.length - 1] === ' ') {
        tokens.splice(tokens.length - 1, 1);
    }
    css_block = [];
    out = "";
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        if (token === ' ') {
            out += this.cssToXPathBlockHelper(css_block);
            css_block = [];
        } else {
            css_block.push(token);
        }
    }
    return out + this.cssToXPathBlockHelper(css_block);
};

DomPredictionHelper.prototype.cssToXPathBlockHelper = function (css_block) {
    var current, expressions, first, i, out, re, rest, _i, _j, _len, _ref;
    if (css_block.length === 0) {
        return '//';
    }
    out = '//';
    first = css_block[0].substring(0, 1);
    if (first === ',') {
        return " | ";
    }
    if (first === ':' || first === '#' || first === '.') {
        out += '*';
    }
    expressions = [];
    re = null;
    for (_i = 0, _len = css_block.length; _i < _len; _i++) {
        current = css_block[_i];
        first = current.substring(0, 1);
        rest = current.substring(1);
        if (first === ':') {
            if (re = rest.match(/^nth-child\((\d+)\)$/)) {
                expressions.push('(((count(preceding-sibling::*) + 1) = ' + re[1] + ') and parent::*)');
            }
        } else if (first === '.') {
            expressions.push('contains(concat( " ", @class, " " ), concat( " ", "' + rest + '", " " ))');
        } else if (first === '#') {
            expressions.push('(@id = "' + rest + '")');
        } else if (first === ',') {

        } else {
            out += current;
        }
    }
    if (expressions.length > 0) {
        out += '[';
    }
    for (i = _j = 0, _ref = expressions.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        out += expressions[i];
        if (i < expressions.length - 1) {
            out += ' and ';
        }
    }
    if (expressions.length > 0) {
        out += ']';
    }
    return out;
};


/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/diff-bind.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/js/diff-bind.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up.  (0 for infinity)
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // The size beyond which the double-ended diff activates.
  // Double-ending is twice as fast, but less accurate.
  this.Diff_DualThreshold = 32;
  // Tweak the relative importance (0.0 = accuracy, 1.0 = proximity)
  this.Match_Balance = 0.5;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose)
  this.Match_Threshold = 0.5;
  // The min and max cutoffs used when computing text lengths.
  this.Match_MinLength = 100;
  this.Match_MaxLength = 1000;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  /**
   * Compute the number of bits in an int.
   * The normal answer for JavaScript is 32.
   * @return {number} Max bits
   */
  function getMaxBits() {
    var maxbits = 0;
    var oldi = 1;
    var newi = 2;
    while (oldi != newi) {
      maxbits++;
      oldi = newi;
      newi = newi << 1;
    }
    return maxbits;
  }
  // How many bits in a number?
  this.Match_MaxBits = getMaxBits();
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed
 * @param {string} text2 New string to be diffed
 * @param {boolean} opt_checklines Optional speedup flag.  If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff
 * @return {Array.<Array.<*>>} Array of diff tuples
 */
diff_match_patch.prototype.diff_main = function (text1, text2, opt_checklines) {
  // Check for equality (speedup)
  if (text1 == text2) {
    return [[DIFF_EQUAL, text1]];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup)
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup)
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block
  var diffs = this.diff_compute(text1, text2, checklines);

  // Restore the prefix and suffix
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed
 * @param {string} text2 New string to be diffed
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff
 * @return {Array.<Array.<*>>} Array of diff tuples
 * @private
 */
diff_match_patch.prototype.diff_compute = function (text1, text2, checklines) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup)
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup)
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup)
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
    [DIFF_EQUAL, shorttext],
    [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  longtext = shorttext = null;  // Garbage collect

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  // Perform a real diff.
  if (checklines && (text1.length < 100 || text2.length < 100)) {
    // Too trivial for the overhead.
    checklines = false;
  }
  var linearray;
  if (checklines) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars(text1, text2);
    text1 = a[0];
    text2 = a[1];
    linearray = a[2];
  }
  diffs = this.diff_map(text1, text2);
  if (!diffs) {
    // No acceptable result.
    diffs = [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  if (checklines) {
    // Convert the diff back to original text.
    this.diff_charsToLines(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push([DIFF_EQUAL, '']);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete >= 1 && count_insert >= 1) {
            // Delete the offending records and add the merged ones.
            var a = this.diff_main(text_delete, text_insert, false);
            diffs.splice(pointer - count_delete - count_insert,
              count_delete + count_insert);
            pointer = pointer - count_delete - count_insert;
            for (var j = a.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, a[j]);
            }
            pointer = pointer + a.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
      pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.
  }
  return diffs;
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string
 * @param {string} text2 Second string
 * @return {Array.<string|Array.<string>>} Three element Array, containing the
 *     encoded text1, the encoded text2 and the array of unique strings.  The
 *     zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars = function (text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode
   * @return {string} Encoded string
   * @private
   */
  function diff_linesToCharsMunge(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
        (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge(text1);
  var chars2 = diff_linesToCharsMunge(text2);
  return [chars1, chars2, lineArray];
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @param {Array.<string>} lineArray Array of unique strings
 * @private
 */
diff_match_patch.prototype.diff_charsToLines = function (diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Explore the intersection points between the two texts.
 * @param {string} text1 Old string to be diffed
 * @param {string} text2 New string to be diffed
 * @return {Array.<Array.<*>>?} Array of diff tuples or null if no diff
 *     available
 * @private
 */
diff_match_patch.prototype.diff_map = function (text1, text2) {
  // Don't run for too long.
  var ms_end = (new Date()).getTime() + this.Diff_Timeout * 1000;
  var max_d = text1.length + text2.length - 1;
  var doubleEnd = this.Diff_DualThreshold * 2 < max_d;
  var v_map1 = [];
  var v_map2 = [];
  var v1 = {};
  var v2 = {};
  v1[1] = 0;
  v2[1] = 0;
  var x, y;
  var footstep;  // Used to track overlapping paths.
  var footsteps = {};
  var done = false;
  // Safari 1.x doesn't have hasOwnProperty
  var hasOwnProperty = !!(footsteps.hasOwnProperty);
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (text1.length + text2.length) % 2;
  for (var d = 0; d < max_d; d++) {
    // Bail out if timeout reached.
    if (this.Diff_Timeout > 0 && (new Date()).getTime() > ms_end) {
      return null;
    }

    // Walk the front path one step.
    v_map1[d] = {};
    for (var k = -d; k <= d; k += 2) {
      if (k == -d || k != d && v1[k - 1] < v1[k + 1]) {
        x = v1[k + 1];
      } else {
        x = v1[k - 1] + 1;
      }
      y = x - k;
      if (doubleEnd) {
        footstep = x + ',' + y;
        if (front && (hasOwnProperty ? footsteps.hasOwnProperty(footstep) :
          (footsteps[footstep] !== undefined))) {
          done = true;
        }
        if (!front) {
          footsteps[footstep] = d;
        }
      }
      while (!done && x < text1.length && y < text2.length &&
        text1.charAt(x) == text2.charAt(y)) {
        x++;
        y++;
        if (doubleEnd) {
          footstep = x + ',' + y;
          if (front && (hasOwnProperty ? footsteps.hasOwnProperty(footstep) :
            (footsteps[footstep] !== undefined))) {
            done = true;
          }
          if (!front) {
            footsteps[footstep] = d;
          }
        }
      }
      v1[k] = x;
      v_map1[d][x + ',' + y] = true;
      if (x == text1.length && y == text2.length) {
        // Reached the end in single-path mode.
        return this.diff_path1(v_map1, text1, text2);
      } else if (done) {
        // Front path ran over reverse path.
        v_map2 = v_map2.slice(0, footsteps[footstep] + 1);
        var a = this.diff_path1(v_map1, text1.substring(0, x),
          text2.substring(0, y));
        return a.concat(this.diff_path2(v_map2, text1.substring(x),
          text2.substring(y)));
      }
    }

    if (doubleEnd) {
      // Walk the reverse path one step.
      v_map2[d] = {};
      for (var k = -d; k <= d; k += 2) {
        if (k == -d || k != d && v2[k - 1] < v2[k + 1]) {
          x = v2[k + 1];
        } else {
          x = v2[k - 1] + 1;
        }
        y = x - k;
        footstep = (text1.length - x) + ',' + (text2.length - y);
        if (!front && (hasOwnProperty ? footsteps.hasOwnProperty(footstep) :
          (footsteps[footstep] !== undefined))) {
          done = true;
        }
        if (front) {
          footsteps[footstep] = d;
        }
        while (!done && x < text1.length && y < text2.length &&
          text1.charAt(text1.length - x - 1) ==
          text2.charAt(text2.length - y - 1)) {
          x++;
          y++;
          footstep = (text1.length - x) + ',' + (text2.length - y);
          if (!front && (hasOwnProperty ? footsteps.hasOwnProperty(footstep) :
            (footsteps[footstep] !== undefined))) {
            done = true;
          }
          if (front) {
            footsteps[footstep] = d;
          }
        }
        v2[k] = x;
        v_map2[d][x + ',' + y] = true;
        if (done) {
          // Reverse path ran over front path.
          v_map1 = v_map1.slice(0, footsteps[footstep] + 1);
          var a = this.diff_path1(v_map1, text1.substring(0, text1.length - x),
            text2.substring(0, text2.length - y));
          return a.concat(this.diff_path2(v_map2,
            text1.substring(text1.length - x),
            text2.substring(text2.length - y)));
        }
      }
    }
  }
  // Number of diffs equals number of characters, no commonality at all.
  return null;
};


/**
 * Work from the middle back to the start to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed
 * @param {string} text2 New string fragment to be diffed
 * @return {Array.<Array.<*>>} Array of diff tuples
 * @private
 */
diff_match_patch.prototype.diff_path1 = function (v_map, text1, text2) {
  var path = [];
  var x = text1.length;
  var y = text2.length;
  /** @type {number?} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d].hasOwnProperty ? v_map[d].hasOwnProperty((x - 1) + ',' + y) :
        (v_map[d][(x - 1) + ',' + y] !== undefined)) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_DELETE, text1.charAt(x)]);
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d].hasOwnProperty ?
        v_map[d].hasOwnProperty(x + ',' + (y - 1)) :
        (v_map[d][x + ',' + (y - 1)] !== undefined)) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[0][1] = text2.charAt(y) + path[0][1];
        } else {
          path.unshift([DIFF_INSERT, text2.charAt(y)]);
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        //if (text1.charAt(x) != text2.charAt(y)) {
        //  throw new Error('No diagonal.  Can\'t happen. (diff_path1)');
        //}
        if (last_op === DIFF_EQUAL) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_EQUAL, text1.charAt(x)]);
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Work from the middle back to the end to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed
 * @param {string} text2 New string fragment to be diffed
 * @return {Array.<Array.<*>>} Array of diff tuples
 * @private
 */
diff_match_patch.prototype.diff_path2 = function (v_map, text1, text2) {
  var path = [];
  var pathLength = 0;
  var x = text1.length;
  var y = text2.length;
  /** @type {number?} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d].hasOwnProperty ? v_map[d].hasOwnProperty((x - 1) + ',' + y) :
        (v_map[d][(x - 1) + ',' + y] !== undefined)) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
            [DIFF_DELETE, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d].hasOwnProperty ?
        v_map[d].hasOwnProperty(x + ',' + (y - 1)) :
        (v_map[d][x + ',' + (y - 1)] !== undefined)) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[pathLength - 1][1] += text2.charAt(text2.length - y - 1);
        } else {
          path[pathLength++] =
            [DIFF_INSERT, text2.charAt(text2.length - y - 1)];
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        //if (text1.charAt(text1.length - x - 1) !=
        //    text2.charAt(text2.length - y - 1)) {
        //  throw new Error('No diagonal.  Can\'t happen. (diff_path2)');
        //}
        if (last_op === DIFF_EQUAL) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
            [DIFF_EQUAL, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Determine the common prefix of two strings
 * @param {string} text1 First string
 * @param {string} text2 Second string
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function (text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charCodeAt(0) !== text2.charCodeAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
      text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings
 * @param {string} text1 First string
 * @param {string} text2 Second string
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function (text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charCodeAt(text1.length - 1) !==
    text2.charCodeAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * @param {string} text1 First string
 * @param {string} text2 Second string
 * @return {Array.<string>?} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
diff_match_patch.prototype.diff_halfMatch = function (text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 10 || shorttext.length < 1) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string
   * @param {string} shorttext Shorter string
   * @param {number} i Start index of quarter length substring within longtext
   * @return {Array.<string>?} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
        shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
        shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
          shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length >= longtext.length / 2) {
      return [best_longtext_a, best_longtext_b,
        best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI(longtext, shorttext,
    Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI(longtext, shorttext,
    Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 */
diff_match_patch.prototype.diff_cleanupSemantic = function (diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = null;  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_changes1 = 0;
  // Number of characters that changed after the equality.
  var length_changes2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      equalities[equalitiesLength++] = pointer;
      length_changes1 = length_changes2;
      length_changes2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // an insertion or deletion
      length_changes2 += diffs[pointer][1].length;
      if (lastequality !== null && (lastequality.length <= length_changes1) &&
        (lastequality.length <= length_changes2)) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
          [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_changes1 = 0;  // Reset the counters.
        length_changes2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function (diffs) {
  // Define some regex patterns for matching boundaries. 
  var punctuation = /[^a-zA-Z0-9]/;
  var whitespace = /\s/;
  var linebreak = /[\r\n]/;
  var blanklineEnd = /\n\r?\n$/;
  var blanklineStart = /^\r?\n\r?\n/;

  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 5 (best) to 0 (worst).
   * Closure, makes reference to regex patterns defined above.
   * @param {string} one First string
   * @param {string} two Second string
   * @return {number} The score.
   */
  function diff_cleanupSemanticScore(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 5;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var score = 0;
    // One point for non-alphanumeric.
    if (one.charAt(one.length - 1).match(punctuation) ||
      two.charAt(0).match(punctuation)) {
      score++;
      // Two points for whitespace.
      if (one.charAt(one.length - 1).match(whitespace) ||
        two.charAt(0).match(whitespace)) {
        score++;
        // Three points for line breaks.
        if (one.charAt(one.length - 1).match(linebreak) ||
          two.charAt(0).match(linebreak)) {
          score++;
          // Four points for blank lines.
          if (one.match(blanklineEnd) || two.match(blanklineStart)) {
            score++;
          }
        }
      }
    }
    return score;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
      diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore(equality1, edit) +
        diff_cleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore(equality1, edit) +
          diff_cleanupSemanticScore(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};


/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function (diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = '';  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      if (diffs[pointer][1].length < this.Diff_EditCost &&
        (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = '';
      }
      post_ins = post_del = false;
    } else {  // an insertion or deletion
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
        ((lastequality.length < this.Diff_EditCost / 2) &&
          (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
          [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = '';
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 */
diff_match_patch.prototype.diff_cleanupMerge = function (diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete !== 0 || count_insert !== 0) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                diffs[pointer - count_delete - count_insert - 1][0] ==
                DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                  text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                  text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_delete - count_insert,
              count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete - count_insert,
              count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
              count_delete + count_insert, [DIFF_DELETE, text_delete],
              [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
            (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
      diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
        diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
          diffs[pointer][1].substring(0, diffs[pointer][1].length -
            diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length)
        == diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
          diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @param {number} loc Location within text1
 * @return {number} Location within text2
 */
diff_match_patch.prototype.diff_xIndex = function (diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @return {string} HTML representation
 */
diff_match_patch.prototype.diff_prettyHtml = function (diffs) {
  var html = [];
  var i = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];   // Operation (insert, delete, equal)
    var data = diffs[x][1]; // Text of change.
    var text = data.replace(/&/g, '&amp;').replace(/</g, '&lt;')
      .replace(/>/g, '&gt;').replace(/\n/g, '&para;<BR>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<INS STYLE="background:#E6FFE6;" TITLE="i=' + i + '">' +
          text + '</INS>';
        break;
      case DIFF_DELETE:
        html[x] = '<DEL STYLE="background:#FFE6E6;" TITLE="i=' + i + '">' +
          text + '</DEL>';
        break;
      case DIFF_EQUAL:
        html[x] = '<SPAN TITLE="i=' + i + '">' + text + '</SPAN>';
        break;
    }
    if (op !== DIFF_DELETE) {
      i += data.length;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @return {string} Source text
 */
diff_match_patch.prototype.diff_text1 = function (diffs) {
  var txt = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      txt[x] = diffs[x][1];
    }
  }
  return txt.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @return {string} Destination text
 */
diff_match_patch.prototype.diff_text2 = function (diffs) {
  var txt = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      txt[x] = diffs[x][1];
    }
  }
  return txt.join('');
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @return {string} Delta text
 */
diff_match_patch.prototype.diff_toDelta = function (diffs) {
  var txt = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        txt[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        txt[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        txt[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  // Opera doesn't know how to encode char 0.
  return txt.join('\t').replace(/\0/g, '%00').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff
 * @param {string} delta Delta text
 * @return {Array.<Array.<*>>} Array of diff tuples
 * @throws {Error} If invalid input
 */
diff_match_patch.prototype.diff_fromDelta = function (text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  // Opera doesn't know how to decode char 0.
  delta = delta.replace(/%00/g, '\0');
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
      // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
            tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
      ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search
 * @param {string} pattern The pattern to search for
 * @param {number} loc The location to search around
 * @return {number?} Best match index or null
 */
diff_match_patch.prototype.match_main = function (text, pattern, loc) {
  loc = Math.max(0, Math.min(loc, text.length - pattern.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (text.length === 0) {
    // Nothing to match.
    return null;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search
 * @param {string} pattern The pattern to search for
 * @param {number} loc The location to search around
 * @return {number?} Best match index or null
 * @private
 */
diff_match_patch.prototype.match_bitap = function (text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet(pattern);

  var score_text_length = text.length;
  // Coerce the text length between reasonable maximums and minimums.
  score_text_length = Math.max(score_text_length, this.Match_MinLength);
  score_text_length = Math.min(score_text_length, this.Match_MaxLength);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc, score_text_length and pattern through being a closure.
   * @param {number} e Number of errors in match
   * @param {number} x Location of match
   * @return {number} Overall score for match
   * @private
   */
  function match_bitapScore(e, x) {
    var d = Math.abs(loc - x);
    return (e / pattern.length / dmp.Match_Balance) +
      (d / score_text_length / (1.0 - dmp.Match_Balance));
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
  }
  // What about in the other direction? (speedup)
  best_loc = text.lastIndexOf(pattern, loc + pattern.length);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = null;

  var bin_min, bin_mid;
  var bin_max = Math.max(loc + loc, text.length);
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    var rd = Array(text.length);

    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = loc;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore(d, bin_mid) < score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(0, loc - (bin_mid - loc) - 1);
    var finish = Math.min(text.length - 1, pattern.length + bin_mid);

    if (text.charAt(finish) == pattern.charAt(pattern.length - 1)) {
      rd[finish] = (1 << (d + 1)) - 1;
    } else {
      rd[finish] = (1 << d) - 1;
    }
    for (var j = finish - 1; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following lines generate
      // warnings.
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & s[text.charAt(j)];
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = ((rd[j + 1] << 1) | 1) & s[text.charAt(j)] |
          ((last_rd[j + 1] << 1) | 1) | ((last_rd[j] << 1) | 1) |
          last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore(d, j);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j;
          if (j > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(0, loc - (j - loc));
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode
 * @return {Object} Hash of character locations
 * @private
 */
diff_match_patch.prototype.match_alphabet = function (pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {patch_obj} patch The patch to grow
 * @param {string} text Source text
 * @private
 */
diff_match_patch.prototype.patch_addContext = function (patch, text) {
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
    pattern.length < this.Match_MaxBits - this.Patch_Margin
    - this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
      patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;
  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix !== '') {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
    patch.start2 + patch.length1 + padding);
  if (suffix !== '') {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are two ways to call this function:
 * Method 1:
 * a = Old text, b = New text, c = array of diff tuplle for a to b
 * Method 2:
 * a = Array of diff tuples for text 1 to text 2, b and c undefined
 * @param {string|Array.<Array.<*>>} a Old text (method 1) or Array of diff
 * tuples for text1 to text2 (method 2)
 * @param {string?} b New text (method 1)
 * @param {Array.<Array.<*>>} c Optional array of diff tuples for text1 to text2
 * (method 1)
 * @return {Array.<patch_obj>} Array of patch objects
 */
diff_match_patch.prototype.patch_make = function (a, b, c) {
  var text1, text2, diffs;
  if (typeof b == 'undefined') {
    diffs = a;
    text1 = this.diff_text1(diffs);
    text2 = '';  // text2 is not actually used.
  } else {
    text1 = a;
    text2 = b;
    if (typeof c != 'undefined') {
      diffs = c;
    } else {
      diffs = this.diff_main(text1, text2, true);
      if (diffs.length > 2) {
        this.diff_cleanupSemantic(diffs);
        this.diff_cleanupEfficiency(diffs);
      }
    }
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  var prepatch_text = text1;  // Recreate the patches to determine context info.
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
          postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
          postpatch_text.substring(char_count2 + diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
          patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext(patch, prepatch_text);
            patches.push(patch);
            patch = new patch_obj();
            patchDiffLength = 0;
            prepatch_text = postpatch_text;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {Array.<patch_obj>} patches Array of patch objects
 * @param {string} text Old text
 * @return {Array.<string|Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values
 */
diff_match_patch.prototype.patch_apply = function (patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new patch_obj();
    patchCopy.diffs = patch.diffs.slice();
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  patches = patchesCopy;

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc = this.match_main(text, text1, expected_loc);
    if (start_loc === null) {
      // No match found.  :(
      results[x] = false;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2 = text.substring(start_loc, start_loc + text1.length);
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
          this.diff_text2(patches[x].diffs) +
          text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indicies.
        var diffs = this.diff_main(text1, text2, false);
        this.diff_cleanupSemanticLossless(diffs);
        var index1 = 0;
        var index2;
        for (var y = 0; y < patches[x].diffs.length; y++) {
          var mod = patches[x].diffs[y];
          if (mod[0] !== DIFF_EQUAL) {
            index2 = this.diff_xIndex(diffs, index1);
          }
          if (mod[0] === DIFF_INSERT) {  // Insertion
            text = text.substring(0, start_loc + index2) + mod[1] +
              text.substring(start_loc + index2);
          } else if (mod[0] === DIFF_DELETE) {  // Deletion
            text = text.substring(0, start_loc + index2) +
              text.substring(start_loc + this.diff_xIndex(diffs,
                index1 + mod[1].length));
          }
          if (mod[0] !== DIFF_DELETE) {
            index1 += mod[1].length;
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * @param {Array.<patch_obj>} patches Array of patch objects
 * @return {string} The padding string added to each side.
 * @private
 */
diff_match_patch.prototype.patch_addPadding = function (patches) {
  var nullPadding = '';
  for (var x = 0; x < this.Patch_Margin; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += nullPadding.length;
    patches[x].start2 += nullPadding.length;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= nullPadding.length;  // Should be 0.
    patch.start2 -= nullPadding.length;  // Should be 0.
    patch.length1 += nullPadding.length;
    patch.length2 += nullPadding.length;
  } else if (nullPadding.length > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = nullPadding.length - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += nullPadding.length;
    patch.length2 += nullPadding.length;
  } else if (nullPadding.length > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = nullPadding.length - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * @param {Array.<patch_obj>} patches Array of patch objects
 */
diff_match_patch.prototype.patch_splitMax = function (patches) {
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 > this.Match_MaxBits) {
      var bigpatch = patches[x];
      // Remove the big old patch.
      patches.splice(x, 1);
      var patch_size = this.Match_MaxBits;
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = '';
      while (bigpatch.diffs.length !== 0) {
        // Create one of several smaller patches.
        var patch = new patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== '') {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push([DIFF_EQUAL, precontext]);
        }
        while (bigpatch.diffs.length !== 0 &&
          patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            // Insertions are harmless.
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else {
            // Deletion or equality.  Only take as much as we can stomach.
            diff_text = diff_text.substring(0, patch_size - patch.length1 -
              this.Patch_Margin);
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push([diff_type, diff_text]);
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        // Compute the head context for the next patch.
        precontext = this.diff_text2(patch.diffs);
        precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
        // Append the end context for this patch.
        var postcontext = this.diff_text1(bigpatch.diffs)
          .substring(0, this.Patch_Margin);
        if (postcontext !== '') {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push([DIFF_EQUAL, postcontext]);
          }
        }
        if (!empty) {
          patches.splice(x++, 0, patch);
        }
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {Array.<patch_obj>} patches Array of patch objects
 * @return {string} Text representation of patches
 */
diff_match_patch.prototype.patch_toText = function (patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of patch objects.
 * @param {string} textline Text representation of patches
 * @return {Array.<patch_obj>} Array of patch objects
 * @throws {Error} If invalid input
 */
diff_match_patch.prototype.patch_fromText = function (textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  // Opera doesn't know how to decode char 0.
  textline = textline.replace(/%00/g, '\0');
  var text = textline.split('\n');
  var textPointer = 0;
  while (textPointer < text.length) {
    var m = text[textPointer].match(/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
function patch_obj() {
  this.diffs = [];
  /** @type {number?} */
  this.start1 = null;
  /** @type {number?} */
  this.start2 = null;
  this.length1 = 0;
  this.length2 = 0;
}


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string
 */
patch_obj.prototype.toString = function () {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var txt = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    txt[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  // Opera doesn't know how to encode char 0.
  return txt.join('').replace(/\0/g, '%00').replace(/%20/g, ' ');
};

(function () {

  window.diff_match_patch = diff_match_patch;

}).call(this);

/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/jquery-bind.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/js/jquery-bind.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * jQuery JavaScript Library v1.4.3
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Oct 14 23:10:06 2010 -0400
 */

(function (window, undefined) {

    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document;
    var jQuery = (function () {

        // Define a local copy of jQuery
        var jQuery = function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context);
        },

            // Map over jQuery in case of overwrite
            _jQuery = window.jQuery,

            // Map over the $ in case of overwrite
            _$ = window.$,

            // A central reference to the root jQuery(document)
            rootjQuery,

            // A simple way to check for HTML strings or ID strings
            // (both of which we optimize for)
            quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,

            // Is it a simple selector
            isSimple = /^.[^:#\[\.,]*$/,

            // Check if a string has a non-whitespace character in it
            rnotwhite = /\S/,
            rwhite = /\s/,

            // Used for trimming whitespace
            trimLeft = /^\s+/,
            trimRight = /\s+$/,

            // Check for non-word characters
            rnonword = /\W/,

            // Check for digits
            rdigit = /\d/,

            // Match a standalone tag
            rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

            // JSON RegExp
            rvalidchars = /^[\],:{}\s]*$/,
            rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
            rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
            rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

            // Useragent RegExp
            rwebkit = /(webkit)[ \/]([\w.]+)/,
            ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
            rmsie = /(msie) ([\w.]+)/,
            rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

            // Keep a UserAgent string for use with jQuery.browser
            userAgent = navigator.userAgent,

            // For matching the engine and version of the browser
            browserMatch,

            // Has the ready events already been bound?
            readyBound = false,

            // The functions to execute on DOM ready
            readyList = [],

            // The ready event handler
            DOMContentLoaded,

            // Save a reference to some core methods
            toString = Object.prototype.toString,
            hasOwn = Object.prototype.hasOwnProperty,
            push = Array.prototype.push,
            slice = Array.prototype.slice,
            trim = String.prototype.trim,
            indexOf = Array.prototype.indexOf,

            // [[Class]] -> type pairs
            class2type = {};

        jQuery.fn = jQuery.prototype = {
            init: function (selector, context) {
                var match, elem, ret, doc;

                // Handle $(""), $(null), or $(undefined)
                if (!selector) {
                    return this;
                }

                // Handle $(DOMElement)
                if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                }

                // The body element only exists once, optimize finding it
                if (selector === "body" && !context && document.body) {
                    this.context = document;
                    this[0] = document.body;
                    this.selector = "body";
                    this.length = 1;
                    return this;
                }

                // Handle HTML strings
                if (typeof selector === "string") {
                    // Are we dealing with HTML string or an ID?
                    match = quickExpr.exec(selector);

                    // Verify a match, and that no context was specified for #id
                    if (match && (match[1] || !context)) {

                        // HANDLE: $(html) -> $(array)
                        if (match[1]) {
                            doc = (context ? context.ownerDocument || context : document);

                            // If a single string is passed in and it's a single tag
                            // just do a createElement and skip the rest
                            ret = rsingleTag.exec(selector);

                            if (ret) {
                                if (jQuery.isPlainObject(context)) {
                                    selector = [document.createElement(ret[1])];
                                    jQuery.fn.attr.call(selector, context, true);

                                } else {
                                    selector = [doc.createElement(ret[1])];
                                }

                            } else {
                                ret = jQuery.buildFragment([match[1]], [doc]);
                                selector = (ret.cacheable ? ret.fragment.cloneNode(true) : ret.fragment).childNodes;
                            }

                            return jQuery.merge(this, selector);

                            // HANDLE: $("#id")
                        } else {
                            elem = document.getElementById(match[2]);

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if (elem.id !== match[2]) {
                                    return rootjQuery.find(selector);
                                }

                                // Otherwise, we inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                        // HANDLE: $("TAG")
                    } else if (!context && !rnonword.test(selector)) {
                        this.selector = selector;
                        this.context = document;
                        selector = document.getElementsByTagName(selector);
                        return jQuery.merge(this, selector);

                        // HANDLE: $(expr, $(...))
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);

                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return jQuery(context).find(selector);
                    }

                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                    return rootjQuery.ready(selector);
                }

                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray(selector, this);
            },

            // Start with an empty selector
            selector: "",

            // The current version of jQuery being used
            jquery: "1.4.3",

            // The default length of a jQuery object is 0
            length: 0,

            // The number of elements contained in the matched element set
            size: function () {
                return this.length;
            },

            toArray: function () {
                return slice.call(this, 0);
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function (num) {
                return num == null ?

                    // Return a 'clean' array
                    this.toArray() :

                    // Return just the object
                    (num < 0 ? this.slice(num)[0] : this[num]);
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function (elems, name, selector) {
                // Build a new jQuery matched element set
                var ret = jQuery();

                if (jQuery.isArray(elems)) {
                    push.apply(ret, elems);

                } else {
                    jQuery.merge(ret, elems);
                }

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;

                ret.context = this.context;

                if (name === "find") {
                    ret.selector = this.selector + (this.selector ? " " : "") + selector;
                } else if (name) {
                    ret.selector = this.selector + "." + name + "(" + selector + ")";
                }

                // Return the newly-formed element set
                return ret;
            },

            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: function (callback, args) {
                return jQuery.each(this, callback, args);
            },

            ready: function (fn) {
                // Attach the listeners
                jQuery.bindReady();

                // If the DOM is already ready
                if (jQuery.isReady) {
                    // Execute the function immediately
                    fn.call(document, jQuery);

                    // Otherwise, remember the function for later
                } else if (readyList) {
                    // Add the function to the wait list
                    readyList.push(fn);
                }

                return this;
            },

            eq: function (i) {
                return i === -1 ?
                    this.slice(i) :
                    this.slice(i, +i + 1);
            },

            first: function () {
                return this.eq(0);
            },

            last: function () {
                return this.eq(-1);
            },

            slice: function () {
                return this.pushStack(slice.apply(this, arguments),
                    "slice", slice.call(arguments).join(","));
            },

            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },

            end: function () {
                return this.prevObject || jQuery(null);
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: [].sort,
            splice: [].splice
        };

        // Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = function () {
            // copy reference to target object
            var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy, copyIsArray;

            // Handle a deep copy situation
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {};
            }

            // extend jQuery itself if only one argument is passed
            if (length === i) {
                target = this;
                --i;
            }

            for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                    // Extend the base object
                    for (name in options) {
                        src = target[name];
                        copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[name] = jQuery.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        };

        jQuery.extend({
            noConflict: function (deep) {
                window.$ = _$;

                if (deep) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            },

            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Handle when the DOM is ready
            ready: function (wait) {
                // A third-party is pushing the ready event forwards
                if (wait === true) {
                    jQuery.readyWait--;
                }

                // Make sure that the DOM is not already loaded
                if (!jQuery.readyWait || (wait !== true && !jQuery.isReady)) {
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if (!document.body) {
                        return setTimeout(jQuery.ready, 1);
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    if (readyList) {
                        // Execute all of them
                        var fn, i = 0;
                        while ((fn = readyList[i++])) {
                            fn.call(document, jQuery);
                        }

                        // Reset the list of functions
                        readyList = null;
                    }

                    // Trigger any bound ready events
                    if (jQuery.fn.triggerHandler) {
                        jQuery(document).triggerHandler("ready");
                    }
                }
            },

            bindReady: function () {
                if (readyBound) {
                    return;
                }

                readyBound = true;

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if (document.readyState === "complete") {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    return setTimeout(jQuery.ready, 1);
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if (document.addEventListener) {
                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", jQuery.ready, false);

                    // If IE event model is used
                } else if (document.attachEvent) {
                    // ensure firing before onload,
                    // maybe late but safe also for iframes
                    document.attachEvent("onreadystatechange", DOMContentLoaded);

                    // A fallback to window.onload, that will always work
                    window.attachEvent("onload", jQuery.ready);

                    // If IE and not a frame
                    // continually check to see if the document is ready
                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) { }

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            },

            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function (obj) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || function (obj) {
                return jQuery.type(obj) === "array";
            },

            // A crude way of determining if an object is a window
            isWindow: function (obj) {
                return obj && typeof obj === "object" && "setInterval" in obj;
            },

            isNaN: function (obj) {
                return obj == null || !rdigit.test(obj) || isNaN(obj);
            },

            type: function (obj) {
                return obj == null ?
                    String(obj) :
                    class2type[toString.call(obj)] || "object";
            },

            isPlainObject: function (obj) {
                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }

                // Not own constructor property must be Object
                if (obj.constructor &&
                    !hasOwn.call(obj, "constructor") &&
                    !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.

                var key;
                for (key in obj) { }

                return key === undefined || hasOwn.call(obj, key);
            },

            isEmptyObject: function (obj) {
                for (var name in obj) {
                    return false;
                }
                return true;
            },

            error: function (msg) {
                throw msg;
            },

            parseJSON: function (data) {
                if (typeof data !== "string" || !data) {
                    return null;
                }

                // Make sure leading/trailing whitespace is removed (IE can't handle it)
                data = jQuery.trim(data);

                // Make sure the incoming data is actual JSON
                // Logic borrowed from http://json.org/json2.js
                if (rvalidchars.test(data.replace(rvalidescape, "@")
                    .replace(rvalidtokens, "]")
                    .replace(rvalidbraces, ""))) {

                    // Try to use the native JSON parser first
                    return window.JSON && window.JSON.parse ?
                        window.JSON.parse(data) :
                        (new Function("return " + data))();

                } else {
                    jQuery.error("Invalid JSON: " + data);
                }
            },

            noop: function () { },

            // Evalulates a script in a global context
            globalEval: function (data) {
                if (data && rnotwhite.test(data)) {
                    // Inspired by code by Andrea Giammarchi
                    // http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
                    var head = document.getElementsByTagName("head")[0] || document.documentElement,
                        script = document.createElement("script");

                    script.type = "text/javascript";

                    if (jQuery.support.scriptEval) {
                        script.appendChild(document.createTextNode(data));
                    } else {
                        script.text = data;
                    }

                    // Use insertBefore instead of appendChild to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709).
                    head.insertBefore(script, head.firstChild);
                    head.removeChild(script);
                }
            },

            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
            },

            // args is for internal usage only
            each: function (object, callback, args) {
                var name, i = 0,
                    length = object.length,
                    isObj = length === undefined || jQuery.isFunction(object);

                if (args) {
                    if (isObj) {
                        for (name in object) {
                            if (callback.apply(object[name], args) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length;) {
                            if (callback.apply(object[i++], args) === false) {
                                break;
                            }
                        }
                    }

                    // A special, fast, case for the most common use of each
                } else {
                    if (isObj) {
                        for (name in object) {
                            if (callback.call(object[name], name, object[name]) === false) {
                                break;
                            }
                        }
                    } else {
                        for (var value = object[0];
                            i < length && callback.call(value, i, value) !== false; value = object[++i]) { }
                    }
                }

                return object;
            },

            // Use native String.trim function wherever possible
            trim: trim ?
                function (text) {
                    return text == null ?
                        "" :
                        trim.call(text);
                } :

                // Otherwise use our own trimming functionality
                function (text) {
                    return text == null ?
                        "" :
                        text.toString().replace(trimLeft, "").replace(trimRight, "");
                },

            // results is for internal usage only
            makeArray: function (array, results) {
                var ret = results || [];

                if (array != null) {
                    // The window, strings (and functions) also have 'length'
                    // The extra typeof function check is to prevent crashes
                    // in Safari 2 (See: #3039)
                    // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                    var type = jQuery.type(array);

                    if (array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(array)) {
                        push.call(ret, array);
                    } else {
                        jQuery.merge(ret, array);
                    }
                }

                return ret;
            },

            inArray: function (elem, array) {
                if (array.indexOf) {
                    return array.indexOf(elem);
                }

                for (var i = 0, length = array.length; i < length; i++) {
                    if (array[i] === elem) {
                        return i;
                    }
                }

                return -1;
            },

            merge: function (first, second) {
                var i = first.length, j = 0;

                if (typeof second.length === "number") {
                    for (var l = second.length; j < l; j++) {
                        first[i++] = second[j];
                    }

                } else {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }

                first.length = i;

                return first;
            },

            grep: function (elems, callback, inv) {
                var ret = [], retVal;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for (var i = 0, length = elems.length; i < length; i++) {
                    retVal = !!callback(elems[i], i);
                    if (inv !== retVal) {
                        ret.push(elems[i]);
                    }
                }

                return ret;
            },

            // arg is for internal usage only
            map: function (elems, callback, arg) {
                var ret = [], value;

                // Go through the array, translating each of the items to their
                // new value (or values).
                for (var i = 0, length = elems.length; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret[ret.length] = value;
                    }
                }

                return ret.concat.apply([], ret);
            },

            // A global GUID counter for objects
            guid: 1,

            proxy: function (fn, proxy, thisObject) {
                if (arguments.length === 2) {
                    if (typeof proxy === "string") {
                        thisObject = fn;
                        fn = thisObject[proxy];
                        proxy = undefined;

                    } else if (proxy && !jQuery.isFunction(proxy)) {
                        thisObject = proxy;
                        proxy = undefined;
                    }
                }

                if (!proxy && fn) {
                    proxy = function () {
                        return fn.apply(thisObject || this, arguments);
                    };
                }

                // Set the guid of unique handler to the same of original handler, so it can be removed
                if (fn) {
                    proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
                }

                // So proxy can be declared as an argument
                return proxy;
            },

            // Mutifunctional method to get and set values to a collection
            // The value/s can be optionally by executed if its a function
            access: function (elems, key, value, exec, fn, pass) {
                var length = elems.length;

                // Setting many attributes
                if (typeof key === "object") {
                    for (var k in key) {
                        jQuery.access(elems, k, key[k], exec, fn, value);
                    }
                    return elems;
                }

                // Setting one attribute
                if (value !== undefined) {
                    // Optionally, function values get executed if exec is true
                    exec = !pass && exec && jQuery.isFunction(value);

                    for (var i = 0; i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }

                    return elems;
                }

                // Getting an attribute
                return length ? fn(elems[0], key) : undefined;
            },

            now: function () {
                return (new Date()).getTime();
            },

            // Use of jQuery.browser is frowned upon.
            // More details: http://docs.jquery.com/Utilities/jQuery.browser
            uaMatch: function (ua) {
                ua = ua.toLowerCase();

                var match = rwebkit.exec(ua) ||
                    ropera.exec(ua) ||
                    rmsie.exec(ua) ||
                    ua.indexOf("compatible") < 0 && rmozilla.exec(ua) ||
                    [];

                return { browser: match[1] || "", version: match[2] || "0" };
            },

            browser: {}
        });

        // Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        browserMatch = jQuery.uaMatch(userAgent);
        if (browserMatch.browser) {
            jQuery.browser[browserMatch.browser] = true;
            jQuery.browser.version = browserMatch.version;
        }

        // Deprecated, use jQuery.browser.webkit instead
        if (jQuery.browser.webkit) {
            jQuery.browser.safari = true;
        }

        if (indexOf) {
            jQuery.inArray = function (elem, array) {
                return indexOf.call(array, elem);
            };
        }

        // Verify that \s matches non-breaking spaces
        // (IE fails on this test)
        if (!rwhite.test("\xA0")) {
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

        // All jQuery objects should point back to these
        rootjQuery = jQuery(document);

        // Cleanup functions for the document ready method
        if (document.addEventListener) {
            DOMContentLoaded = function () {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function () {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (document.readyState === "complete") {
                    document.detachEvent("onreadystatechange", DOMContentLoaded);
                    jQuery.ready();
                }
            };
        }

        // The DOM ready check for Internet Explorer
        function doScrollCheck() {
            if (jQuery.isReady) {
                return;
            }

            try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
            } catch (e) {
                setTimeout(doScrollCheck, 1);
                return;
            }

            // and execute any waiting functions
            jQuery.ready();
        }

        // Expose jQuery to the global object
        return (window.jQuery = window.$ = jQuery);

    })();


    (function () {

        jQuery.support = {};

        var root = document.documentElement,
            script = document.createElement("script"),
            div = document.createElement("div"),
            id = "script" + jQuery.now();

        div.style.display = "none";
        div.innerHTML = "   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

        var all = div.getElementsByTagName("*"),
            a = div.getElementsByTagName("a")[0],
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));

        // Can't get basic test support
        if (!all || !all.length || !a) {
            return;
        }

        jQuery.support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: div.firstChild.nodeType === 3,

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText insted)
            style: /red/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: a.getAttribute("href") === "/a",

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55$/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: div.getElementsByTagName("input")[0].value === "on",

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Will be defined later
            optDisabled: false,
            checkClone: false,
            scriptEval: false,
            noCloneEvent: true,
            boxModel: null,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableHiddenOffsets: true
        };

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as diabled)
        select.disabled = true;
        jQuery.support.optDisabled = !opt.disabled;

        script.type = "text/javascript";
        try {
            script.appendChild(document.createTextNode("window." + id + "=1;"));
        } catch (e) { }

        root.insertBefore(script, root.firstChild);

        // Make sure that the execution of code works by injecting a script
        // tag with appendChild/createTextNode
        // (IE doesn't support this, fails, and uses .text instead)
        if (window[id]) {
            jQuery.support.scriptEval = true;
            delete window[id];
        }

        root.removeChild(script);

        if (div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", function click() {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                jQuery.support.noCloneEvent = false;
                div.detachEvent("onclick", click);
            });
            div.cloneNode(true).fireEvent("onclick");
        }

        div = document.createElement("div");
        div.innerHTML = "<input type='radio' name='radiotest' checked='checked'/>";

        var fragment = document.createDocumentFragment();
        fragment.appendChild(div.firstChild);

        // WebKit doesn't clone checked state correctly in fragments
        jQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        // Figure out if the W3C box model works as expected
        // document.body must exist before we can do this
        jQuery(function () {
            var div = document.createElement("div");
            div.style.width = div.style.paddingLeft = "1px";

            document.body.appendChild(div);
            jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;

            if ("zoom" in div.style) {
                // Check if natively block-level elements act like inline-block
                // elements when setting their display to 'inline' and giving
                // them layout
                // (IE < 8 does this)
                div.style.display = "inline";
                div.style.zoom = 1;
                jQuery.support.inlineBlockNeedsLayout = div.offsetWidth === 2;

                // Check if elements with layout shrink-wrap their children
                // (IE 6 does this)
                div.style.display = "";
                div.innerHTML = "<div style='width:4px;'></div>";
                jQuery.support.shrinkWrapBlocks = div.offsetWidth !== 2;
            }

            div.innerHTML = "<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";
            var tds = div.getElementsByTagName("td");

            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            // (only IE 8 fails this test)
            jQuery.support.reliableHiddenOffsets = tds[0].offsetHeight === 0;

            tds[0].style.display = "";
            tds[1].style.display = "none";

            // Check if empty table cells still have offsetWidth/Height
            // (IE < 8 fail this test)
            jQuery.support.reliableHiddenOffsets = jQuery.support.reliableHiddenOffsets && tds[0].offsetHeight === 0;
            div.innerHTML = "";

            document.body.removeChild(div).style.display = "none";
            div = tds = null;
        });

        // Technique from Juriy Zaytsev
        // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
        var eventSupported = function (eventName) {
            var el = document.createElement("div");
            eventName = "on" + eventName;

            var isSupported = (eventName in el);
            if (!isSupported) {
                el.setAttribute(eventName, "return;");
                isSupported = typeof el[eventName] === "function";
            }
            el = null;

            return isSupported;
        };

        jQuery.support.submitBubbles = eventSupported("submit");
        jQuery.support.changeBubbles = eventSupported("change");

        // release memory in IE
        root = script = div = all = a = null;
    })();

    jQuery.props = {
        "for": "htmlFor",
        "class": "className",
        readonly: "readOnly",
        maxlength: "maxLength",
        cellspacing: "cellSpacing",
        rowspan: "rowSpan",
        colspan: "colSpan",
        tabindex: "tabIndex",
        usemap: "useMap",
        frameborder: "frameBorder"
    };




    var windowData = {},
        rbrace = /^(?:\{.*\}|\[.*\])$/;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page	
        expando: "jQuery" + jQuery.now(),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        data: function (elem, name, data) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            elem = elem == window ?
                windowData :
                elem;

            var isNode = elem.nodeType,
                id = isNode ? elem[jQuery.expando] : null,
                cache = jQuery.cache, thisCache;

            if (isNode && !id && typeof name === "string" && data === undefined) {
                return;
            }

            // Get the data from the object directly
            if (!isNode) {
                cache = elem;

                // Compute a unique ID for the element
            } else if (!id) {
                elem[jQuery.expando] = id = ++jQuery.uuid;
            }

            // Avoid generating a new cache unless none exists and we
            // want to manipulate it.
            if (typeof name === "object") {
                if (isNode) {
                    cache[id] = jQuery.extend(cache[id], name);

                } else {
                    jQuery.extend(cache, name);
                }

            } else if (isNode && !cache[id]) {
                cache[id] = {};
            }

            thisCache = isNode ? cache[id] : cache;

            // Prevent overriding the named cache with undefined values
            if (data !== undefined) {
                thisCache[name] = data;
            }

            return typeof name === "string" ? thisCache[name] : thisCache;
        },

        removeData: function (elem, name) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            elem = elem == window ?
                windowData :
                elem;

            var isNode = elem.nodeType,
                id = isNode ? elem[jQuery.expando] : elem,
                cache = jQuery.cache,
                thisCache = isNode ? cache[id] : id;

            // If we want to remove a specific section of the element's data
            if (name) {
                if (thisCache) {
                    // Remove the section of cache data
                    delete thisCache[name];

                    // If we've removed all the data, remove the element's cache
                    if (isNode && jQuery.isEmptyObject(thisCache)) {
                        jQuery.removeData(elem);
                    }
                }

                // Otherwise, we want to remove all of the element's data
            } else {
                if (isNode && jQuery.support.deleteExpando) {
                    delete elem[jQuery.expando];

                } else if (elem.removeAttribute) {
                    elem.removeAttribute(jQuery.expando);

                    // Completely remove the data cache
                } else if (isNode) {
                    delete cache[id];

                    // Remove all fields from the object
                } else {
                    for (var n in elem) {
                        delete elem[n];
                    }
                }
            }
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function (elem) {
            if (elem.nodeName) {
                var match = jQuery.noData[elem.nodeName.toLowerCase()];

                if (match) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }

            return true;
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            if (typeof key === "undefined") {
                return this.length ? jQuery.data(this[0]) : null;

            } else if (typeof key === "object") {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            var parts = key.split(".");
            parts[1] = parts[1] ? "." + parts[1] : "";

            if (value === undefined) {
                var data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if (data === undefined && this.length) {
                    data = jQuery.data(this[0], key);

                    // If nothing was found internally, try to fetch any
                    // data from the HTML5 data-* attribute
                    if (data === undefined && this[0].nodeType === 1) {
                        data = this[0].getAttribute("data-" + key);

                        if (typeof data === "string") {
                            try {
                                data = data === "true" ? true :
                                    data === "false" ? false :
                                        data === "null" ? null :
                                            !jQuery.isNaN(data) ? parseFloat(data) :
                                                rbrace.test(data) ? jQuery.parseJSON(data) :
                                                    data;
                            } catch (e) { }

                        } else {
                            data = undefined;
                        }
                    }
                }

                return data === undefined && parts[1] ?
                    this.data(parts[0]) :
                    data;

            } else {
                return this.each(function () {
                    var $this = jQuery(this), args = [parts[0], value];

                    $this.triggerHandler("setData" + parts[1] + "!", args);
                    jQuery.data(this, key, value);
                    $this.triggerHandler("changeData" + parts[1] + "!", args);
                });
            }
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });




    jQuery.extend({
        queue: function (elem, type, data) {
            if (!elem) {
                return;
            }

            type = (type || "fx") + "queue";
            var q = jQuery.data(elem, type);

            // Speed up dequeue by getting out quickly if this is just a lookup
            if (!data) {
                return q || [];
            }

            if (!q || jQuery.isArray(data)) {
                q = jQuery.data(elem, type, jQuery.makeArray(data));

            } else {
                q.push(data);
            }

            return q;
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type), fn = queue.shift();

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
            }

            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                fn.call(elem, function () {
                    jQuery.dequeue(elem, type);
                });
            }
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            if (typeof type !== "string") {
                data = type;
                type = "fx";
            }

            if (data === undefined) {
                return jQuery.queue(this[0], type);
            }
            return this.each(function (i) {
                var queue = jQuery.queue(this, type, data);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },

        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue(type, function () {
                var elem = this;
                setTimeout(function () {
                    jQuery.dequeue(elem, type);
                }, time);
            });
        },

        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        }
    });




    var rclass = /[\n\t]/g,
        rspaces = /\s+/,
        rreturn = /\r/g,
        rspecialurl = /^(?:href|src|style)$/,
        rtype = /^(?:button|input)$/i,
        rfocusable = /^(?:button|input|object|select|textarea)$/i,
        rclickable = /^a(?:rea)?$/i,
        rradiocheck = /^(?:radio|checkbox)$/i;

    jQuery.fn.extend({
        attr: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.attr);
        },

        removeAttr: function (name, fn) {
            return this.each(function () {
                jQuery.attr(this, name, "");
                if (this.nodeType === 1) {
                    this.removeAttribute(name);
                }
            });
        },

        addClass: function (value) {
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self.addClass(value.call(this, i, self.attr("class")));
                });
            }

            if (value && typeof value === "string") {
                var classNames = (value || "").split(rspaces);

                for (var i = 0, l = this.length; i < l; i++) {
                    var elem = this[i];

                    if (elem.nodeType === 1) {
                        if (!elem.className) {
                            elem.className = value;

                        } else {
                            var className = " " + elem.className + " ", setClass = elem.className;
                            for (var c = 0, cl = classNames.length; c < cl; c++) {
                                if (className.indexOf(" " + classNames[c] + " ") < 0) {
                                    setClass += " " + classNames[c];
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self.removeClass(value.call(this, i, self.attr("class")));
                });
            }

            if ((value && typeof value === "string") || value === undefined) {
                var classNames = (value || "").split(rspaces);

                for (var i = 0, l = this.length; i < l; i++) {
                    var elem = this[i];

                    if (elem.nodeType === 1 && elem.className) {
                        if (value) {
                            var className = (" " + elem.className + " ").replace(rclass, " ");
                            for (var c = 0, cl = classNames.length; c < cl; c++) {
                                className = className.replace(" " + classNames[c] + " ", " ");
                            }
                            elem.className = jQuery.trim(className);

                        } else {
                            elem.className = "";
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value, isBool = typeof stateVal === "boolean";

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self.toggleClass(value.call(this, i, self.attr("class"), stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === "string") {
                    // toggle individual class names
                    var className, i = 0, self = jQuery(this),
                        state = stateVal,
                        classNames = value.split(rspaces);

                    while ((className = classNames[i++])) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }

                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery.data(this, "__className__", this.className);
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery.data(this, "__className__") || "";
                }
            });
        },

        hasClass: function (selector) {
            var className = " " + selector + " ";
            for (var i = 0, l = this.length; i < l; i++) {
                if ((" " + this[i].className + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        },

        val: function (value) {
            if (!arguments.length) {
                var elem = this[0];

                if (elem) {
                    if (jQuery.nodeName(elem, "option")) {
                        // attributes.value is undefined in Blackberry 4.7 but
                        // uses .value. See #6932
                        var val = elem.attributes.value;
                        return !val || val.specified ? elem.value : elem.text;
                    }

                    // We need to handle select boxes special
                    if (jQuery.nodeName(elem, "select")) {
                        var index = elem.selectedIndex,
                            values = [],
                            options = elem.options,
                            one = elem.type === "select-one";

                        // Nothing was selected
                        if (index < 0) {
                            return null;
                        }

                        // Loop through all the selected options
                        for (var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++) {
                            var option = options[i];

                            // Don't return options that are disabled or in a disabled optgroup
                            if (option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                                (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                                // Get the specific value for the option
                                value = jQuery(option).val();

                                // We don't need an array for one selects
                                if (one) {
                                    return value;
                                }

                                // Multi-Selects return an array
                                values.push(value);
                            }
                        }

                        return values;
                    }

                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    if (rradiocheck.test(elem.type) && !jQuery.support.checkOn) {
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    }


                    // Everything else, we just grab the value
                    return (elem.value || "").replace(rreturn, "");

                }

                return undefined;
            }

            var isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var self = jQuery(this), val = value;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, self.val());
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                if (jQuery.isArray(val) && rradiocheck.test(this.type)) {
                    this.checked = jQuery.inArray(self.val(), val) >= 0;

                } else if (jQuery.nodeName(this, "select")) {
                    var values = jQuery.makeArray(val);

                    jQuery("option", this).each(function () {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });

                    if (!values.length) {
                        this.selectedIndex = -1;
                    }

                } else {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attr: function (elem, name, value, pass) {
            // don't set attributes on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8) {
                return undefined;
            }

            if (pass && name in jQuery.attrFn) {
                return jQuery(elem)[name](value);
            }

            var notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc(elem),
                // Whether we are setting (or getting)
                set = value !== undefined;

            // Try to normalize/fix the name
            name = notxml && jQuery.props[name] || name;

            // Only do all the following if this is a node (faster for style)
            if (elem.nodeType === 1) {
                // These attributes require special treatment
                var special = rspecialurl.test(name);

                // Safari mis-reports the default selected property of an option
                // Accessing the parent's selectedIndex property fixes it
                if (name === "selected" && !jQuery.support.optSelected) {
                    var parent = elem.parentNode;
                    if (parent) {
                        parent.selectedIndex;

                        // Make sure that it also works with optgroups, see #5701
                        if (parent.parentNode) {
                            parent.parentNode.selectedIndex;
                        }
                    }
                }

                // If applicable, access the attribute via the DOM 0 way
                // 'in' checks fail in Blackberry 4.7 #6931
                if ((name in elem || elem[name] !== undefined) && notxml && !special) {
                    if (set) {
                        // We can't allow the type property to be changed (since it causes problems in IE)
                        if (name === "type" && rtype.test(elem.nodeName) && elem.parentNode) {
                            jQuery.error("type property can't be changed");
                        }

                        if (value === null) {
                            if (elem.nodeType === 1) {
                                elem.removeAttribute(name);
                            }

                        } else {
                            elem[name] = value;
                        }
                    }

                    // browsers index elements by id/name on forms, give priority to attributes.
                    if (jQuery.nodeName(elem, "form") && elem.getAttributeNode(name)) {
                        return elem.getAttributeNode(name).nodeValue;
                    }

                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    if (name === "tabIndex") {
                        var attributeNode = elem.getAttributeNode("tabIndex");

                        return attributeNode && attributeNode.specified ?
                            attributeNode.value :
                            rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
                                0 :
                                undefined;
                    }

                    return elem[name];
                }

                if (!jQuery.support.style && notxml && name === "style") {
                    if (set) {
                        elem.style.cssText = "" + value;
                    }

                    return elem.style.cssText;
                }

                if (set) {
                    // convert the value to a string (all browsers do this but IE) see #1070
                    elem.setAttribute(name, "" + value);
                }

                // Ensure that missing attributes return undefined
                // Blackberry 4.7 returns "" from getAttribute #6938
                if (!elem.attributes[name] && (elem.hasAttribute && !elem.hasAttribute(name))) {
                    return undefined;
                }

                var attr = !jQuery.support.hrefNormalized && notxml && special ?
                    // Some attributes require a special call on IE
                    elem.getAttribute(name, 2) :
                    elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return attr === null ? undefined : attr;
            }
        }
    });




    var rnamespaces = /\.(.*)$/,
        rformElems = /^(?:textarea|input|select)$/i,
        rperiod = /\./g,
        rspace = / /g,
        rescape = /[^\w\s.|`]/g,
        fcleanup = function (nm) {
            return nm.replace(rescape, "\\$&");
        },
        focusCounts = { focusin: 0, focusout: 0 };

    /*
     * A number of helper functions used for managing events.
     * Many of the ideas behind this code originated from
     * Dean Edwards' addEvent library.
     */
    jQuery.event = {

        // Bind an event to an element
        // Original by Dean Edwards
        add: function (elem, types, handler, data) {
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // For whatever reason, IE has trouble passing the window object
            // around, causing it to be cloned in the process
            if (jQuery.isWindow(elem) && (elem !== window && !elem.frameElement)) {
                elem = window;
            }

            if (handler === false) {
                handler = returnFalse;
            }

            var handleObjIn, handleObj;

            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
            }

            // Make sure that the function being executed has a unique ID
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure
            var elemData = jQuery.data(elem);

            // If no elemData is found then we must be trying to bind to one of the
            // banned noData elements
            if (!elemData) {
                return;
            }

            // Use a key less likely to result in collisions for plain JS objects.
            // Fixes bug #7150.
            var eventKey = elem.nodeType ? "events" : "__events__",
                events = elemData[eventKey],
                eventHandle = elemData.handle;

            if (typeof events === "function") {
                // On plain objects events is a fn that holds the the data
                // which prevents this data from being JSON serialized
                // the function does not need to be called, it just contains the data
                eventHandle = events.handle;
                events = events.events;

            } else if (!events) {
                if (!elem.nodeType) {
                    // On plain objects, create a fn that acts as the holder
                    // of the values to avoid JSON serialization of event data
                    elemData[eventKey] = elemData = function () { };
                }

                elemData.events = events = {};
            }

            if (!eventHandle) {
                elemData.handle = eventHandle = function () {
                    // Handle the second event of a trigger and when
                    // an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && !jQuery.event.triggered ?
                        jQuery.event.handle.apply(eventHandle.elem, arguments) :
                        undefined;
                };
            }

            // Add elem as a property of the handle function
            // This is to prevent a memory leak with non-native events in IE.
            eventHandle.elem = elem;

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = types.split(" ");

            var type, i = 0, namespaces;

            while ((type = types[i++])) {
                handleObj = handleObjIn ?
                    jQuery.extend({}, handleObjIn) :
                    { handler: handler, data: data };

                // Namespaced event handlers
                if (type.indexOf(".") > -1) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    handleObj.namespace = namespaces.slice(0).sort().join(".");

                } else {
                    namespaces = [];
                    handleObj.namespace = "";
                }

                handleObj.type = type;
                if (!handleObj.guid) {
                    handleObj.guid = handler.guid;
                }

                // Get the current list of functions bound to this event
                var handlers = events[type],
                    special = jQuery.event.special[type] || {};

                // Init the event handler queue
                if (!handlers) {
                    handlers = events[type] = [];

                    // Check for a special event handler
                    // Only use addEventListener/attachEvent if the special
                    // events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add the function to the element's handler list
                handlers.push(handleObj);

                // Keep track of which events have been used, for global triggering
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, pos) {
            // don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            }

            var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
                eventKey = elem.nodeType ? "events" : "__events__",
                elemData = jQuery.data(elem),
                events = elemData && elemData[eventKey];

            if (!elemData || !events) {
                return;
            }

            if (typeof events === "function") {
                elemData = events;
                events = events.events;
            }

            // types is actually an event object here
            if (types && types.type) {
                handler = types.handler;
                types = types.type;
            }

            // Unbind all events for the element
            if (!types || typeof types === "string" && types.charAt(0) === ".") {
                types = types || "";

                for (type in events) {
                    jQuery.event.remove(elem, type + types);
                }

                return;
            }

            // Handle multiple events separated by a space
            // jQuery(...).unbind("mouseover mouseout", fn);
            types = types.split(" ");

            while ((type = types[i++])) {
                origType = type;
                handleObj = null;
                all = type.indexOf(".") < 0;
                namespaces = [];

                if (!all) {
                    // Namespaced event handlers
                    namespaces = type.split(".");
                    type = namespaces.shift();

                    namespace = new RegExp("(^|\\.)" +
                        jQuery.map(namespaces.slice(0).sort(), fcleanup).join("\\.(?:.*\\.)?") + "(\\.|$)");
                }

                eventType = events[type];

                if (!eventType) {
                    continue;
                }

                if (!handler) {
                    for (j = 0; j < eventType.length; j++) {
                        handleObj = eventType[j];

                        if (all || namespace.test(handleObj.namespace)) {
                            jQuery.event.remove(elem, origType, handleObj.handler, j);
                            eventType.splice(j--, 1);
                        }
                    }

                    continue;
                }

                special = jQuery.event.special[type] || {};

                for (j = pos || 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if (handler.guid === handleObj.guid) {
                        // remove the given handler for the given type
                        if (all || namespace.test(handleObj.namespace)) {
                            if (pos == null) {
                                eventType.splice(j--, 1);
                            }

                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }

                        if (pos != null) {
                            break;
                        }
                    }
                }

                // remove generic event handler if no more handlers exist
                if (eventType.length === 0 || pos != null && eventType.length === 1) {
                    if (!special.teardown || special.teardown.call(elem, namespaces) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    ret = null;
                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                var handle = elemData.handle;
                if (handle) {
                    handle.elem = null;
                }

                delete elemData.events;
                delete elemData.handle;

                if (typeof elemData === "function") {
                    jQuery.removeData(elem, eventKey);

                } else if (jQuery.isEmptyObject(elemData)) {
                    jQuery.removeData(elem);
                }
            }
        },

        // bubbling is internal
        trigger: function (event, data, elem /*, bubbling */) {
            // Event object or event type
            var type = event.type || event,
                bubbling = arguments[3];

            if (!bubbling) {
                event = typeof event === "object" ?
                    // jQuery.Event object
                    event[jQuery.expando] ? event :
                        // Object literal
                        jQuery.extend(jQuery.Event(type), event) :
                    // Just the event type (string)
                    jQuery.Event(type);

                if (type.indexOf("!") >= 0) {
                    event.type = type = type.slice(0, -1);
                    event.exclusive = true;
                }

                // Handle a global trigger
                if (!elem) {
                    // Don't bubble custom events when global (to avoid too much overhead)
                    event.stopPropagation();

                    // Only trigger if we've ever bound an event for it
                    if (jQuery.event.global[type]) {
                        jQuery.each(jQuery.cache, function () {
                            if (this.events && this.events[type]) {
                                jQuery.event.trigger(event, data, this.handle.elem);
                            }
                        });
                    }
                }

                // Handle triggering a single element

                // don't do events on text and comment nodes
                if (!elem || elem.nodeType === 3 || elem.nodeType === 8) {
                    return undefined;
                }

                // Clean up in case it is reused
                event.result = undefined;
                event.target = elem;

                // Clone the incoming data, if any
                data = jQuery.makeArray(data);
                data.unshift(event);
            }

            event.currentTarget = elem;

            // Trigger the event, it is assumed that "handle" is a function
            var handle = elem.nodeType ?
                jQuery.data(elem, "handle") :
                (jQuery.data(elem, "__events__") || {}).handle;

            if (handle) {
                handle.apply(elem, data);
            }

            var parent = elem.parentNode || elem.ownerDocument;

            // Trigger an inline bound script
            try {
                if (!(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()])) {
                    if (elem["on" + type] && elem["on" + type].apply(elem, data) === false) {
                        event.result = false;
                        event.preventDefault();
                    }
                }

                // prevent IE from throwing an error for some elements with some event types, see #3533
            } catch (inlineError) { }

            if (!event.isPropagationStopped() && parent) {
                jQuery.event.trigger(event, data, parent, true);

            } else if (!event.isDefaultPrevented()) {
                var target = event.target, old, targetType = type.replace(rnamespaces, ""),
                    isClick = jQuery.nodeName(target, "a") && targetType === "click",
                    special = jQuery.event.special[targetType] || {};

                if ((!special._default || special._default.call(elem, event) === false) &&
                    !isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()])) {

                    try {
                        if (target[targetType]) {
                            // Make sure that we don't accidentally re-trigger the onFOO events
                            old = target["on" + targetType];

                            if (old) {
                                target["on" + targetType] = null;
                            }

                            jQuery.event.triggered = true;
                            target[targetType]();
                        }

                        // prevent IE from throwing an error for some elements with some event types, see #3533
                    } catch (triggerError) { }

                    if (old) {
                        target["on" + targetType] = old;
                    }

                    jQuery.event.triggered = false;
                }
            }
        },

        handle: function (event) {
            var all, handlers, namespaces, namespace_sort = [], namespace_re, events, args = jQuery.makeArray(arguments);

            event = args[0] = jQuery.event.fix(event || window.event);
            event.currentTarget = this;

            // Namespaced event handlers
            all = event.type.indexOf(".") < 0 && !event.exclusive;

            if (!all) {
                namespaces = event.type.split(".");
                event.type = namespaces.shift();
                namespace_sort = namespaces.slice(0).sort();
                namespace_re = new RegExp("(^|\\.)" + namespace_sort.join("\\.(?:.*\\.)?") + "(\\.|$)");
            }

            event.namespace = event.namespace || namespace_sort.join(".");

            events = jQuery.data(this, this.nodeType ? "events" : "__events__");

            if (typeof events === "function") {
                events = events.events;
            }

            handlers = (events || {})[event.type];

            if (events && handlers) {
                // Clone the handlers to prevent manipulation
                handlers = handlers.slice(0);

                for (var j = 0, l = handlers.length; j < l; j++) {
                    var handleObj = handlers[j];

                    // Filter the functions by class
                    if (all || namespace_re.test(handleObj.namespace)) {
                        // Pass in a reference to the handler function itself
                        // So that we can later remove it
                        event.handler = handleObj.handler;
                        event.data = handleObj.data;
                        event.handleObj = handleObj;

                        var ret = handleObj.handler.apply(this, args);

                        if (ret !== undefined) {
                            event.result = ret;
                            if (ret === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }

                        if (event.isImmediatePropagationStopped()) {
                            break;
                        }
                    }
                }
            }

            return event.result;
        },

        props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // store a copy of the original event object
            // and "clone" to set read-only properties
            var originalEvent = event;
            event = jQuery.Event(originalEvent);

            for (var i = this.props.length, prop; i;) {
                prop = this.props[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary
            if (!event.target) {
                event.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either
            }

            // check if target is a textnode (safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // Add relatedTarget, if necessary
            if (!event.relatedTarget && event.fromElement) {
                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
            }

            // Calculate pageX/Y if missing and clientX/Y available
            if (event.pageX == null && event.clientX != null) {
                var doc = document.documentElement, body = document.body;
                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }

            // Add which for key events
            if (event.which == null && (event.charCode != null || event.keyCode != null)) {
                event.which = event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
            if (!event.metaKey && event.ctrlKey) {
                event.metaKey = event.ctrlKey;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if (!event.which && event.button !== undefined) {
                event.which = (event.button & 1 ? 1 : (event.button & 2 ? 3 : (event.button & 4 ? 2 : 0)));
            }

            return event;
        },

        // Deprecated, use jQuery.guid instead
        guid: 1E8,

        // Deprecated, use jQuery.proxy instead
        proxy: jQuery.proxy,

        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady,
                teardown: jQuery.noop
            },

            live: {
                add: function (handleObj) {
                    jQuery.event.add(this,
                        liveConvert(handleObj.origType, handleObj.selector),
                        jQuery.extend({}, handleObj, { handler: liveHandler, guid: handleObj.handler.guid }));
                },

                remove: function (handleObj) {
                    jQuery.event.remove(this, liveConvert(handleObj.origType, handleObj.selector), handleObj);
                }
            },

            beforeunload: {
                setup: function (data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function (namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = document.removeEventListener ?
        function (elem, type, handle) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, handle, false);
            }
        } :
        function (elem, type, handle) {
            if (elem.detachEvent) {
                elem.detachEvent("on" + type, handle);
            }
        };

    jQuery.Event = function (src) {
        // Allow instantiation without the 'new' keyword
        if (!this.preventDefault) {
            return new jQuery.Event(src);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            // Event type
        } else {
            this.type = src;
        }

        // timeStamp is buggy for some events on Firefox(#3843)
        // So we won't rely on the native value
        this.timeStamp = jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }

            // if preventDefault exists run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Checks if an event happened on an element within another element
    // Used in jQuery.event.special.mouseenter and mouseleave handlers
    var withinElement = function (event) {
        // Check if mouse(over|out) are still within the same parent element
        var parent = event.relatedTarget;

        // Firefox sometimes assigns relatedTarget a XUL element
        // which we cannot access the parentNode property of
        try {
            // Traverse up the tree
            while (parent && parent !== this) {
                parent = parent.parentNode;
            }

            if (parent !== this) {
                // set the correct event type
                event.type = event.data;

                // handle event if we actually just moused on to a non sub-element
                jQuery.event.handle.apply(this, arguments);
            }

            // assuming we've left the element since we most likely mousedover a xul element
        } catch (e) { }
    },

        // In case of event delegation, we only need to rename the event.type,
        // liveHandler will take care of the rest.
        delegate = function (event) {
            event.type = event.data;
            jQuery.event.handle.apply(this, arguments);
        };

    // Create mouseenter and mouseleave events
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            setup: function (data) {
                jQuery.event.add(this, fix, data && data.selector ? delegate : withinElement, orig);
            },
            teardown: function (data) {
                jQuery.event.remove(this, fix, data && data.selector ? delegate : withinElement);
            }
        };
    });

    // submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function (data, namespaces) {
                if (this.nodeName.toLowerCase() !== "form") {
                    jQuery.event.add(this, "click.specialSubmit", function (e) {
                        var elem = e.target, type = elem.type;

                        if ((type === "submit" || type === "image") && jQuery(elem).closest("form").length) {
                            e.liveFired = undefined;
                            return trigger("submit", this, arguments);
                        }
                    });

                    jQuery.event.add(this, "keypress.specialSubmit", function (e) {
                        var elem = e.target, type = elem.type;

                        if ((type === "text" || type === "password") && jQuery(elem).closest("form").length && e.keyCode === 13) {
                            e.liveFired = undefined;
                            return trigger("submit", this, arguments);
                        }
                    });

                } else {
                    return false;
                }
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialSubmit");
            }
        };

    }

    // change delegation, happens here so we have bind.
    if (!jQuery.support.changeBubbles) {

        var changeFilters,

            getVal = function (elem) {
                var type = elem.type, val = elem.value;

                if (type === "radio" || type === "checkbox") {
                    val = elem.checked;

                } else if (type === "select-multiple") {
                    val = elem.selectedIndex > -1 ?
                        jQuery.map(elem.options, function (elem) {
                            return elem.selected;
                        }).join("-") :
                        "";

                } else if (elem.nodeName.toLowerCase() === "select") {
                    val = elem.selectedIndex;
                }

                return val;
            },

            testChange = function testChange(e) {
                var elem = e.target, data, val;

                if (!rformElems.test(elem.nodeName) || elem.readOnly) {
                    return;
                }

                data = jQuery.data(elem, "_change_data");
                val = getVal(elem);

                // the current data will be also retrieved by beforeactivate
                if (e.type !== "focusout" || elem.type !== "radio") {
                    jQuery.data(elem, "_change_data", val);
                }

                if (data === undefined || val === data) {
                    return;
                }

                if (data != null || val) {
                    e.type = "change";
                    e.liveFired = undefined;
                    return jQuery.event.trigger(e, arguments[1], elem);
                }
            };

        jQuery.event.special.change = {
            filters: {
                focusout: testChange,

                beforedeactivate: testChange,

                click: function (e) {
                    var elem = e.target, type = elem.type;

                    if (type === "radio" || type === "checkbox" || elem.nodeName.toLowerCase() === "select") {
                        return testChange.call(this, e);
                    }
                },

                // Change has to be called before submit
                // Keydown will be called before keypress, which is used in submit-event delegation
                keydown: function (e) {
                    var elem = e.target, type = elem.type;

                    if ((e.keyCode === 13 && elem.nodeName.toLowerCase() !== "textarea") ||
                        (e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
                        type === "select-multiple") {
                        return testChange.call(this, e);
                    }
                },

                // Beforeactivate happens also before the previous element is blurred
                // with this event you can't trigger a change event, but you can store
                // information
                beforeactivate: function (e) {
                    var elem = e.target;
                    jQuery.data(elem, "_change_data", getVal(elem));
                }
            },

            setup: function (data, namespaces) {
                if (this.type === "file") {
                    return false;
                }

                for (var type in changeFilters) {
                    jQuery.event.add(this, type + ".specialChange", changeFilters[type]);
                }

                return rformElems.test(this.nodeName);
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialChange");

                return rformElems.test(this.nodeName);
            }
        };

        changeFilters = jQuery.event.special.change.filters;

        // Handle when the input is .focus()'d
        changeFilters.focus = changeFilters.beforeactivate;
    }

    function trigger(type, elem, args) {
        args[0].type = type;
        return jQuery.event.handle.apply(elem, args);
    }

    // Create "bubbling" focus and blur events
    if (document.addEventListener) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {
            jQuery.event.special[fix] = {
                setup: function () {
                    if (focusCounts[fix]++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function () {
                    if (--focusCounts[fix] === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };

            function handler(e) {
                e = jQuery.event.fix(e);
                e.type = fix;
                return jQuery.event.trigger(e, null, e.target);
            }
        });
    }

    jQuery.each(["bind", "one"], function (i, name) {
        jQuery.fn[name] = function (type, data, fn) {
            // Handle object literals
            if (typeof type === "object") {
                for (var key in type) {
                    this[name](key, data, type[key], fn);
                }
                return this;
            }

            if (jQuery.isFunction(data) || data === false) {
                fn = data;
                data = undefined;
            }

            var handler = name === "one" ? jQuery.proxy(fn, function (event) {
                jQuery(this).unbind(event, handler);
                return fn.apply(this, arguments);
            }) : fn;

            if (type === "unload" && name !== "one") {
                this.one(type, data, fn);

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.add(this[i], type, handler, data);
                }
            }

            return this;
        };
    });

    jQuery.fn.extend({
        unbind: function (type, fn) {
            // Handle object literals
            if (typeof type === "object" && !type.preventDefault) {
                for (var key in type) {
                    this.unbind(key, type[key]);
                }

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.remove(this[i], type, fn);
                }
            }

            return this;
        },

        delegate: function (selector, types, data, fn) {
            return this.live(types, data, fn, selector);
        },

        undelegate: function (selector, types, fn) {
            if (arguments.length === 0) {
                return this.unbind("live");

            } else {
                return this.die(types, null, fn, selector);
            }
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },

        triggerHandler: function (type, data) {
            if (this[0]) {
                var event = jQuery.Event(type);
                event.preventDefault();
                event.stopPropagation();
                jQuery.event.trigger(event, data, this[0]);
                return event.result;
            }
        },

        toggle: function (fn) {
            // Save reference to arguments for access in closure
            var args = arguments, i = 1;

            // link all the functions, so any of them can unbind this click handler
            while (i < args.length) {
                jQuery.proxy(fn, args[i++]);
            }

            return this.click(jQuery.proxy(fn, function (event) {
                // Figure out which function to execute
                var lastToggle = (jQuery.data(this, "lastToggle" + fn.guid) || 0) % i;
                jQuery.data(this, "lastToggle" + fn.guid, lastToggle + 1);

                // Make sure that clicks stop
                event.preventDefault();

                // and execute the function
                return args[lastToggle].apply(this, arguments) || false;
            }));
        },

        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    var liveMap = {
        focus: "focusin",
        blur: "focusout",
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };

    jQuery.each(["live", "die"], function (i, name) {
        jQuery.fn[name] = function (types, data, fn, origSelector /* Internal Use Only */) {
            var type, i = 0, match, namespaces, preType,
                selector = origSelector || this.selector,
                context = origSelector ? this : jQuery(this.context);

            if (typeof types === "object" && !types.preventDefault) {
                for (var key in types) {
                    context[name](key, data, types[key], selector);
                }

                return this;
            }

            if (jQuery.isFunction(data)) {
                fn = data;
                data = undefined;
            }

            types = (types || "").split(" ");

            while ((type = types[i++]) != null) {
                match = rnamespaces.exec(type);
                namespaces = "";

                if (match) {
                    namespaces = match[0];
                    type = type.replace(rnamespaces, "");
                }

                if (type === "hover") {
                    types.push("mouseenter" + namespaces, "mouseleave" + namespaces);
                    continue;
                }

                preType = type;

                if (type === "focus" || type === "blur") {
                    types.push(liveMap[type] + namespaces);
                    type = type + namespaces;

                } else {
                    type = (liveMap[type] || type) + namespaces;
                }

                if (name === "live") {
                    // bind live handler
                    for (var j = 0, l = context.length; j < l; j++) {
                        jQuery.event.add(context[j], "live." + liveConvert(type, selector),
                            { data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType });
                    }

                } else {
                    // unbind live handler
                    context.unbind("live." + liveConvert(type, selector), fn);
                }
            }

            return this;
        };
    });

    function liveHandler(event) {
        var stop, maxLevel, elems = [], selectors = [],
            related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
            events = jQuery.data(this, this.nodeType ? "events" : "__events__");

        if (typeof events === "function") {
            events = events.events;
        }

        // Make sure we avoid non-left-click bubbling in Firefox (#3861)
        if (event.liveFired === this || !events || !events.live || event.button && event.type === "click") {
            return;
        }

        if (event.namespace) {
            namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
        }

        event.liveFired = this;

        var live = events.live.slice(0);

        for (j = 0; j < live.length; j++) {
            handleObj = live[j];

            if (handleObj.origType.replace(rnamespaces, "") === event.type) {
                selectors.push(handleObj.selector);

            } else {
                live.splice(j--, 1);
            }
        }

        match = jQuery(event.target).closest(selectors, event.currentTarget);

        for (i = 0, l = match.length; i < l; i++) {
            close = match[i];

            for (j = 0; j < live.length; j++) {
                handleObj = live[j];

                if (close.selector === handleObj.selector && (!namespace || namespace.test(handleObj.namespace))) {
                    elem = close.elem;
                    related = null;

                    // Those two events require additional checking
                    if (handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave") {
                        event.type = handleObj.preType;
                        related = jQuery(event.relatedTarget).closest(handleObj.selector)[0];
                    }

                    if (!related || related !== elem) {
                        elems.push({ elem: elem, handleObj: handleObj, level: close.level });
                    }
                }
            }
        }

        for (i = 0, l = elems.length; i < l; i++) {
            match = elems[i];

            if (maxLevel && match.level > maxLevel) {
                break;
            }

            event.currentTarget = match.elem;
            event.data = match.handleObj.data;
            event.handleObj = match.handleObj;

            ret = match.handleObj.origHandler.apply(match.elem, arguments);

            if (ret === false || event.isPropagationStopped()) {
                maxLevel = match.level;

                if (ret === false) {
                    stop = false;
                }
            }
        }

        return stop;
    }

    function liveConvert(type, selector) {
        return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspace, "&");
    }

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error").split(" "), function (i, name) {

            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
                if (fn == null) {
                    fn = data;
                    data = null;
                }

                return arguments.length > 0 ?
                    this.bind(name, data, fn) :
                    this.trigger(name);
            };

            if (jQuery.attrFn) {
                jQuery.attrFn[name] = true;
            }
        });

    // Prevent memory leaks in IE
    // Window isn't included so as not to unbind existing unload events
    // More info:
    //  - http://isaacschlueter.com/2006/10/msie-memory-leaks/
    if (window.attachEvent && !window.addEventListener) {
        jQuery(window).bind("unload", function () {
            for (var id in jQuery.cache) {
                if (jQuery.cache[id].handle) {
                    // Try/Catch is to handle iframes being unloaded, see #4280
                    try {
                        jQuery.event.remove(jQuery.cache[id].handle.elem);
                    } catch (e) { }
                }
            }
        });
    }


    /*!
     * Sizzle CSS Selector Engine - v1.0
     *  Copyright 2009, The Dojo Foundation
     *  Released under the MIT, BSD, and GPL Licenses.
     *  More information: http://sizzlejs.com/
     */
    (function () {

        var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
            done = 0,
            toString = Object.prototype.toString,
            hasDuplicate = false,
            baseHasDuplicate = true;

        // Here we check if the JavaScript engine is using some sort of
        // optimization where it does not always call our comparision
        // function. If that is the case, discard the hasDuplicate value.
        //   Thus far that includes Google Chrome.
        [0, 0].sort(function () {
            baseHasDuplicate = false;
            return 0;
        });

        var Sizzle = function (selector, context, results, seed) {
            results = results || [];
            context = context || document;

            var origContext = context;

            if (context.nodeType !== 1 && context.nodeType !== 9) {
                return [];
            }

            if (!selector || typeof selector !== "string") {
                return results;
            }

            var parts = [], m, set, checkSet, extra, prune = true, contextXML = Sizzle.isXML(context),
                soFar = selector, ret, cur, pop, i;

            // Reset the position of the chunker regexp (start from head)
            do {
                chunker.exec("");
                m = chunker.exec(soFar);

                if (m) {
                    soFar = m[3];

                    parts.push(m[1]);

                    if (m[2]) {
                        extra = m[3];
                        break;
                    }
                }
            } while (m);

            if (parts.length > 1 && origPOS.exec(selector)) {
                if (parts.length === 2 && Expr.relative[parts[0]]) {
                    set = posProcess(parts[0] + parts[1], context);
                } else {
                    set = Expr.relative[parts[0]] ?
                        [context] :
                        Sizzle(parts.shift(), context);

                    while (parts.length) {
                        selector = parts.shift();

                        if (Expr.relative[selector]) {
                            selector += parts.shift();
                        }

                        set = posProcess(selector, set);
                    }
                }
            } else {
                // Take a shortcut and set the context if the root selector is an ID
                // (but not if it'll be faster if the inner selector is an ID)
                if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
                    Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {
                    ret = Sizzle.find(parts.shift(), context, contextXML);
                    context = ret.expr ? Sizzle.filter(ret.expr, ret.set)[0] : ret.set[0];
                }

                if (context) {
                    ret = seed ?
                        { expr: parts.pop(), set: makeArray(seed) } :
                        Sizzle.find(parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML);
                    set = ret.expr ? Sizzle.filter(ret.expr, ret.set) : ret.set;

                    if (parts.length > 0) {
                        checkSet = makeArray(set);
                    } else {
                        prune = false;
                    }

                    while (parts.length) {
                        cur = parts.pop();
                        pop = cur;

                        if (!Expr.relative[cur]) {
                            cur = "";
                        } else {
                            pop = parts.pop();
                        }

                        if (pop == null) {
                            pop = context;
                        }

                        Expr.relative[cur](checkSet, pop, contextXML);
                    }
                } else {
                    checkSet = parts = [];
                }
            }

            if (!checkSet) {
                checkSet = set;
            }

            if (!checkSet) {
                Sizzle.error(cur || selector);
            }

            if (toString.call(checkSet) === "[object Array]") {
                if (!prune) {
                    results.push.apply(results, checkSet);
                } else if (context && context.nodeType === 1) {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i]))) {
                            results.push(set[i]);
                        }
                    }
                } else {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && checkSet[i].nodeType === 1) {
                            results.push(set[i]);
                        }
                    }
                }
            } else {
                makeArray(checkSet, results);
            }

            if (extra) {
                Sizzle(extra, origContext, results, seed);
                Sizzle.uniqueSort(results);
            }

            return results;
        };

        Sizzle.uniqueSort = function (results) {
            if (sortOrder) {
                hasDuplicate = baseHasDuplicate;
                results.sort(sortOrder);

                if (hasDuplicate) {
                    for (var i = 1; i < results.length; i++) {
                        if (results[i] === results[i - 1]) {
                            results.splice(i--, 1);
                        }
                    }
                }
            }

            return results;
        };

        Sizzle.matches = function (expr, set) {
            return Sizzle(expr, null, null, set);
        };

        Sizzle.matchesSelector = function (node, expr) {
            return Sizzle(expr, null, null, [node]).length > 0;
        };

        Sizzle.find = function (expr, context, isXML) {
            var set;

            if (!expr) {
                return [];
            }

            for (var i = 0, l = Expr.order.length; i < l; i++) {
                var type = Expr.order[i], match;

                if ((match = Expr.leftMatch[type].exec(expr))) {
                    var left = match[1];
                    match.splice(1, 1);

                    if (left.substr(left.length - 1) !== "\\") {
                        match[1] = (match[1] || "").replace(/\\/g, "");
                        set = Expr.find[type](match, context, isXML);
                        if (set != null) {
                            expr = expr.replace(Expr.match[type], "");
                            break;
                        }
                    }
                }
            }

            if (!set) {
                set = context.getElementsByTagName("*");
            }

            return { set: set, expr: expr };
        };

        Sizzle.filter = function (expr, set, inplace, not) {
            var old = expr, result = [], curLoop = set, match, anyFound,
                isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

            while (expr && set.length) {
                for (var type in Expr.filter) {
                    if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {
                        var filter = Expr.filter[type], found, item, left = match[1];
                        anyFound = false;

                        match.splice(1, 1);

                        if (left.substr(left.length - 1) === "\\") {
                            continue;
                        }

                        if (curLoop === result) {
                            result = [];
                        }

                        if (Expr.preFilter[type]) {
                            match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);

                            if (!match) {
                                anyFound = found = true;
                            } else if (match === true) {
                                continue;
                            }
                        }

                        if (match) {
                            for (var i = 0; (item = curLoop[i]) != null; i++) {
                                if (item) {
                                    found = filter(item, match, i, curLoop);
                                    var pass = not ^ !!found;

                                    if (inplace && found != null) {
                                        if (pass) {
                                            anyFound = true;
                                        } else {
                                            curLoop[i] = false;
                                        }
                                    } else if (pass) {
                                        result.push(item);
                                        anyFound = true;
                                    }
                                }
                            }
                        }

                        if (found !== undefined) {
                            if (!inplace) {
                                curLoop = result;
                            }

                            expr = expr.replace(Expr.match[type], "");

                            if (!anyFound) {
                                return [];
                            }

                            break;
                        }
                    }
                }

                // Improper expression
                if (expr === old) {
                    if (anyFound == null) {
                        Sizzle.error(expr);
                    } else {
                        break;
                    }
                }

                old = expr;
            }

            return curLoop;
        };

        Sizzle.error = function (msg) {
            throw "Syntax error, unrecognized expression: " + msg;
        };

        var Expr = Sizzle.selectors = {
            order: ["ID", "NAME", "TAG"],
            match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            },
            leftMatch: {},
            attrMap: {
                "class": "className",
                "for": "htmlFor"
            },
            attrHandle: {
                href: function (elem) {
                    return elem.getAttribute("href");
                }
            },
            relative: {
                "+": function (checkSet, part) {
                    var isPartStr = typeof part === "string",
                        isTag = isPartStr && !/\W/.test(part),
                        isPartStrNotTag = isPartStr && !isTag;

                    if (isTag) {
                        part = part.toLowerCase();
                    }

                    for (var i = 0, l = checkSet.length, elem; i < l; i++) {
                        if ((elem = checkSet[i])) {
                            while ((elem = elem.previousSibling) && elem.nodeType !== 1) { }

                            checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
                                elem || false :
                                elem === part;
                        }
                    }

                    if (isPartStrNotTag) {
                        Sizzle.filter(part, checkSet, true);
                    }
                },
                ">": function (checkSet, part) {
                    var isPartStr = typeof part === "string",
                        elem, i = 0, l = checkSet.length;

                    if (isPartStr && !/\W/.test(part)) {
                        part = part.toLowerCase();

                        for (; i < l; i++) {
                            elem = checkSet[i];
                            if (elem) {
                                var parent = elem.parentNode;
                                checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                            }
                        }
                    } else {
                        for (; i < l; i++) {
                            elem = checkSet[i];
                            if (elem) {
                                checkSet[i] = isPartStr ?
                                    elem.parentNode :
                                    elem.parentNode === part;
                            }
                        }

                        if (isPartStr) {
                            Sizzle.filter(part, checkSet, true);
                        }
                    }
                },
                "": function (checkSet, part, isXML) {
                    var doneName = done++, checkFn = dirCheck, nodeCheck;

                    if (typeof part === "string" && !/\W/.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
                },
                "~": function (checkSet, part, isXML) {
                    var doneName = done++, checkFn = dirCheck, nodeCheck;

                    if (typeof part === "string" && !/\W/.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
                }
            },
            find: {
                ID: function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [m] : [];
                    }
                },
                NAME: function (match, context) {
                    if (typeof context.getElementsByName !== "undefined") {
                        var ret = [], results = context.getElementsByName(match[1]);

                        for (var i = 0, l = results.length; i < l; i++) {
                            if (results[i].getAttribute("name") === match[1]) {
                                ret.push(results[i]);
                            }
                        }

                        return ret.length === 0 ? null : ret;
                    }
                },
                TAG: function (match, context) {
                    return context.getElementsByTagName(match[1]);
                }
            },
            preFilter: {
                CLASS: function (match, curLoop, inplace, result, not, isXML) {
                    match = " " + match[1].replace(/\\/g, "") + " ";

                    if (isXML) {
                        return match;
                    }

                    for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {
                        if (elem) {
                            if (not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n]/g, " ").indexOf(match) >= 0)) {
                                if (!inplace) {
                                    result.push(elem);
                                }
                            } else if (inplace) {
                                curLoop[i] = false;
                            }
                        }
                    }

                    return false;
                },
                ID: function (match) {
                    return match[1].replace(/\\/g, "");
                },
                TAG: function (match, curLoop) {
                    return match[1].toLowerCase();
                },
                CHILD: function (match) {
                    if (match[1] === "nth") {
                        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                        var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
                            match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
                            !/\D/.test(match[2]) && "0n+" + match[2] || match[2]);

                        // calculate the numbers (first)n+(last) including if they are negative
                        match[2] = (test[1] + (test[2] || 1)) - 0;
                        match[3] = test[3] - 0;
                    }

                    // TODO: Move to normal caching system
                    match[0] = done++;

                    return match;
                },
                ATTR: function (match, curLoop, inplace, result, not, isXML) {
                    var name = match[1].replace(/\\/g, "");

                    if (!isXML && Expr.attrMap[name]) {
                        match[1] = Expr.attrMap[name];
                    }

                    if (match[2] === "~=") {
                        match[4] = " " + match[4] + " ";
                    }

                    return match;
                },
                PSEUDO: function (match, curLoop, inplace, result, not) {
                    if (match[1] === "not") {
                        // If we're dealing with a complex expression, or a simple one
                        if ((chunker.exec(match[3]) || "").length > 1 || /^\w/.test(match[3])) {
                            match[3] = Sizzle(match[3], null, null, curLoop);
                        } else {
                            var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
                            if (!inplace) {
                                result.push.apply(result, ret);
                            }
                            return false;
                        }
                    } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {
                        return true;
                    }

                    return match;
                },
                POS: function (match) {
                    match.unshift(true);
                    return match;
                }
            },
            filters: {
                enabled: function (elem) {
                    return elem.disabled === false && elem.type !== "hidden";
                },
                disabled: function (elem) {
                    return elem.disabled === true;
                },
                checked: function (elem) {
                    return elem.checked === true;
                },
                selected: function (elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    elem.parentNode.selectedIndex;
                    return elem.selected === true;
                },
                parent: function (elem) {
                    return !!elem.firstChild;
                },
                empty: function (elem) {
                    return !elem.firstChild;
                },
                has: function (elem, i, match) {
                    return !!Sizzle(match[3], elem).length;
                },
                header: function (elem) {
                    return (/h\d/i).test(elem.nodeName);
                },
                text: function (elem) {
                    return "text" === elem.type;
                },
                radio: function (elem) {
                    return "radio" === elem.type;
                },
                checkbox: function (elem) {
                    return "checkbox" === elem.type;
                },
                file: function (elem) {
                    return "file" === elem.type;
                },
                password: function (elem) {
                    return "password" === elem.type;
                },
                submit: function (elem) {
                    return "submit" === elem.type;
                },
                image: function (elem) {
                    return "image" === elem.type;
                },
                reset: function (elem) {
                    return "reset" === elem.type;
                },
                button: function (elem) {
                    return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
                },
                input: function (elem) {
                    return (/input|select|textarea|button/i).test(elem.nodeName);
                }
            },
            setFilters: {
                first: function (elem, i) {
                    return i === 0;
                },
                last: function (elem, i, match, array) {
                    return i === array.length - 1;
                },
                even: function (elem, i) {
                    return i % 2 === 0;
                },
                odd: function (elem, i) {
                    return i % 2 === 1;
                },
                lt: function (elem, i, match) {
                    return i < match[3] - 0;
                },
                gt: function (elem, i, match) {
                    return i > match[3] - 0;
                },
                nth: function (elem, i, match) {
                    return match[3] - 0 === i;
                },
                eq: function (elem, i, match) {
                    return match[3] - 0 === i;
                }
            },
            filter: {
                PSEUDO: function (elem, match, i, array) {
                    var name = match[1], filter = Expr.filters[name];

                    if (filter) {
                        return filter(elem, i, match, array);
                    } else if (name === "contains") {
                        return (elem.textContent || elem.innerText || Sizzle.getText([elem]) || "").indexOf(match[3]) >= 0;
                    } else if (name === "not") {
                        var not = match[3];

                        for (var j = 0, l = not.length; j < l; j++) {
                            if (not[j] === elem) {
                                return false;
                            }
                        }

                        return true;
                    } else {
                        Sizzle.error("Syntax error, unrecognized expression: " + name);
                    }
                },
                CHILD: function (elem, match) {
                    var type = match[1], node = elem;
                    switch (type) {
                        case 'only':
                        case 'first':
                            while ((node = node.previousSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }
                            if (type === "first") {
                                return true;
                            }
                            node = elem;
                        case 'last':
                            while ((node = node.nextSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }
                            return true;
                        case 'nth':
                            var first = match[2], last = match[3];

                            if (first === 1 && last === 0) {
                                return true;
                            }

                            var doneName = match[0],
                                parent = elem.parentNode;

                            if (parent && (parent.sizcache !== doneName || !elem.nodeIndex)) {
                                var count = 0;
                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        node.nodeIndex = ++count;
                                    }
                                }
                                parent.sizcache = doneName;
                            }

                            var diff = elem.nodeIndex - last;
                            if (first === 0) {
                                return diff === 0;
                            } else {
                                return (diff % first === 0 && diff / first >= 0);
                            }
                    }
                },
                ID: function (elem, match) {
                    return elem.nodeType === 1 && elem.getAttribute("id") === match;
                },
                TAG: function (elem, match) {
                    return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
                },
                CLASS: function (elem, match) {
                    return (" " + (elem.className || elem.getAttribute("class")) + " ")
                        .indexOf(match) > -1;
                },
                ATTR: function (elem, match) {
                    var name = match[1],
                        result = Expr.attrHandle[name] ?
                            Expr.attrHandle[name](elem) :
                            elem[name] != null ?
                                elem[name] :
                                elem.getAttribute(name),
                        value = result + "",
                        type = match[2],
                        check = match[4];

                    return result == null ?
                        type === "!=" :
                        type === "=" ?
                            value === check :
                            type === "*=" ?
                                value.indexOf(check) >= 0 :
                                type === "~=" ?
                                    (" " + value + " ").indexOf(check) >= 0 :
                                    !check ?
                                        value && result !== false :
                                        type === "!=" ?
                                            value !== check :
                                            type === "^=" ?
                                                value.indexOf(check) === 0 :
                                                type === "$=" ?
                                                    value.substr(value.length - check.length) === check :
                                                    type === "|=" ?
                                                        value === check || value.substr(0, check.length + 1) === check + "-" :
                                                        false;
                },
                POS: function (elem, match, i, array) {
                    var name = match[2], filter = Expr.setFilters[name];

                    if (filter) {
                        return filter(elem, i, match, array);
                    }
                }
            }
        };

        var origPOS = Expr.match.POS,
            fescape = function (all, num) {
                return "\\" + (num - 0 + 1);
            };

        for (var type in Expr.match) {
            Expr.match[type] = new RegExp(Expr.match[type].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
            Expr.leftMatch[type] = new RegExp(/(^(?:.|\r|\n)*?)/.source + Expr.match[type].source.replace(/\\(\d+)/g, fescape));
        }

        var makeArray = function (array, results) {
            array = Array.prototype.slice.call(array, 0);

            if (results) {
                results.push.apply(results, array);
                return results;
            }

            return array;
        };

        // Perform a simple check to determine if the browser is capable of
        // converting a NodeList to an array using builtin methods.
        // Also verifies that the returned array holds DOM nodes
        // (which is not the case in the Blackberry browser)
        try {
            Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;

            // Provide a fallback method if it does not work
        } catch (e) {
            makeArray = function (array, results) {
                var ret = results || [], i = 0;

                if (toString.call(array) === "[object Array]") {
                    Array.prototype.push.apply(ret, array);
                } else {
                    if (typeof array.length === "number") {
                        for (var l = array.length; i < l; i++) {
                            ret.push(array[i]);
                        }
                    } else {
                        for (; array[i]; i++) {
                            ret.push(array[i]);
                        }
                    }
                }

                return ret;
            };
        }

        var sortOrder, siblingCheck;

        if (document.documentElement.compareDocumentPosition) {
            sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
                    return a.compareDocumentPosition ? -1 : 1;
                }

                return a.compareDocumentPosition(b) & 4 ? -1 : 1;
            };
        } else {
            sortOrder = function (a, b) {
                var ap = [], bp = [], aup = a.parentNode, bup = b.parentNode,
                    cur = aup, al, bl;

                // The nodes are identical, we can exit early
                if (a === b) {
                    hasDuplicate = true;
                    return 0;

                    // If the nodes are siblings (or identical) we can do a quick check
                } else if (aup === bup) {
                    return siblingCheck(a, b);

                    // If no parents were found then the nodes are disconnected
                } else if (!aup) {
                    return -1;

                } else if (!bup) {
                    return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while (cur) {
                    ap.unshift(cur);
                    cur = cur.parentNode;
                }

                cur = bup;

                while (cur) {
                    bp.unshift(cur);
                    cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for (var i = 0; i < al && i < bl; i++) {
                    if (ap[i] !== bp[i]) {
                        return siblingCheck(ap[i], bp[i]);
                    }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
                    siblingCheck(a, bp[i], -1) :
                    siblingCheck(ap[i], b, 1);
            };

            siblingCheck = function (a, b, ret) {
                if (a === b) {
                    return ret;
                }

                var cur = a.nextSibling;

                while (cur) {
                    if (cur === b) {
                        return -1;
                    }

                    cur = cur.nextSibling;
                }

                return 1;
            };
        }

        // Utility function for retreiving the text value of an array of DOM nodes
        Sizzle.getText = function (elems) {
            var ret = "", elem;

            for (var i = 0; elems[i]; i++) {
                elem = elems[i];

                // Get the text from text nodes and CDATA nodes
                if (elem.nodeType === 3 || elem.nodeType === 4) {
                    ret += elem.nodeValue;

                    // Traverse everything else, except comment nodes
                } else if (elem.nodeType !== 8) {
                    ret += Sizzle.getText(elem.childNodes);
                }
            }

            return ret;
        };

        // Check to see if the browser returns elements by name when
        // querying by getElementById (and provide a workaround)
        (function () {
            // We're going to inject a fake input element with a specified name
            var form = document.createElement("div"),
                id = "script" + (new Date()).getTime();
            form.innerHTML = "<a name='" + id + "'/>";

            // Inject it into the root element, check its status, and remove it quickly
            var root = document.documentElement;
            root.insertBefore(form, root.firstChild);

            // The workaround has to do additional checks after a getElementById
            // Which slows things down for other browsers (hence the branching)
            if (document.getElementById(id)) {
                Expr.find.ID = function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);
                        return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];
                    }
                };

                Expr.filter.ID = function (elem, match) {
                    var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                    return elem.nodeType === 1 && node && node.nodeValue === match;
                };
            }

            root.removeChild(form);
            root = form = null; // release memory in IE
        })();

        (function () {
            // Check to see if the browser returns only elements
            // when doing getElementsByTagName("*")

            // Create a fake element
            var div = document.createElement("div");
            div.appendChild(document.createComment(""));

            // Make sure no comments are found
            if (div.getElementsByTagName("*").length > 0) {
                Expr.find.TAG = function (match, context) {
                    var results = context.getElementsByTagName(match[1]);

                    // Filter out possible comments
                    if (match[1] === "*") {
                        var tmp = [];

                        for (var i = 0; results[i]; i++) {
                            if (results[i].nodeType === 1) {
                                tmp.push(results[i]);
                            }
                        }

                        results = tmp;
                    }

                    return results;
                };
            }

            // Check to see if an attribute returns normalized href attributes
            div.innerHTML = "<a href='#'></a>";
            if (div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
                div.firstChild.getAttribute("href") !== "#") {
                Expr.attrHandle.href = function (elem) {
                    return elem.getAttribute("href", 2);
                };
            }

            div = null; // release memory in IE
        })();

        if (document.querySelectorAll) {
            (function () {
                var oldSizzle = Sizzle, div = document.createElement("div");
                div.innerHTML = "<p class='TEST'></p>";

                // Safari can't handle uppercase or unicode characters when
                // in quirks mode.
                if (div.querySelectorAll && div.querySelectorAll(".TEST").length === 0) {
                    return;
                }

                Sizzle = function (query, context, extra, seed) {
                    context = context || document;

                    // Only use querySelectorAll on non-XML documents
                    // (ID selectors don't work in non-HTML documents)
                    if (!seed && !Sizzle.isXML(context)) {
                        if (context.nodeType === 9) {
                            try {
                                return makeArray(context.querySelectorAll(query), extra);
                            } catch (qsaError) { }

                            // qSA works strangely on Element-rooted queries
                            // We can work around this by specifying an extra ID on the root
                            // and working up from there (Thanks to Andrew Dupont for the technique)
                            // IE 8 doesn't work on object elements
                        } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            var old = context.id, id = context.id = "__sizzle__";

                            try {
                                return makeArray(context.querySelectorAll("#" + id + " " + query), extra);

                            } catch (pseudoError) {
                            } finally {
                                if (old) {
                                    context.id = old;

                                } else {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }

                    return oldSizzle(query, context, extra, seed);
                };

                for (var prop in oldSizzle) {
                    Sizzle[prop] = oldSizzle[prop];
                }

                div = null; // release memory in IE
            })();
        }

        (function () {
            var html = document.documentElement,
                matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector,
                pseudoWorks = false;

            try {
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call(document.documentElement, ":sizzle");

            } catch (pseudoError) {
                pseudoWorks = true;
            }

            if (matches) {
                Sizzle.matchesSelector = function (node, expr) {
                    try {
                        if (pseudoWorks || !Expr.match.PSEUDO.test(expr)) {
                            return matches.call(node, expr);
                        }
                    } catch (e) { }

                    return Sizzle(expr, null, null, [node]).length > 0;
                };
            }
        })();

        (function () {
            var div = document.createElement("div");

            div.innerHTML = "<div class='test e'></div><div class='test'></div>";

            // Opera can't find a second classname (in 9.6)
            // Also, make sure that getElementsByClassName actually exists
            if (!div.getElementsByClassName || div.getElementsByClassName("e").length === 0) {
                return;
            }

            // Safari caches class attributes, doesn't catch changes (in 3.2)
            div.lastChild.className = "e";

            if (div.getElementsByClassName("e").length === 1) {
                return;
            }

            Expr.order.splice(1, 0, "CLASS");
            Expr.find.CLASS = function (match, context, isXML) {
                if (typeof context.getElementsByClassName !== "undefined" && !isXML) {
                    return context.getElementsByClassName(match[1]);
                }
            };

            div = null; // release memory in IE
        })();

        function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];
                if (elem) {
                    elem = elem[dir];
                    var match = false;

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1 && !isXML) {
                            elem.sizcache = doneName;
                            elem.sizset = i;
                        }

                        if (elem.nodeName.toLowerCase() === cur) {
                            match = elem;
                            break;
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];
                if (elem) {
                    elem = elem[dir];
                    var match = false;

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1) {
                            if (!isXML) {
                                elem.sizcache = doneName;
                                elem.sizset = i;
                            }
                            if (typeof cur !== "string") {
                                if (elem === cur) {
                                    match = true;
                                    break;
                                }

                            } else if (Sizzle.filter(cur, [elem]).length > 0) {
                                match = elem;
                                break;
                            }
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        Sizzle.contains = document.documentElement.contains ? function (a, b) {
            return a !== b && (a.contains ? a.contains(b) : true);
        } : function (a, b) {
            return !!(a.compareDocumentPosition(b) & 16);
        };

        Sizzle.isXML = function (elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833) 
            var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        var posProcess = function (selector, context) {
            var tmpSet = [], later = "", match,
                root = context.nodeType ? [context] : context;

            // Position selectors must be done after the filter
            // And so must :not(positional) so we move all PSEUDOs to the end
            while ((match = Expr.match.PSEUDO.exec(selector))) {
                later += match[0];
                selector = selector.replace(Expr.match.PSEUDO, "");
            }

            selector = Expr.relative[selector] ? selector + "*" : selector;

            for (var i = 0, l = root.length; i < l; i++) {
                Sizzle(selector, root[i], tmpSet);
            }

            return Sizzle.filter(later, tmpSet);
        };

        // EXPOSE
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.filters;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
        rparentsprev = /^(?:parents|prevUntil|prevAll)/,
        // Note: This RegExp should be improved, or likely pulled from Sizzle
        rmultiselector = /,/,
        isSimple = /^.[^:#\[\.,]*$/,
        slice = Array.prototype.slice,
        POS = jQuery.expr.match.POS;

    jQuery.fn.extend({
        find: function (selector) {
            var ret = this.pushStack("", "find", selector), length = 0;

            for (var i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                    // Make sure that the results are unique
                    for (var n = length; n < ret.length; n++) {
                        for (var r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function (target) {
            var targets = jQuery(target);
            return this.filter(function () {
                for (var i = 0, l = targets.length; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        not: function (selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: function (selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },

        is: function (selector) {
            return !!selector && jQuery.filter(selector, this).length > 0;
        },

        closest: function (selectors, context) {
            var ret = [], i, l, cur = this[0];

            if (jQuery.isArray(selectors)) {
                var match, matches = {}, selector, level = 1;

                if (cur && selectors.length) {
                    for (i = 0, l = selectors.length; i < l; i++) {
                        selector = selectors[i];

                        if (!matches[selector]) {
                            matches[selector] = jQuery.expr.match.POS.test(selector) ?
                                jQuery(selector, context || this.context) :
                                selector;
                        }
                    }

                    while (cur && cur.ownerDocument && cur !== context) {
                        for (selector in matches) {
                            match = matches[selector];

                            if (match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match)) {
                                ret.push({ selector: selector, elem: cur, level: level });
                            }
                        }

                        cur = cur.parentNode;
                        level++;
                    }
                }

                return ret;
            }

            var pos = POS.test(selectors) ?
                jQuery(selectors, context || this.context) : null;

            for (i = 0, l = this.length; i < l; i++) {
                cur = this[i];

                while (cur) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;

                    } else {
                        cur = cur.parentNode;
                        if (!cur || !cur.ownerDocument || cur === context) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function (elem) {
            if (!elem || typeof elem === "string") {
                return jQuery.inArray(this[0],
                    // If it receives a string, the selector is used
                    // If it receives nothing, the siblings are used
                    elem ? jQuery(elem) : this.parent().children());
            }
            // Locate the position of the desired element
            return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this);
        },

        add: function (selector, context) {
            var set = typeof selector === "string" ?
                jQuery(selector, context || this.context) :
                jQuery.makeArray(selector),
                all = jQuery.merge(this.get(), set);

            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
                all :
                jQuery.unique(all));
        },

        andSelf: function () {
            return this.add(this.prevObject);
        }
    });

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return jQuery.nth(elem, 2, "nextSibling");
        },
        prev: function (elem) {
            return jQuery.nth(elem, 2, "previousSibling");
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return jQuery.sibling(elem.parentNode.firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, "iframe") ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.makeArray(elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until);

            if (!runtil.test(name)) {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }

            ret = this.length > 1 ? jQuery.unique(ret) : ret;

            if ((this.length > 1 || rmultiselector.test(selector)) && rparentsprev.test(name)) {
                ret = ret.reverse();
            }

            return this.pushStack(ret, name, slice.call(arguments).join(","));
        };
    });

    jQuery.extend({
        filter: function (expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
                jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
                jQuery.find.matches(expr, elems);
        },

        dir: function (elem, dir, until) {
            var matched = [], cur = elem[dir];
            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        nth: function (cur, result, dir, elem) {
            result = result || 1;
            var num = 0;

            for (; cur; cur = cur[dir]) {
                if (cur.nodeType === 1 && ++num === result) {
                    break;
                }
            }

            return cur;
        },

        sibling: function (n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, keep) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });

        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem, i) {
                return (elem === qualifier) === keep;
            });

        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function (elem) {
                return elem.nodeType === 1;
            });

            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }

        return jQuery.grep(elements, function (elem, i) {
            return (jQuery.inArray(elem, qualifier) >= 0) === keep;
        });
    }




    var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnocache = /<(?:script|object|embed|option|style)/i,
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,  // checked="checked" or checked (html5)
        raction = /\=([^="'>\s]+\/)>/g,
        wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            area: [1, "<map>", "</map>"],
            _default: [0, "", ""]
        };

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE can't serialize <link> and <script> tags normally
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "div<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: function (text) {
            if (jQuery.isFunction(text)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self.text(text.call(this, i, self.text()));
                });
            }

            if (typeof text !== "object" && text !== undefined) {
                return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(text));
            }

            return jQuery.text(this);
        },

        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this), contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            return this.each(function () {
                jQuery(this).wrapAll(html);
            });
        },

        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },

        append: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },

        before: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            } else if (arguments.length) {
                var set = jQuery(arguments[0]);
                set.push.apply(set, this.toArray());
                return this.pushStack(set, "before", arguments);
            }
        },

        after: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            } else if (arguments.length) {
                var set = this.pushStack(this, "after", arguments);
                set.push.apply(set, jQuery(arguments[0]).toArray());
                return set;
            }
        },

        // keepData is for internal use only--do not document
        remove: function (selector, keepData) {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]);
                    }

                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }

            return this;
        },

        empty: function () {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }

            return this;
        },

        clone: function (events) {
            // Do the clone
            var ret = this.map(function () {
                if (!jQuery.support.noCloneEvent && !jQuery.isXMLDoc(this)) {
                    // IE copies events bound via attachEvent when
                    // using cloneNode. Calling detachEvent on the
                    // clone will also remove the events from the orignal
                    // In order to get around this, we use innerHTML.
                    // Unfortunately, this means some modifications to
                    // attributes in IE that are actually only stored
                    // as properties will not be copied (such as the
                    // the name attribute on an input).
                    var html = this.outerHTML, ownerDocument = this.ownerDocument;
                    if (!html) {
                        var div = ownerDocument.createElement("div");
                        div.appendChild(this.cloneNode(true));
                        html = div.innerHTML;
                    }

                    return jQuery.clean([html.replace(rinlinejQuery, "")
                        // Handle the case in IE 8 where action=/test/> self-closes a tag
                        .replace(raction, '="$1">')
                        .replace(rleadingWhitespace, "")], ownerDocument)[0];
                } else {
                    return this.cloneNode(true);
                }
            });

            // Copy the events from the original to the clone
            if (events === true) {
                cloneCopyEvent(this, ret);
                cloneCopyEvent(this.find("*"), ret.find("*"));
            }

            // Return the cloned set
            return ret;
        },

        html: function (value) {
            if (value === undefined) {
                return this[0] && this[0].nodeType === 1 ?
                    this[0].innerHTML.replace(rinlinejQuery, "") :
                    null;

                // See if we can take a shortcut and just use innerHTML
            } else if (typeof value === "string" && !rnocache.test(value) &&
                (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
                !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                value = value.replace(rxhtmlTag, "<$1></$2>");

                try {
                    for (var i = 0, l = this.length; i < l; i++) {
                        // Remove element nodes and prevent memory leaks
                        if (this[i].nodeType === 1) {
                            jQuery.cleanData(this[i].getElementsByTagName("*"));
                            this[i].innerHTML = value;
                        }
                    }

                    // If using innerHTML throws an exception, use the fallback method
                } catch (e) {
                    this.empty().append(value);
                }

            } else if (jQuery.isFunction(value)) {
                this.each(function (i) {
                    var self = jQuery(this);
                    self.html(value.call(this, i, self.html()));
                });

            } else {
                this.empty().append(value);
            }

            return this;
        },

        replaceWith: function (value) {
            if (this[0] && this[0].parentNode) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }

                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }

                return this.each(function () {
                    var next = this.nextSibling, parent = this.parentNode;

                    jQuery(this).remove();

                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            } else {
                return this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value);
            }
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, table, callback) {
            var results, first, value = args[0], scripts = [], fragment, parent;

            // We can't cloneNode fragments that contain checked, in WebKit
            if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function () {
                    jQuery(this).domManip(args, table, callback, true);
                });
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }

            if (this[0]) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if (jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length) {
                    results = { fragment: parent };

                } else {
                    results = jQuery.buildFragment(args, this, scripts);
                }

                fragment = results.fragment;

                if (fragment.childNodes.length === 1) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }

                if (first) {
                    table = table && jQuery.nodeName(first, "tr");

                    for (var i = 0, l = this.length; i < l; i++) {
                        callback.call(
                            table ?
                                root(this[i], first) :
                                this[i],
                            i > 0 || results.cacheable || this.length > 1 ?
                                fragment.cloneNode(true) :
                                fragment
                        );
                    }
                }

                if (scripts.length) {
                    jQuery.each(scripts, evalScript);
                }
            }

            return this;
        }
    });

    function root(elem, cur) {
        return jQuery.nodeName(elem, "table") ?
            (elem.getElementsByTagName("tbody")[0] ||
                elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
            elem;
    }

    function cloneCopyEvent(orig, ret) {
        var i = 0;

        ret.each(function () {
            if (this.nodeName !== (orig[i] && orig[i].nodeName)) {
                return;
            }

            var oldData = jQuery.data(orig[i++]), curData = jQuery.data(this, oldData), events = oldData && oldData.events;

            if (events) {
                delete curData.handle;
                curData.events = {};

                for (var type in events) {
                    for (var handler in events[type]) {
                        jQuery.event.add(this, type, events[type][handler], events[type][handler].data);
                    }
                }
            }
        });
    }

    jQuery.buildFragment = function (args, nodes, scripts) {
        var fragment, cacheable, cacheresults,
            doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);

        // Only cache "small" (1/2 KB) strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        if (args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
            !rnocache.test(args[0]) && (jQuery.support.checkClone || !rchecked.test(args[0]))) {

            cacheable = true;
            cacheresults = jQuery.fragments[args[0]];
            if (cacheresults) {
                if (cacheresults !== 1) {
                    fragment = cacheresults;
                }
            }
        }

        if (!fragment) {
            fragment = doc.createDocumentFragment();
            jQuery.clean(args, doc, fragment, scripts);
        }

        if (cacheable) {
            jQuery.fragments[args[0]] = cacheresults ? fragment : 1;
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var ret = [], insert = jQuery(selector),
                parent = this.length === 1 && this[0].parentNode;

            if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {
                insert[original](this[0]);
                return this;

            } else {
                for (var i = 0, l = insert.length; i < l; i++) {
                    var elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    jQuery.extend({
        clean: function (elems, context, fragment, scripts) {
            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if (typeof context.createElement === "undefined") {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            var ret = [];

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string" && !rhtml.test(elem)) {
                    elem = context.createTextNode(elem);

                } else if (typeof elem === "string") {
                    // Fix "XHTML"-style tags in all browsers
                    elem = elem.replace(rxhtmlTag, "<$1></$2>");

                    // Trim whitespace, otherwise indexOf won't work as expected
                    var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
                        wrap = wrapMap[tag] || wrapMap._default,
                        depth = wrap[0],
                        div = context.createElement("div");

                    // Go to html and back, then peel off extra wrappers
                    div.innerHTML = wrap[1] + elem + wrap[2];

                    // Move to the right depth
                    while (depth--) {
                        div = div.lastChild;
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if (!jQuery.support.tbody) {

                        // String was a <table>, *may* have spurious <tbody>
                        var hasBody = rtbody.test(elem),
                            tbody = tag === "table" && !hasBody ?
                                div.firstChild && div.firstChild.childNodes :

                                // String was a bare <thead> or <tfoot>
                                wrap[1] === "<table>" && !hasBody ?
                                    div.childNodes :
                                    [];

                        for (var j = tbody.length - 1; j >= 0; --j) {
                            if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                tbody[j].parentNode.removeChild(tbody[j]);
                            }
                        }

                    }

                    // IE completely kills leading whitespace when innerHTML is used
                    if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                        div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                    }

                    elem = div.childNodes;
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    ret = jQuery.merge(ret, elem);
                }
            }

            if (fragment) {
                for (i = 0; ret[i]; i++) {
                    if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
                        scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);

                    } else {
                        if (ret[i].nodeType === 1) {
                            ret.splice.apply(ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName("script"))));
                        }
                        fragment.appendChild(ret[i]);
                    }
                }
            }

            return ret;
        },

        cleanData: function (elems) {
            var data, id, cache = jQuery.cache,
                special = jQuery.event.special,
                deleteExpando = jQuery.support.deleteExpando;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {
                    continue;
                }

                id = elem[jQuery.expando];

                if (id) {
                    data = cache[id];

                    if (data && data.events) {
                        for (var type in data.events) {
                            if (special[type]) {
                                jQuery.event.remove(elem, type);

                            } else {
                                jQuery.removeEvent(elem, type, data.handle);
                            }
                        }
                    }

                    if (deleteExpando) {
                        delete elem[jQuery.expando];

                    } else if (elem.removeAttribute) {
                        elem.removeAttribute(jQuery.expando);
                    }

                    delete cache[id];
                }
            }
        }
    });

    function evalScript(i, elem) {
        if (elem.src) {
            jQuery.ajax({
                url: elem.src,
                async: false,
                dataType: "script"
            });
        } else {
            jQuery.globalEval(elem.text || elem.textContent || elem.innerHTML || "");
        }

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }




    var ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity=([^)]*)/,
        rdashAlpha = /-([a-z])/ig,
        rupper = /([A-Z])/g,
        rnumpx = /^-?\d+(?:px)?$/i,
        rnum = /^-?\d/,

        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssWidth = ["Left", "Right"],
        cssHeight = ["Top", "Bottom"],
        curCSS,

        // cache check for defaultView.getComputedStyle
        getComputedStyle = document.defaultView && document.defaultView.getComputedStyle,

        fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };

    jQuery.fn.css = function (name, value) {
        // Setting 'undefined' is a no-op
        if (arguments.length === 2 && value === undefined) {
            return this;
        }

        return jQuery.access(this, name, value, true, function (elem, name, value) {
            return value !== undefined ?
                jQuery.style(elem, name, value) :
                jQuery.css(elem, name);
        });
    };

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity", "opacity");
                        return ret === "" ? "1" : ret;

                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "zIndex": true,
            "fontWeight": true,
            "opacity": true,
            "zoom": true,
            "lineHeight": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, origName = jQuery.camelCase(name),
                style = elem.style, hooks = jQuery.cssHooks[origName];

            name = jQuery.cssProps[origName] || origName;

            // Check if we're setting a value
            if (value !== undefined) {
                // Make sure that NaN and null values aren't set. See: #7116
                if (typeof value === "number" && isNaN(value) || value == null) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (typeof value === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value)) !== undefined) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[name] = value;
                    } catch (e) { }
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra) {
            // Make sure that we're working with the right name
            var ret, origName = jQuery.camelCase(name),
                hooks = jQuery.cssHooks[origName];

            name = jQuery.cssProps[origName] || origName;

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks && (ret = hooks.get(elem, true, extra)) !== undefined) {
                return ret;

                // Otherwise, if a way to get the computed value exists, use that
            } else if (curCSS) {
                return curCSS(elem, name, origName);
            }
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function (elem, options, callback) {
            var old = {};

            // Remember the old values, and insert the new ones
            for (var name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }

            callback.call(elem);

            // Revert the old values
            for (name in options) {
                elem.style[name] = old[name];
            }
        },

        camelCase: function (string) {
            return string.replace(rdashAlpha, fcamelCase);
        }
    });

    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                var val;

                if (computed) {
                    if (elem.offsetWidth !== 0) {
                        val = getWH(elem, name, extra);

                    } else {
                        jQuery.swap(elem, cssShow, function () {
                            val = getWH(elem, name, extra);
                        });
                    }

                    return val + "px";
                }
            },

            set: function (elem, value) {
                if (rnumpx.test(value)) {
                    // ignore negative width and height values #1599
                    value = parseFloat(value);

                    if (value >= 0) {
                        return value + "px";
                    }

                } else {
                    return value;
                }
            }
        };
    });

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
                    (parseFloat(RegExp.$1) / 100) + "" :
                    computed ? "1" : "";
            },

            set: function (elem, value) {
                var style = elem.style;

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // Set the alpha filter to set the opacity
                var opacity = jQuery.isNaN(value) ?
                    "" :
                    "alpha(opacity=" + value * 100 + ")",
                    filter = style.filter || "";

                style.filter = ralpha.test(filter) ?
                    filter.replace(ralpha, opacity) :
                    style.filter + ' ' + opacity;
            }
        };
    }

    if (getComputedStyle) {
        curCSS = function (elem, newName, name) {
            var ret, defaultView, computedStyle;

            name = name.replace(rupper, "-$1").toLowerCase();

            if (!(defaultView = elem.ownerDocument.defaultView)) {
                return undefined;
            }

            if ((computedStyle = defaultView.getComputedStyle(elem, null))) {
                ret = computedStyle.getPropertyValue(name);
                if (ret === "" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {
                    ret = jQuery.style(elem, name);
                }
            }

            return ret;
        };

    } else if (document.documentElement.currentStyle) {
        curCSS = function (elem, name) {
            var left, rsLeft, ret = elem.currentStyle && elem.currentStyle[name], style = elem.style;

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if (!rnumpx.test(ret) && rnum.test(ret)) {
                // Remember the original values
                left = style.left;
                rsLeft = elem.runtimeStyle.left;

                // Put in the new values to get a computed value out
                elem.runtimeStyle.left = elem.currentStyle.left;
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                elem.runtimeStyle.left = rsLeft;
            }

            return ret;
        };
    }

    function getWH(elem, name, extra) {
        var which = name === "width" ? cssWidth : cssHeight,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight;

        if (extra === "border") {
            return val;
        }

        jQuery.each(which, function () {
            if (!extra) {
                val -= parseFloat(jQuery.css(elem, "padding" + this)) || 0;
            }

            if (extra === "margin") {
                val += parseFloat(jQuery.css(elem, "margin" + this)) || 0;

            } else {
                val -= parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
            }
        });

        return val;
    }

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function (elem) {
            var width = elem.offsetWidth, height = elem.offsetHeight;

            return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css(elem, "display")) === "none");
        };

        jQuery.expr.filters.visible = function (elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }




    var jsc = jQuery.now(),
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rselectTextarea = /^(?:select|textarea)/i,
        rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
        rnoContent = /^(?:GET|HEAD|DELETE)$/,
        rbracket = /\[\]$/,
        jsre = /\=\?(&|$)/,
        rquery = /\?/,
        rts = /([?&])_=[^&]*/,
        rurl = /^(\w+:)?\/\/([^\/?#]+)/,
        r20 = /%20/g,
        rhash = /#.*$/,

        // Keep a copy of the old load method
        _load = jQuery.fn.load;

    jQuery.fn.extend({
        load: function (url, params, callback) {
            if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments);

                // Don't do a request if no elements are being requested
            } else if (!this.length) {
                return this;
            }

            var off = url.indexOf(" ");
            if (off >= 0) {
                var selector = url.slice(off, url.length);
                url = url.slice(0, off);
            }

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if (params) {
                // If it's a function
                if (jQuery.isFunction(params)) {
                    // We assume that it's the callback
                    callback = params;
                    params = null;

                    // Otherwise, build a param string
                } else if (typeof params === "object") {
                    params = jQuery.param(params, jQuery.ajaxSettings.traditional);
                    type = "POST";
                }
            }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                complete: function (res, status) {
                    // If successful, inject the HTML into all the matched elements
                    if (status === "success" || status === "notmodified") {
                        // See if a selector was specified
                        self.html(selector ?
                            // Create a dummy div to hold the results
                            jQuery("<div>")
                                // inject the contents of the document in, removing the scripts
                                // to avoid any 'Permission Denied' errors in IE
                                .append(res.responseText.replace(rscript, ""))

                                // Locate the specified elements
                                .find(selector) :

                            // If not, just inject the full result
                            res.responseText);
                    }

                    if (callback) {
                        self.each(callback, [res.responseText, status, res]);
                    }
                }
            });

            return this;
        },

        serialize: function () {
            return jQuery.param(this.serializeArray());
        },

        serializeArray: function () {
            return this.map(function () {
                return this.elements ? jQuery.makeArray(this.elements) : this;
            })
                .filter(function () {
                    return this.name && !this.disabled &&
                        (this.checked || rselectTextarea.test(this.nodeName) ||
                            rinput.test(this.type));
                })
                .map(function (i, elem) {
                    var val = jQuery(this).val();

                    return val == null ?
                        null :
                        jQuery.isArray(val) ?
                            jQuery.map(val, function (val, i) {
                                return { name: elem.name, value: val };
                            }) :
                            { name: elem.name, value: val };
                }).get();
        }
    });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
        jQuery.fn[o] = function (f) {
            return this.bind(o, f);
        };
    });

    jQuery.extend({
        get: function (url, data, callback, type) {
            // shift arguments if data argument was omited
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = null;
            }

            return jQuery.ajax({
                type: "GET",
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        },

        getScript: function (url, callback) {
            return jQuery.get(url, null, callback, "script");
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        post: function (url, data, callback, type) {
            // shift arguments if data argument was omited
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = {};
            }

            return jQuery.ajax({
                type: "POST",
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        },

        ajaxSetup: function (settings) {
            jQuery.extend(jQuery.ajaxSettings, settings);
        },

        ajaxSettings: {
            url: location.href,
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            username: null,
            password: null,
            traditional: false,
            */
            // This function can be overriden by calling jQuery.ajaxSetup
            xhr: function () {
                return new window.XMLHttpRequest();
            },
            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                script: "text/javascript, application/javascript",
                json: "application/json, text/javascript",
                text: "text/plain",
                _default: "*/*"
            }
        },

        ajax: function (origSettings) {
            var s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings),
                jsonp, status, data, type = s.type.toUpperCase(), noContent = rnoContent.test(type);

            s.url = s.url.replace(rhash, "");

            // Use original (not extended) context object if it was provided
            s.context = origSettings && origSettings.context != null ? origSettings.context : s;

            // convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Handle JSONP Parameter Callbacks
            if (s.dataType === "jsonp") {
                if (type === "GET") {
                    if (!jsre.test(s.url)) {
                        s.url += (rquery.test(s.url) ? "&" : "?") + (s.jsonp || "callback") + "=?";
                    }
                } else if (!s.data || !jsre.test(s.data)) {
                    s.data = (s.data ? s.data + "&" : "") + (s.jsonp || "callback") + "=?";
                }
                s.dataType = "json";
            }

            // Build temporary JSONP function
            if (s.dataType === "json" && (s.data && jsre.test(s.data) || jsre.test(s.url))) {
                jsonp = s.jsonpCallback || ("jsonp" + jsc++);

                // Replace the =? sequence both in the query string and the data
                if (s.data) {
                    s.data = (s.data + "").replace(jsre, "=" + jsonp + "$1");
                }

                s.url = s.url.replace(jsre, "=" + jsonp + "$1");

                // We need to make sure
                // that a JSONP style response is executed properly
                s.dataType = "script";

                // Handle JSONP-style loading
                var customJsonp = window[jsonp];

                window[jsonp] = function (tmp) {
                    data = tmp;
                    jQuery.handleSuccess(s, xhr, status, data);
                    jQuery.handleComplete(s, xhr, status, data);

                    if (jQuery.isFunction(customJsonp)) {
                        customJsonp(tmp);

                    } else {
                        // Garbage collect
                        window[jsonp] = undefined;

                        try {
                            delete window[jsonp];
                        } catch (jsonpError) { }
                    }

                    if (head) {
                        head.removeChild(script);
                    }
                };
            }

            if (s.dataType === "script" && s.cache === null) {
                s.cache = false;
            }

            if (s.cache === false && type === "GET") {
                var ts = jQuery.now();

                // try replacing _= if it is there
                var ret = s.url.replace(rts, "$1_=" + ts);

                // if nothing was replaced, add timestamp to the end
                s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
            }

            // If data is available, append data to url for get requests
            if (s.data && type === "GET") {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
            }

            // Watch for a new set of requests
            if (s.global && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Matches an absolute URL, and saves the domain
            var parts = rurl.exec(s.url),
                remote = parts && (parts[1] && parts[1] !== location.protocol || parts[2] !== location.host);

            // If we're requesting a remote document
            // and trying to load JSON or Script with a GET
            if (s.dataType === "script" && type === "GET" && remote) {
                var head = document.getElementsByTagName("head")[0] || document.documentElement;
                var script = document.createElement("script");
                if (s.scriptCharset) {
                    script.charset = s.scriptCharset;
                }
                script.src = s.url;

                // Handle Script loading
                if (!jsonp) {
                    var done = false;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function () {
                        if (!done && (!this.readyState ||
                            this.readyState === "loaded" || this.readyState === "complete")) {
                            done = true;
                            jQuery.handleSuccess(s, xhr, status, data);
                            jQuery.handleComplete(s, xhr, status, data);

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }
                        }
                    };
                }

                // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                // This arises when a base node is used (#2709 and #4378).
                head.insertBefore(script, head.firstChild);

                // We handle everything using the script element injection
                return undefined;
            }

            var requestDone = false;

            // Create the request object
            var xhr = s.xhr();

            if (!xhr) {
                return;
            }

            // Open the socket
            // Passing null username, generates a login popup on Opera (#2865)
            if (s.username) {
                xhr.open(type, s.url, s.async, s.username, s.password);
            } else {
                xhr.open(type, s.url, s.async);
            }

            // Need an extra try/catch for cross domain requests in Firefox 3
            try {
                // Set content-type if data specified and content-body is valid for this type
                if ((s.data != null && !noContent) || (origSettings && origSettings.contentType)) {
                    xhr.setRequestHeader("Content-Type", s.contentType);
                }

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if (s.ifModified) {
                    if (jQuery.lastModified[s.url]) {
                        xhr.setRequestHeader("If-Modified-Since", jQuery.lastModified[s.url]);
                    }

                    if (jQuery.etag[s.url]) {
                        xhr.setRequestHeader("If-None-Match", jQuery.etag[s.url]);
                    }
                }

                // Set header so the called script knows that it's an XMLHttpRequest
                // Only send the header if it's not a remote XHR
                if (!remote) {
                    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                }

                // Set the Accepts header for the server, depending on the dataType
                xhr.setRequestHeader("Accept", s.dataType && s.accepts[s.dataType] ?
                    s.accepts[s.dataType] + ", */*; q=0.01" :
                    s.accepts._default);
            } catch (headerError) { }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
                // Handle the global AJAX counter
                if (s.global && jQuery.active-- === 1) {
                    jQuery.event.trigger("ajaxStop");
                }

                // close opended socket
                xhr.abort();
                return false;
            }

            if (s.global) {
                jQuery.triggerGlobal(s, "ajaxSend", [xhr, s]);
            }

            // Wait for a response to come back
            var onreadystatechange = xhr.onreadystatechange = function (isTimeout) {
                // The request was aborted
                if (!xhr || xhr.readyState === 0 || isTimeout === "abort") {
                    // Opera doesn't call onreadystatechange before this point
                    // so we simulate the call
                    if (!requestDone) {
                        jQuery.handleComplete(s, xhr, status, data);
                    }

                    requestDone = true;
                    if (xhr) {
                        xhr.onreadystatechange = jQuery.noop;
                    }

                    // The transfer is complete and the data is available, or the request timed out
                } else if (!requestDone && xhr && (xhr.readyState === 4 || isTimeout === "timeout")) {
                    requestDone = true;
                    xhr.onreadystatechange = jQuery.noop;

                    status = isTimeout === "timeout" ?
                        "timeout" :
                        !jQuery.httpSuccess(xhr) ?
                            "error" :
                            s.ifModified && jQuery.httpNotModified(xhr, s.url) ?
                                "notmodified" :
                                "success";

                    var errMsg;

                    if (status === "success") {
                        // Watch for, and catch, XML document parse errors
                        try {
                            // process the data (runs the xml through httpData regardless of callback)
                            data = jQuery.httpData(xhr, s.dataType, s);
                        } catch (parserError) {
                            status = "parsererror";
                            errMsg = parserError;
                        }
                    }

                    // Make sure that the request was successful or notmodified
                    if (status === "success" || status === "notmodified") {
                        // JSONP handles its own success callback
                        if (!jsonp) {
                            jQuery.handleSuccess(s, xhr, status, data);
                        }
                    } else {
                        jQuery.handleError(s, xhr, status, errMsg);
                    }

                    // Fire the complete handlers
                    if (!jsonp) {
                        jQuery.handleComplete(s, xhr, status, data);
                    }

                    if (isTimeout === "timeout") {
                        xhr.abort();
                    }

                    // Stop memory leaks
                    if (s.async) {
                        xhr = null;
                    }
                }
            };

            // Override the abort handler, if we can (IE 6 doesn't allow it, but that's OK)
            // Opera doesn't fire onreadystatechange at all on abort
            try {
                var oldAbort = xhr.abort;
                xhr.abort = function () {
                    // xhr.abort in IE7 is not a native JS function
                    // and does not have a call property
                    if (xhr && oldAbort.call) {
                        oldAbort.call(xhr);
                    }

                    onreadystatechange("abort");
                };
            } catch (abortError) { }

            // Timeout checker
            if (s.async && s.timeout > 0) {
                setTimeout(function () {
                    // Check to see if the request is still happening
                    if (xhr && !requestDone) {
                        onreadystatechange("timeout");
                    }
                }, s.timeout);
            }

            // Send the data
            try {
                xhr.send(noContent || s.data == null ? null : s.data);

            } catch (sendError) {
                jQuery.handleError(s, xhr, null, sendError);

                // Fire the complete handlers
                jQuery.handleComplete(s, xhr, status, data);
            }

            // firefox 1.5 doesn't fire statechange for sync requests
            if (!s.async) {
                onreadystatechange();
            }

            // return XMLHttpRequest to allow aborting the request etc.
            return xhr;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function (a, traditional) {
            var s = [], add = function (key, value) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction(value) ? value() : value;
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };

            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings.traditional;
            }

            // If an array was passed in, assume that it is an array of form elements.
            if (jQuery.isArray(a) || a.jquery) {
                // Serialize the form elements
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });

            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (var prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }

            // Return the resulting serialization
            return s.join("&").replace(r20, "+");
        }
    });

    function buildParams(prefix, obj, traditional, add) {
        if (jQuery.isArray(obj) && obj.length) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams(prefix + "[" + (typeof v === "object" || jQuery.isArray(v) ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && obj != null && typeof obj === "object") {
            if (jQuery.isEmptyObject(obj)) {
                add(prefix, "");

                // Serialize object item.
            } else {
                jQuery.each(obj, function (k, v) {
                    buildParams(prefix + "[" + k + "]", v, traditional, add);
                });
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        handleError: function (s, xhr, status, e) {
            // If a local callback was specified, fire it
            if (s.error) {
                s.error.call(s.context, xhr, status, e);
            }

            // Fire the global callback
            if (s.global) {
                jQuery.triggerGlobal(s, "ajaxError", [xhr, s, e]);
            }
        },

        handleSuccess: function (s, xhr, status, data) {
            // If a local callback was specified, fire it and pass it the data
            if (s.success) {
                s.success.call(s.context, data, status, xhr);
            }

            // Fire the global callback
            if (s.global) {
                jQuery.triggerGlobal(s, "ajaxSuccess", [xhr, s]);
            }
        },

        handleComplete: function (s, xhr, status) {
            // Process result
            if (s.complete) {
                s.complete.call(s.context, xhr, status);
            }

            // The request was completed
            if (s.global) {
                jQuery.triggerGlobal(s, "ajaxComplete", [xhr, s]);
            }

            // Handle the global AJAX counter
            if (s.global && jQuery.active-- === 1) {
                jQuery.event.trigger("ajaxStop");
            }
        },

        triggerGlobal: function (s, type, args) {
            (s.context && s.context.url == null ? jQuery(s.context) : jQuery.event).trigger(type, args);
        },

        // Determines if an XMLHttpRequest was successful or not
        httpSuccess: function (xhr) {
            try {
                // IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450
                return !xhr.status && location.protocol === "file:" ||
                    xhr.status >= 200 && xhr.status < 300 ||
                    xhr.status === 304 || xhr.status === 1223;
            } catch (e) { }

            return false;
        },

        // Determines if an XMLHttpRequest returns NotModified
        httpNotModified: function (xhr, url) {
            var lastModified = xhr.getResponseHeader("Last-Modified"),
                etag = xhr.getResponseHeader("Etag");

            if (lastModified) {
                jQuery.lastModified[url] = lastModified;
            }

            if (etag) {
                jQuery.etag[url] = etag;
            }

            return xhr.status === 304;
        },

        httpData: function (xhr, type, s) {
            var ct = xhr.getResponseHeader("content-type") || "",
                xml = type === "xml" || !type && ct.indexOf("xml") >= 0,
                data = xml ? xhr.responseXML : xhr.responseText;

            if (xml && data.documentElement.nodeName === "parsererror") {
                jQuery.error("parsererror");
            }

            // Allow a pre-filtering function to sanitize the response
            // s is checked to keep backwards compatibility
            if (s && s.dataFilter) {
                data = s.dataFilter(data, type);
            }

            // The filter can actually parse the response
            if (typeof data === "string") {
                // Get the JavaScript object, if JSON is used.
                if (type === "json" || !type && ct.indexOf("json") >= 0) {
                    data = jQuery.parseJSON(data);

                    // If the type is "script", eval it in global context
                } else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
                    jQuery.globalEval(data);
                }
            }

            return data;
        }

    });

    /*
     * Create the request object; Microsoft failed to properly
     * implement the XMLHttpRequest in IE7 (can't request local files),
     * so we use the ActiveXObject when it is available
     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
     * we need a fallback.
     */
    if (window.ActiveXObject) {
        jQuery.ajaxSettings.xhr = function () {
            if (window.location.protocol !== "file:") {
                try {
                    return new window.XMLHttpRequest();
                } catch (xhrError) { }
            }

            try {
                return new window.ActiveXObject("Microsoft.XMLHTTP");
            } catch (activeError) { }
        };
    }

    // Does this browser support XHR requests?
    jQuery.support.ajax = !!jQuery.ajaxSettings.xhr();




    var elemdisplay = {},
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = /^([+\-]=)?([\d+.\-]+)(.*)$/,
        timerId,
        fxAttrs = [
            // height animations
            ["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
            // width animations
            ["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
            // opacity animations
            ["opacity"]
        ];

    jQuery.fn.extend({
        show: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("show", 3), speed, easing, callback);
            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    // Reset the inline display of this element to learn if it is
                    // being hidden by cascaded rules or not
                    if (!jQuery.data(this[i], "olddisplay") && this[i].style.display === "none") {
                        this[i].style.display = "";
                    }

                    // Set elements which have been overridden with display: none
                    // in a stylesheet to whatever the default browser style is
                    // for such an element
                    if (this[i].style.display === "" && jQuery.css(this[i], "display") === "none") {
                        jQuery.data(this[i], "olddisplay", defaultDisplay(this[i].nodeName));
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    this[i].style.display = jQuery.data(this[i], "olddisplay") || "";
                }

                return this;
            }
        },

        hide: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("hide", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    var display = jQuery.css(this[i], "display");

                    if (display !== "none") {
                        jQuery.data(this[i], "olddisplay", display);
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    this[i].style.display = "none";
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: function (fn, fn2, callback) {
            var bool = typeof fn === "boolean";

            if (jQuery.isFunction(fn) && jQuery.isFunction(fn2)) {
                this._toggle.apply(this, arguments);

            } else if (fn == null || bool) {
                this.each(function () {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[state ? "show" : "hide"]();
                });

            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }

            return this;
        },

        fadeTo: function (speed, to, easing, callback) {
            return this.filter(":hidden").css("opacity", 0).show().end()
                .animate({ opacity: to }, speed, easing, callback);
        },

        animate: function (prop, speed, easing, callback) {
            var optall = jQuery.speed(speed, easing, callback);

            if (jQuery.isEmptyObject(prop)) {
                return this.each(optall.complete);
            }

            return this[optall.queue === false ? "each" : "queue"](function () {
                // XXX ‘this’ does not always have a nodeName when running the
                // test suite

                var opt = jQuery.extend({}, optall), p,
                    isElement = this.nodeType === 1,
                    hidden = isElement && jQuery(this).is(":hidden"),
                    self = this;

                for (p in prop) {
                    var name = jQuery.camelCase(p);

                    if (p !== name) {
                        prop[name] = prop[p];
                        delete prop[p];
                        p = name;
                    }

                    if (prop[p] === "hide" && hidden || prop[p] === "show" && !hidden) {
                        return opt.complete.call(this);
                    }

                    if (isElement && (p === "height" || p === "width")) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height
                        // animated
                        if (jQuery.css(this, "display") === "inline" &&
                            jQuery.css(this, "float") === "none") {
                            if (!jQuery.support.inlineBlockNeedsLayout) {
                                this.style.display = "inline-block";

                            } else {
                                var display = defaultDisplay(this.nodeName);

                                // inline-level elements accept inline-block;
                                // block-level elements need to be inline with layout
                                if (display === "inline") {
                                    this.style.display = "inline-block";

                                } else {
                                    this.style.display = "inline";
                                    this.style.zoom = 1;
                                }
                            }
                        }
                    }

                    if (jQuery.isArray(prop[p])) {
                        // Create (if needed) and add to specialEasing
                        (opt.specialEasing = opt.specialEasing || {})[p] = prop[p][1];
                        prop[p] = prop[p][0];
                    }
                }

                if (opt.overflow != null) {
                    this.style.overflow = "hidden";
                }

                opt.curAnim = jQuery.extend({}, prop);

                jQuery.each(prop, function (name, val) {
                    var e = new jQuery.fx(self, opt, name);

                    if (rfxtypes.test(val)) {
                        e[val === "toggle" ? hidden ? "show" : "hide" : val](prop);

                    } else {
                        var parts = rfxnum.exec(val),
                            start = e.cur(true) || 0;

                        if (parts) {
                            var end = parseFloat(parts[2]),
                                unit = parts[3] || "px";

                            // We need to compute starting value
                            if (unit !== "px") {
                                jQuery.style(self, name, (end || 1) + unit);
                                start = ((end || 1) / e.cur(true)) * start;
                                jQuery.style(self, name, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if (parts[1]) {
                                end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                            }

                            e.custom(start, end, unit);

                        } else {
                            e.custom(start, val, "");
                        }
                    }
                });

                // For JS strict compliance
                return true;
            });
        },

        stop: function (clearQueue, gotoEnd) {
            var timers = jQuery.timers;

            if (clearQueue) {
                this.queue([]);
            }

            this.each(function () {
                // go in reverse order so anything added to the queue during the loop is ignored
                for (var i = timers.length - 1; i >= 0; i--) {
                    if (timers[i].elem === this) {
                        if (gotoEnd) {
                            // force the next step to be the last
                            timers[i](true);
                        }

                        timers.splice(i, 1);
                    }
                }
            });

            // start the next in the queue if the last step wasn't forced
            if (!gotoEnd) {
                this.dequeue();
            }

            return this;
        }

    });

    function genFx(type, num) {
        var obj = {};

        jQuery.each(fxAttrs.concat.apply([], fxAttrs.slice(0, num)), function () {
            obj[this] = type;
        });

        return obj;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show", 1),
        slideUp: genFx("hide", 1),
        slideToggle: genFx("toggle", 1),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.extend({
        speed: function (speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing ||
                    jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

            // Queueing
            opt.old = opt.complete;
            opt.complete = function () {
                if (opt.queue !== false) {
                    jQuery(this).dequeue();
                }
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }
            };

            return opt;
        },

        easing: {
            linear: function (p, n, firstNum, diff) {
                return firstNum + diff * p;
            },
            swing: function (p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
            }
        },

        timers: [],

        fx: function (elem, options, prop) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;

            if (!options.orig) {
                options.orig = {};
            }
        }

    });

    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: function () {
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            (jQuery.fx.step[this.prop] || jQuery.fx.step._default)(this);
        },

        // Get the current size
        cur: function () {
            if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {
                return this.elem[this.prop];
            }

            var r = parseFloat(jQuery.css(this.elem, this.prop));
            return r && r > -10000 ? r : 0;
        },

        // Start an animation from one number to another
        custom: function (from, to, unit) {
            this.startTime = jQuery.now();
            this.start = from;
            this.end = to;
            this.unit = unit || this.unit || "px";
            this.now = this.start;
            this.pos = this.state = 0;

            var self = this, fx = jQuery.fx;
            function t(gotoEnd) {
                return self.step(gotoEnd);
            }

            t.elem = this.elem;

            if (t() && jQuery.timers.push(t) && !timerId) {
                timerId = setInterval(fx.tick, fx.interval);
            }
        },

        // Simple 'show' function
        show: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.show = true;

            // Begin the animation
            // Make sure that we start at a small width/height to avoid any
            // flash of content
            this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

            // Start by showing the element
            jQuery(this.elem).show();
        },

        // Simple 'hide' function
        hide: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.hide = true;

            // Begin the animation
            this.custom(this.cur(), 0);
        },

        // Each step of an animation
        step: function (gotoEnd) {
            var t = jQuery.now(), done = true;

            if (gotoEnd || t >= this.options.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                this.options.curAnim[this.prop] = true;

                for (var i in this.options.curAnim) {
                    if (this.options.curAnim[i] !== true) {
                        done = false;
                    }
                }

                if (done) {
                    // Reset the overflow
                    if (this.options.overflow != null && !jQuery.support.shrinkWrapBlocks) {
                        var elem = this.elem, options = this.options;
                        jQuery.each(["", "X", "Y"], function (index, value) {
                            elem.style["overflow" + value] = options.overflow[index];
                        });
                    }

                    // Hide the element if the "hide" operation was done
                    if (this.options.hide) {
                        jQuery(this.elem).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if (this.options.hide || this.options.show) {
                        for (var p in this.options.curAnim) {
                            jQuery.style(this.elem, p, this.options.orig[p]);
                        }
                    }

                    // Execute the complete function
                    this.options.complete.call(this.elem);
                }

                return false;

            } else {
                var n = t - this.startTime;
                this.state = n / this.options.duration;

                // Perform the easing function, defaults to swing
                var specialEasing = this.options.specialEasing && this.options.specialEasing[this.prop];
                var defaultEasing = this.options.easing || (jQuery.easing.swing ? "swing" : "linear");
                this.pos = jQuery.easing[specialEasing || defaultEasing](this.state, n, 0, 1, this.options.duration);
                this.now = this.start + ((this.end - this.start) * this.pos);

                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend(jQuery.fx, {
        tick: function () {
            var timers = jQuery.timers;

            for (var i = 0; i < timers.length; i++) {
                if (!timers[i]()) {
                    timers.splice(i--, 1);
                }
            }

            if (!timers.length) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: function () {
            clearInterval(timerId);
            timerId = null;
        },

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: function (fx) {
                jQuery.style(fx.elem, "opacity", fx.now);
            },

            _default: function (fx) {
                if (fx.elem.style && fx.elem.style[fx.prop] != null) {
                    fx.elem.style[fx.prop] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
                } else {
                    fx.elem[fx.prop] = fx.now;
                }
            }
        }
    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
            }).length;
        };
    }

    function defaultDisplay(nodeName) {
        if (!elemdisplay[nodeName]) {
            var elem = jQuery("<" + nodeName + ">").appendTo("body"),
                display = elem.css("display");

            elem.remove();

            if (display === "none" || display === "") {
                display = "block";
            }

            elemdisplay[nodeName] = display;
        }

        return elemdisplay[nodeName];
    }




    var rtable = /^t(?:able|d|h)$/i,
        rroot = /^(?:body|html)$/i;

    if ("getBoundingClientRect" in document.documentElement) {
        jQuery.fn.offset = function (options) {
            var elem = this[0], box;

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            try {
                box = elem.getBoundingClientRect();
            } catch (e) { }

            var doc = elem.ownerDocument,
                docElem = doc.documentElement;

            // Make sure we're not dealing with a disconnected DOM node
            if (!box || !jQuery.contains(docElem, elem)) {
                return box || { top: 0, left: 0 };
            }

            var body = doc.body,
                win = getWindow(doc),
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                scrollTop = (win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop),
                scrollLeft = (win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft),
                top = box.top + scrollTop - clientTop,
                left = box.left + scrollLeft - clientLeft;

            return { top: top, left: left };
        };

    } else {
        jQuery.fn.offset = function (options) {
            var elem = this[0];

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            jQuery.offset.initialize();

            var offsetParent = elem.offsetParent, prevOffsetParent = elem,
                doc = elem.ownerDocument, computedStyle, docElem = doc.documentElement,
                body = doc.body, defaultView = doc.defaultView,
                prevComputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle,
                top = elem.offsetTop, left = elem.offsetLeft;

            while ((elem = elem.parentNode) && elem !== body && elem !== docElem) {
                if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                    break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top -= elem.scrollTop;
                left -= elem.scrollLeft;

                if (elem === offsetParent) {
                    top += elem.offsetTop;
                    left += elem.offsetLeft;

                    if (jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName))) {
                        top += parseFloat(computedStyle.borderTopWidth) || 0;
                        left += parseFloat(computedStyle.borderLeftWidth) || 0;
                    }

                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }

                if (jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible") {
                    top += parseFloat(computedStyle.borderTopWidth) || 0;
                    left += parseFloat(computedStyle.borderLeftWidth) || 0;
                }

                prevComputedStyle = computedStyle;
            }

            if (prevComputedStyle.position === "relative" || prevComputedStyle.position === "static") {
                top += body.offsetTop;
                left += body.offsetLeft;
            }

            if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                top += Math.max(docElem.scrollTop, body.scrollTop);
                left += Math.max(docElem.scrollLeft, body.scrollLeft);
            }

            return { top: top, left: left };
        };
    }

    jQuery.offset = {
        initialize: function () {
            var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat(jQuery.css(body, "marginTop")) || 0,
                html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

            jQuery.extend(container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" });

            container.innerHTML = html;
            body.insertBefore(container, body.firstChild);
            innerDiv = container.firstChild;
            checkDiv = innerDiv.firstChild;
            td = innerDiv.nextSibling.firstChild.firstChild;

            this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
            this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

            checkDiv.style.position = "fixed";
            checkDiv.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
            checkDiv.style.position = checkDiv.style.top = "";

            innerDiv.style.overflow = "hidden";
            innerDiv.style.position = "relative";

            this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

            this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

            body.removeChild(container);
            body = container = innerDiv = checkDiv = table = td = null;
            jQuery.offset.initialize = jQuery.noop;
        },

        bodyOffset: function (body) {
            var top = body.offsetTop, left = body.offsetLeft;

            jQuery.offset.initialize();

            if (jQuery.offset.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function (elem, options, i) {
            var position = jQuery.css(elem, "position");

            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            var curElem = jQuery(elem),
                curOffset = curElem.offset(),
                curCSSTop = jQuery.css(elem, "top"),
                curCSSLeft = jQuery.css(elem, "left"),
                calculatePosition = (position === "absolute" && jQuery.inArray('auto', [curCSSTop, curCSSLeft]) > -1),
                props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is absolute
            if (calculatePosition) {
                curPosition = curElem.position();
            }

            curTop = calculatePosition ? curPosition.top : parseInt(curCSSTop, 10) || 0;
            curLeft = calculatePosition ? curPosition.left : parseInt(curCSSLeft, 10) || 0;

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };


    jQuery.fn.extend({
        position: function () {
            if (!this[0]) {
                return null;
            }

            var elem = this[0],

                // Get *real* offsetParent
                offsetParent = this.offsetParent(),

                // Get correct offsets
                offset = this.offset(),
                parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

            // Add offsetParent borders
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

            // Subtract the two offsets
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each(["Left", "Top"], function (i, name) {
        var method = "scroll" + name;

        jQuery.fn[method] = function (val) {
            var elem = this[0], win;

            if (!elem) {
                return null;
            }

            if (val !== undefined) {
                // Set the scroll offset
                return this.each(function () {
                    win = getWindow(this);

                    if (win) {
                        win.scrollTo(
                            !i ? val : jQuery(win).scrollLeft(),
                            i ? val : jQuery(win).scrollTop()
                        );

                    } else {
                        this[method] = val;
                    }
                });
            } else {
                win = getWindow(elem);

                // Return the scroll offset
                return win ? ("pageXOffset" in win) ? win[i ? "pageYOffset" : "pageXOffset"] :
                    jQuery.support.boxModel && win.document.documentElement[method] ||
                    win.document.body[method] :
                    elem[method];
            }
        };
    });

    function getWindow(elem) {
        return jQuery.isWindow(elem) ?
            elem :
            elem.nodeType === 9 ?
                elem.defaultView || elem.parentWindow :
                false;
    }




    // Create innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each(["Height", "Width"], function (i, name) {

        var type = name.toLowerCase();

        // innerHeight and innerWidth
        jQuery.fn["inner" + name] = function () {
            return this[0] ?
                parseFloat(jQuery.css(this[0], type, "padding")) :
                null;
        };

        // outerHeight and outerWidth
        jQuery.fn["outer" + name] = function (margin) {
            return this[0] ?
                parseFloat(jQuery.css(this[0], type, margin ? "margin" : "border")) :
                null;
        };

        jQuery.fn[type] = function (size) {
            // Get window width or height
            var elem = this[0];
            if (!elem) {
                return size == null ? null : this;
            }

            if (jQuery.isFunction(size)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self[type](size.call(this, i, self[type]()));
                });
            }

            return jQuery.isWindow(elem) ?
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                elem.document.compatMode === "CSS1Compat" && elem.document.documentElement["client" + name] ||
                elem.document.body["client" + name] :

                // Get document width or height
                (elem.nodeType === 9) ? // is it a document
                    // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                    Math.max(
                        elem.documentElement["client" + name],
                        elem.body["scroll" + name], elem.documentElement["scroll" + name],
                        elem.body["offset" + name], elem.documentElement["offset" + name]
                    ) :

                    // Get or set width or height on the element
                    size === undefined ?
                        // Get width or height on the element
                        parseFloat(jQuery.css(elem, type)) :

                        // Set the width or height on the element (default to pixels if value is unitless)
                        this.css(type, typeof size === "string" ? size : size + "px");
        };

    });


})(window);


(function () {

    window.jQuerySG = jQuery.noConflict(true);

}).call(this);

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/src/index.js?!./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css":
/*!*********************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/src??ref--2-2!./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css ***!
  \*********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/* line 1, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main {\n    azimuth: center !important;\n    background-attachment: scroll !important;\n    background-image: none !important;\n    background-position: 0% 0% !important;\n    background-repeat: repeat !important;\n    border-collapse: separate !important;\n    border-spacing: 0 !important;\n    bottom: auto !important;\n    caption-side: top !important;\n    clear: none !important;\n    clip: auto !important;\n    color: black !important;\n    content: normal !important;\n    counter-increment: none !important;\n    counter-reset: none !important;\n    cursor: auto !important;\n    direction: ltr !important;\n    elevation: level !important;\n    empty-cells: show !important;\n    font-family: sans-serif !important;\n    font-variant: normal !important;\n    font-weight: normal !important;\n    height: auto !important;\n    left: auto !important;\n    letter-spacing: normal !important;\n    line-height: normal !important;\n    list-style-image: none !important;\n    list-style-position: outside !important;\n    list-style-type: disc !important;\n    max-height: none !important;\n    max-width: none !important;\n    min-height: 0 !important;\n    min-width: 0 !important;\n    orphans: 2 !important;\n    outline-color: invert !important;\n    outline-style: none !important;\n    outline-width: medium !important;\n    overflow: visible !important;\n    page-break-after: auto !important;\n    page-break-before: auto !important;\n    page-break-inside: auto !important;\n    table-layout: auto !important;\n    text-align: left !important;\n    text-decoration: none !important;\n    text-indent: 0 !important;\n    text-transform: none !important;\n    top: auto !important;\n    unicode-bidi: normal !important;\n    vertical-align: baseline !important;\n    visibility: visible !important;\n    white-space: normal !important;\n    widows: 2 !important;\n    width: auto !important;\n    word-spacing: normal !important;\n    position: fixed !important;\n    z-index: 9999999 !important;\n    display: block !important;\n    right: 5px !important;\n    margin: 5px !important;\n    padding: 5px !important;\n    font-size: 14px !important;\n    float: none !important;\n    border: 1px solid black !important;\n    font-style: none !important;\n    background: white !important;\n    text-align: left !important;\n}\n\n\n/* line 71, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main *,\n.selectorgadget_clean,\n.selectorgadget_clean * {\n    azimuth: center;\n    background-attachment: scroll;\n    background-image: none;\n    background-position: 0% 0%;\n    background-repeat: repeat;\n    border-collapse: separate;\n    border-spacing: 0;\n    bottom: auto;\n    caption-side: top;\n    clear: none;\n    clip: auto;\n    color: black;\n    content: normal;\n    counter-increment: none;\n    counter-reset: none;\n    cursor: auto;\n    direction: ltr;\n    elevation: level;\n    empty-cells: show;\n    font-family: sans-serif;\n    font-variant: normal;\n    font-weight: normal;\n    height: auto;\n    left: auto;\n    letter-spacing: normal;\n    line-height: normal;\n    list-style-image: none;\n    list-style-position: outside;\n    list-style-type: disc;\n    max-height: none;\n    max-width: none;\n    min-height: 0;\n    min-width: 0;\n    orphans: 2;\n    outline-color: invert;\n    outline-style: none;\n    outline-width: medium;\n    overflow: visible;\n    page-break-after: auto;\n    page-break-before: auto;\n    page-break-inside: auto;\n    table-layout: auto;\n    text-align: left;\n    text-decoration: none;\n    text-indent: 0;\n    text-transform: none;\n    top: auto;\n    unicode-bidi: normal;\n    vertical-align: baseline;\n    visibility: visible;\n    white-space: normal;\n    widows: 2;\n    width: auto;\n    word-spacing: normal;\n    right: 0px;\n    margin: 0;\n    padding: 0;\n    font-size: 14px;\n    float: none;\n    font-style: none;\n    background: white;\n    text-align: left;\n}\n\n\n/* line 136, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_clean a {\n    color: blue;\n    text-decoration: underline;\n    cursor: pointer;\n}\n\n\n/* line 142, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main .selectorgadget_input_field {\n    display: block;\n    float: left;\n    margin: 0 7px 0 0;\n    background-color: #f5f5f5;\n    border: 1px solid #dedede;\n    border-top: 1px solid #eee;\n    border-left: 1px solid #eee;\n    font-family: \"Lucida Grande\", Tahoma, Arial, Verdana, sans-serif;\n    text-decoration: none;\n    color: #565656;\n    cursor: pointer;\n    padding: 5px 8px 6px 7px;\n}\n\n\n/* line 161, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main .selectorgadget_wizard .selectorgadget_input_field {\n    margin: 7px 3px 7px 3px;\n    float: none;\n    display: inline;\n}\n\n\n/* line 167, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main .selectorgadget_prompt {\n    margin: 3px 0px 3px 0px;\n    font-family: \"Lucida Grande\", Tahoma, Arial, Verdana, sans-serif;\n    font-weight: bold;\n    float: none;\n}\n\n\n/* line 174, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main .selectorgadget_wizard #selectorgadget_path_field {\n    margin: 5px 0px;\n    clear: both;\n    float: none;\n    display: block;\n}\n\n\n/* line 181, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_selected {\n    background-color: #0F0 !important;\n    background-image: none !important;\n}\n\n\n/* line 186, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_suggested {\n    background-color: #FF5 !important;\n    background-image: none !important;\n}\n\n\n/* line 191, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_border {\n    position: absolute !important;\n    z-index: 999999 !important;\n    background: white !important;\n    background-color: orange !important;\n    margin: 0px !important;\n    padding: 0px !important;\n    display: block !important;\n    float: none !important;\n    border: 0 !important;\n    font-style: none !important;\n    outline: 0 !important;\n    vertical-align: baseline !important;\n    text-align: left !important;\n}\n\n\n/* line 207, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_bottom_border {\n    font-size: 10px !important;\n    padding: 2px 0px 2px 5px !important;\n}\n\n\n/* line 212, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_border_red {\n    background-color: #F00 !important;\n}\n\n\n/* line 219, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_rejected {\n    background-color: #F00 !important;\n    background-image: none !important;\n}\n\n\n/* line 225, lib/css/selectorgadget.css.scss */\n\nimg.selectorgadget_rejected {\n    border: 5px solid #F00 !important;\n}\n\n\n/* line 229, lib/css/selectorgadget.css.scss */\n\nimg.selectorgadget_suggested {\n    border: 5px solid #FF5 !important;\n}\n\n\n/* line 233, lib/css/selectorgadget.css.scss */\n\nimg.selectorgadget_selected {\n    border: 5px solid #0F0 !important;\n}\n\n\n/* line 238, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main.selectorgadget_top {\n    top: 5px !important;\n}\n\n\n/* line 242, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main.selectorgadget_bottom {\n    bottom: 5px !important;\n}\n\n\n/* line 246, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main input {\n    margin-right: 10px !important;\n    font-size: 15px !important;\n}\n\n\n/* line 251, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_path_field {\n    width: 400px !important;\n}\n\n\n/* line 255, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main .selectorgadget_new_line {\n    clear: both;\n}\n\n\n/* line 259, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main .selectorgadget_option {\n    float: left;\n}\n\n\n/* line 263, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main .selectorgadget_selected_option {\n    text-decoration: underline;\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/addStylesClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/addStylesClient.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return addStylesClient; });
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listToStyles */ "./node_modules/vue-style-loader/lib/listToStyles.js");
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = Object(_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = Object(_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/listToStyles.js":
/*!***********************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/listToStyles.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return listToStyles; });
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),

/***/ "./src/backend.js":
/*!************************!*\
  !*** ./src/backend.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spider-rulegen/vendor */ "./node_modules/@spider-rulegen/vendor/index.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/utils.js");




const emitter = new events__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]()
_spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__["SelectorGadget"].prototype.emitter = emitter

const port = chrome.runtime.connect({
    name: 'content-script'
})

port.onMessage.addListener(handleMessageFromDevtools)
port.onDisconnect.addListener(handleDisconnect)

let pathStore = ''

emitter.on("setPath", (e) => {
    if (pathStore !== e) {
        pathStore = e
        sendMessageToDevtools({ type: "selector:update", value: e })
    }
})

function sendMessageToDevtools(msg) {
    port.postMessage(msg)
}

function handleMessageFromDevtools(e) {
    switch (e.type) {
        case "selector:load":
            console.log("backend - load path: ", e.value)
            // ensure open
            const sg = _spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__["SelectorGadget"].toggleOpen()
            pathStore = sg.refreshFromPath({ value: e.value })
            break
        case "selector:deactive":
            _spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__["SelectorGadget"].toggleClose()
            break
        case "location:href":
            window.location.href = e.value
            break
        case "extract:urls":
            sendMessageToDevtools({ type: "extracted:urls", value: Object(_utils__WEBPACK_IMPORTED_MODULE_2__["getUrls"])(e.value) })
    }
}

function handleDisconnect() {
    _spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__["SelectorGadget"].toggleClose()
}



/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: getUrls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrls", function() { return getUrls; });
function getUrls(cssSelector) {
    if (!cssSelector) {
        return []
    }
    const domList = document.querySelectorAll(cssSelector)
    const urls = new Set()
    const hasSeen = new Set()

    function cb(node) {
        if (hasSeen.has(node)) {
            return false
        } else {
            hasSeen.add(node)
            if (node.nodeName === 'A') {
                const url = (node.href || '').trim()
                if (url) {
                    urls.add(url)
                }
                return false
            } else {
                return true
            }
        }
    }

    for (const domItem of domList) {
        domTraverse(domItem, cb)
    }
    return Array.from(urls);
}

function domTraverse(domItem, cb) {
    const goInto = cb(domItem)
    if (goInto && domItem.childNodes) {
        for (const node of domItem.childNodes) {
            domTraverse(node, cb)
        }
    }
}

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzcGlkZXItcnVsZWdlbi92ZW5kb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzcGlkZXItcnVsZWdlbi92ZW5kb3Ivc2VsZWN0b3JnYWRnZXQvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcz80ZjIyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3BpZGVyLXJ1bGVnZW4vdmVuZG9yL3NlbGVjdG9yZ2FkZ2V0L2pzL2NvcmUvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNwaWRlci1ydWxlZ2VuL3ZlbmRvci9zZWxlY3RvcmdhZGdldC9qcy9jb3JlL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNwaWRlci1ydWxlZ2VuL3ZlbmRvci9zZWxlY3RvcmdhZGdldC9qcy9kaWZmLWJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzcGlkZXItcnVsZWdlbi92ZW5kb3Ivc2VsZWN0b3JnYWRnZXQvanMvanF1ZXJ5LWJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzcGlkZXItcnVsZWdlbi92ZW5kb3Ivc2VsZWN0b3JnYWRnZXQvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZW5kLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTREO0FBQ1o7QUFDRjs7Ozs7Ozs7Ozs7O0FDRjlDOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHlQQUEwRztBQUNoSSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLG1IQUFzRDtBQUN4RSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLEtBQVUsRUFBRSxFOzs7Ozs7Ozs7Ozs7Ozs7O0FDVGY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkM7O0FBRXBDLDJCQUEyQjs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELHdEQUFtQjs7QUFFcEU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7QUN6b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sZ0NBQWdDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFD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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUzs7QUFFVCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYiwrQkFBK0IsRUFBRTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtRkFBbUYsdUJBQXVCO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7OztBQUdMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGLFdBQVcsWUFBWTs7QUFFdkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNCQUFzQjs7QUFFbkM7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix1QkFBdUI7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELE9BQU87QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxT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O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7O0FBRWIsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQzs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FB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ZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2JhY2tlbmQuanNcIik7XG4iLCJpbXBvcnQgc3R5bGVzIGZyb20gXCIuL3NlbGVjdG9yZ2FkZ2V0L2Nzcy9zZWxlY3RvcmdhZGdldC5jc3NcIlxuaW1wb3J0IGpxIGZyb20gXCIuL3NlbGVjdG9yZ2FkZ2V0L2pzL2pxdWVyeS1iaW5kXCJcbmltcG9ydCBkZiBmcm9tIFwiLi9zZWxlY3RvcmdhZGdldC9qcy9kaWZmLWJpbmRcIlxuZXhwb3J0IHsgU2VsZWN0b3JHYWRnZXQgfSBmcm9tIFwiLi9zZWxlY3RvcmdhZGdldC9qcy9jb3JlL2NvcmVcIiIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0yLTIhLi9zZWxlY3RvcmdhZGdldC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI0YmZiYmY2YlwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMi0yIS4vc2VsZWN0b3JnYWRnZXQuY3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTItMiEuL3NlbGVjdG9yZ2FkZ2V0LmNzc1wiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiXG4vKlxuIFRoZSBNSVQgTGljZW5zZVxuIENvcHlyaWdodCAoYykgMjAxMiBBbmRyZXcgQ2FudGlub1xuIENvcHlyaWdodCAoYykgMjAwOSBBbmRyZXcgQ2FudGlubyAmIEt5bGUgTWF4d2VsbFxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiBUSEUgU09GVFdBUkUuXG4qL1xuXG5pbXBvcnQgeyBEb21QcmVkaWN0aW9uSGVscGVyIH0gZnJvbSBcIi4vZG9tXCJcblxuZXhwb3J0IGZ1bmN0aW9uIFNlbGVjdG9yR2FkZ2V0KCkgeyB9XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5ib3JkZXJfd2lkdGggPSA1O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuYm9yZGVyX3BhZGRpbmcgPSAyO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuYl90b3AgPSBudWxsO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuYl9sZWZ0ID0gbnVsbDtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmJfcmlnaHQgPSBudWxsO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuYl9ib3R0b20gPSBudWxsO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2VsZWN0ZWQgPSBbXTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJlamVjdGVkID0gW107XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zcGVjaWFsX21vZGUgPSBudWxsO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUucGF0aF9vdXRwdXRfZmllbGQgPSBudWxsO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2dfZGl2ID0gbnVsbDtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmlnbm9yZV9jbGFzcyA9ICdzZWxlY3RvcmdhZGdldF9pZ25vcmUnO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUudW5ib3VuZCA9IGZhbHNlO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUucHJlZGljdGlvbl9oZWxwZXIgPSBuZXcgRG9tUHJlZGljdGlvbkhlbHBlcigpO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUucmVzdHJpY3RlZF9lbGVtZW50cyA9IGpRdWVyeVNHLm1hcChbJ2h0bWwnLCAnYm9keScsICdoZWFkJywgJ2Jhc2UnXSwgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGpRdWVyeVNHKHNlbGVjdG9yKS5nZXQoMCk7XG59KTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLm1ha2VCb3JkZXJzID0gZnVuY3Rpb24gKG9yaWdfZWxlbSwgbWFrZVJlZCkge1xuICAgIHZhciBlbGVtLCBoZWlnaHQsIGxlZnQsIHAsIHBhdGhfdG9fc2hvdywgdG9wLCB3aWR0aDtcbiAgICB0aGlzLnJlbW92ZUJvcmRlcnMoKTtcbiAgICB0aGlzLnNldHVwQm9yZGVycygpO1xuICAgIGlmIChvcmlnX2VsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICBwYXRoX3RvX3Nob3cgPSBvcmlnX2VsZW0ucGFyZW50Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgKyAnICcgKyBvcmlnX2VsZW0udGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGhfdG9fc2hvdyA9IG9yaWdfZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGVsZW0gPSBqUXVlcnlTRyhvcmlnX2VsZW0pO1xuICAgIHAgPSBlbGVtLm9mZnNldCgpO1xuICAgIHRvcCA9IHAudG9wO1xuICAgIGxlZnQgPSBwLmxlZnQ7XG4gICAgd2lkdGggPSBlbGVtLm91dGVyV2lkdGgoKTtcbiAgICBoZWlnaHQgPSBlbGVtLm91dGVySGVpZ2h0KCk7XG4gICAgdGhpcy5iX3RvcC5jc3MoJ3dpZHRoJywgdGhpcy5weCh3aWR0aCArIHRoaXMuYm9yZGVyX3BhZGRpbmcgKiAyICsgdGhpcy5ib3JkZXJfd2lkdGggKiAyKSkuY3NzKCd0b3AnLCB0aGlzLnB4KHRvcCAtIHRoaXMuYm9yZGVyX3dpZHRoIC0gdGhpcy5ib3JkZXJfcGFkZGluZykpLmNzcygnbGVmdCcsIHRoaXMucHgobGVmdCAtIHRoaXMuYm9yZGVyX3BhZGRpbmcgLSB0aGlzLmJvcmRlcl93aWR0aCkpO1xuICAgIHRoaXMuYl9ib3R0b20uY3NzKCd3aWR0aCcsIHRoaXMucHgod2lkdGggKyB0aGlzLmJvcmRlcl9wYWRkaW5nICogMiArIHRoaXMuYm9yZGVyX3dpZHRoICogMiAtIDUpKS5jc3MoJ3RvcCcsIHRoaXMucHgodG9wICsgaGVpZ2h0ICsgdGhpcy5ib3JkZXJfcGFkZGluZykpLmNzcygnbGVmdCcsIHRoaXMucHgobGVmdCAtIHRoaXMuYm9yZGVyX3BhZGRpbmcgLSB0aGlzLmJvcmRlcl93aWR0aCkpLnRleHQocGF0aF90b19zaG93KTtcbiAgICB0aGlzLmJfbGVmdC5jc3MoJ2hlaWdodCcsIHRoaXMucHgoaGVpZ2h0ICsgdGhpcy5ib3JkZXJfcGFkZGluZyAqIDIpKS5jc3MoJ3RvcCcsIHRoaXMucHgodG9wIC0gdGhpcy5ib3JkZXJfcGFkZGluZykpLmNzcygnbGVmdCcsIHRoaXMucHgobGVmdCAtIHRoaXMuYm9yZGVyX3BhZGRpbmcgLSB0aGlzLmJvcmRlcl93aWR0aCkpO1xuICAgIHRoaXMuYl9yaWdodC5jc3MoJ2hlaWdodCcsIHRoaXMucHgoaGVpZ2h0ICsgdGhpcy5ib3JkZXJfcGFkZGluZyAqIDIpKS5jc3MoJ3RvcCcsIHRoaXMucHgodG9wIC0gdGhpcy5ib3JkZXJfcGFkZGluZykpLmNzcygnbGVmdCcsIHRoaXMucHgobGVmdCArIHdpZHRoICsgdGhpcy5ib3JkZXJfcGFkZGluZykpO1xuICAgIHRoaXMuYl9yaWdodC5nZXQoMCkudGFyZ2V0X2VsZW0gPSB0aGlzLmJfbGVmdC5nZXQoMCkudGFyZ2V0X2VsZW0gPSB0aGlzLmJfdG9wLmdldCgwKS50YXJnZXRfZWxlbSA9IHRoaXMuYl9ib3R0b20uZ2V0KDApLnRhcmdldF9lbGVtID0gb3JpZ19lbGVtO1xuICAgIGlmIChtYWtlUmVkIHx8IGVsZW0uaGFzQ2xhc3MoXCJzZWxlY3RvcmdhZGdldF9zdWdnZXN0ZWRcIikgfHwgZWxlbS5oYXNDbGFzcyhcInNlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkXCIpKSB7XG4gICAgICAgIHRoaXMuYl90b3AuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvcmRlcl9yZWQnKTtcbiAgICAgICAgdGhpcy5iX2JvdHRvbS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyX3JlZCcpO1xuICAgICAgICB0aGlzLmJfbGVmdC5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyX3JlZCcpO1xuICAgICAgICB0aGlzLmJfcmlnaHQuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvcmRlcl9yZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5iX3RvcC5oYXNDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyX3JlZCcpKSB7XG4gICAgICAgICAgICB0aGlzLmJfdG9wLnJlbW92ZUNsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXJfcmVkJyk7XG4gICAgICAgICAgICB0aGlzLmJfYm90dG9tLnJlbW92ZUNsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXJfcmVkJyk7XG4gICAgICAgICAgICB0aGlzLmJfbGVmdC5yZW1vdmVDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyX3JlZCcpO1xuICAgICAgICAgICAgdGhpcy5iX3JpZ2h0LnJlbW92ZUNsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXJfcmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2hvd0JvcmRlcnMoKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5weCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgKyAncHgnO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNob3dCb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYl90b3Auc2hvdygpO1xuICAgIHRoaXMuYl9ib3R0b20uc2hvdygpO1xuICAgIHRoaXMuYl9sZWZ0LnNob3coKTtcbiAgICByZXR1cm4gdGhpcy5iX3JpZ2h0LnNob3coKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5yZW1vdmVCb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmJfdG9wKSB7XG4gICAgICAgIHRoaXMuYl90b3AuaGlkZSgpO1xuICAgICAgICB0aGlzLmJfYm90dG9tLmhpZGUoKTtcbiAgICAgICAgdGhpcy5iX2xlZnQuaGlkZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5iX3JpZ2h0LmhpZGUoKTtcbiAgICB9XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2V0dXBCb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB3aWR0aDtcbiAgICBpZiAoIXRoaXMuYl90b3ApIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLmJvcmRlcl93aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuYl90b3AgPSBqUXVlcnlTRygnPGRpdj4nKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyJykuY3NzKCdoZWlnaHQnLCB3aWR0aCkuaGlkZSgpLmJpbmQoXCJtb3VzZWRvd24uc2dcIiwge1xuICAgICAgICAgICAgJ3NlbGYnOiB0aGlzXG4gICAgICAgIH0sIHRoaXMuc2dNb3VzZWRvd24pO1xuICAgICAgICB0aGlzLmJfYm90dG9tID0galF1ZXJ5U0coJzxkaXY+JykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvcmRlcicpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3R0b21fYm9yZGVyJykuY3NzKCdoZWlnaHQnLCB0aGlzLnB4KHRoaXMuYm9yZGVyX3dpZHRoICsgNikpLmhpZGUoKS5iaW5kKFwibW91c2Vkb3duLnNnXCIsIHtcbiAgICAgICAgICAgICdzZWxmJzogdGhpc1xuICAgICAgICB9LCB0aGlzLnNnTW91c2Vkb3duKTtcbiAgICAgICAgdGhpcy5iX2xlZnQgPSBqUXVlcnlTRygnPGRpdj4nKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyJykuY3NzKCd3aWR0aCcsIHdpZHRoKS5oaWRlKCkuYmluZChcIm1vdXNlZG93bi5zZ1wiLCB7XG4gICAgICAgICAgICAnc2VsZic6IHRoaXNcbiAgICAgICAgfSwgdGhpcy5zZ01vdXNlZG93bik7XG4gICAgICAgIHRoaXMuYl9yaWdodCA9IGpRdWVyeVNHKCc8ZGl2PicpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXInKS5jc3MoJ3dpZHRoJywgd2lkdGgpLmhpZGUoKS5iaW5kKFwibW91c2Vkb3duLnNnXCIsIHtcbiAgICAgICAgICAgICdzZWxmJzogdGhpc1xuICAgICAgICB9LCB0aGlzLnNnTW91c2Vkb3duKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQm9yZGVyVG9Eb20oKTtcbiAgICB9XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuYWRkQm9yZGVyVG9Eb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJfdG9wLmdldCgwKSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJfYm90dG9tLmdldCgwKSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJfbGVmdC5nZXQoMCkpO1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYl9yaWdodC5nZXQoMCkpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJlbW92ZUJvcmRlckZyb21Eb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYl90b3ApIHtcbiAgICAgICAgdGhpcy5iX3RvcC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5iX2JvdHRvbS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5iX2xlZnQucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuYl9yaWdodC5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYl90b3AgPSB0aGlzLmJfYm90dG9tID0gdGhpcy5iX2xlZnQgPSB0aGlzLmJfcmlnaHQgPSBudWxsO1xuICAgIH1cbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zZWxlY3RhYmxlID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICByZXR1cm4gIXRoaXMuY3NzX3Jlc3RyaWN0aW9uIHx8ICh0aGlzLmNzc19yZXN0cmljdGlvbiAmJiBqUXVlcnlTRyhlbGVtKS5pcyh0aGlzLmNzc19yZXN0cmljdGlvbikpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNnTW91c2VvdmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZ2FkZ2V0LCBwYXJlbnQsIHNlbGY7XG4gICAgZ2FkZ2V0ID0gZS5kYXRhLnNlbGY7XG4gICAgaWYgKGdhZGdldC51bmJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcyA9PT0gZG9jdW1lbnQuYm9keSB8fCB0aGlzID09PSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxmID0galF1ZXJ5U0codGhpcyk7XG4gICAgZ2FkZ2V0LnVuaGlnaGxpZ2h0SWZyYW1lcygpO1xuICAgIGlmIChzZWxmLmlzKFwiaWZyYW1lXCIpKSB7XG4gICAgICAgIGdhZGdldC5oaWdobGlnaHRJZnJhbWUoc2VsZiwgZSk7XG4gICAgfVxuICAgIGlmIChnYWRnZXQuc3BlY2lhbF9tb2RlICE9PSAnZCcpIHtcbiAgICAgICAgcGFyZW50ID0gZ2FkZ2V0LmZpcnN0U2VsZWN0ZWRPclN1Z2dlc3RlZFBhcmVudCh0aGlzKTtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQgIT09IHRoaXMgJiYgZ2FkZ2V0LnNlbGVjdGFibGUocGFyZW50KSkge1xuICAgICAgICAgICAgZ2FkZ2V0Lm1ha2VCb3JkZXJzKHBhcmVudCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZ2FkZ2V0LnNlbGVjdGFibGUoc2VsZikpIHtcbiAgICAgICAgICAgICAgICBnYWRnZXQubWFrZUJvcmRlcnModGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWpRdWVyeVNHKCcuc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWQnLCB0aGlzKS5nZXQoMCkpIHtcbiAgICAgICAgICAgIGlmIChnYWRnZXQuc2VsZWN0YWJsZShzZWxmKSkge1xuICAgICAgICAgICAgICAgIGdhZGdldC5tYWtlQm9yZGVycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuZmlyc3RTZWxlY3RlZE9yU3VnZ2VzdGVkUGFyZW50ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgb3JpZztcbiAgICBvcmlnID0gZWxlbTtcbiAgICBpZiAoalF1ZXJ5U0coZWxlbSkuaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3N1Z2dlc3RlZCcpIHx8IGpRdWVyeVNHKGVsZW0pLmhhc0NsYXNzKCdzZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcpKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cbiAgICB3aGlsZSAoZWxlbS5wYXJlbnROb2RlICYmIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSkge1xuICAgICAgICBpZiAoalF1ZXJ5U0cuaW5BcnJheShlbGVtLCB0aGlzLnJlc3RyaWN0ZWRfZWxlbWVudHMpID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeVNHKGVsZW0pLmhhc0NsYXNzKCdzZWxlY3RvcmdhZGdldF9zdWdnZXN0ZWQnKSB8fCBqUXVlcnlTRyhlbGVtKS5oYXNDbGFzcygnc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNnTW91c2VvdXQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBlbGVtLCBnYWRnZXQ7XG4gICAgZ2FkZ2V0ID0gZS5kYXRhLnNlbGY7XG4gICAgaWYgKGdhZGdldC51bmJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcyA9PT0gZG9jdW1lbnQuYm9keSB8fCB0aGlzID09PSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbGVtID0galF1ZXJ5U0codGhpcyk7XG4gICAgZ2FkZ2V0LnJlbW92ZUJvcmRlcnMoKTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuaGlnaGxpZ2h0SWZyYW1lID0gZnVuY3Rpb24gKGVsZW0sIGNsaWNrKSB7XG4gICAgdmFyIGJsb2NrLCBpbnN0cnVjdGlvbnMsIHAsIHNlbGYsIHNyYywgdGFyZ2V0O1xuICAgIHAgPSBlbGVtLm9mZnNldCgpO1xuICAgIHNlbGYgPSB0aGlzO1xuICAgIHRhcmdldCA9IGpRdWVyeVNHKGNsaWNrLnRhcmdldCk7XG4gICAgYmxvY2sgPSBqUXVlcnlTRygnPGRpdj4nKS5jc3MoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJykuY3NzKCd6LWluZGV4JywgJzk5OTk4JykuY3NzKCd3aWR0aCcsIHRoaXMucHgoZWxlbS5vdXRlcldpZHRoKCkpKS5jc3MoJ2hlaWdodCcsIHRoaXMucHgoZWxlbS5vdXRlckhlaWdodCgpKSkuY3NzKCd0b3AnLCB0aGlzLnB4KHAudG9wKSkuY3NzKCdsZWZ0JywgdGhpcy5weChwLmxlZnQpKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCAnI0FBQScpLmNzcygnb3BhY2l0eScsICcwLjYnKS5hZGRDbGFzcyhcInNlbGVjdG9yZ2FkZ2V0X2lmcmFtZVwiKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfY2xlYW4nKTtcbiAgICBpbnN0cnVjdGlvbnMgPSBqUXVlcnlTRyhcIjxkaXY+PHNwYW4+VGhpcyBpcyBhbiBpZnJhbWUuICBUbyBzZWxlY3QgaW4gaXQsIDwvc3Bhbj48L2Rpdj5cIikuYWRkQ2xhc3MoXCJzZWxlY3RvcmdhZGdldF9pZnJhbWVfaW5mb1wiKS5hZGRDbGFzcyhcInNlbGVjdG9yZ2FkZ2V0X2lmcmFtZVwiKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfY2xlYW4nKTtcbiAgICBpbnN0cnVjdGlvbnMuY3NzKHtcbiAgICAgICAgd2lkdGg6IFwiMjAwcHhcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjODg4XCJcbiAgICB9LCB7XG4gICAgICAgIHBhZGRpbmc6IFwiNXB4XCIsXG4gICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIFwiei1pbmRleFwiOiBcIjk5OTk5XCIsXG4gICAgICAgIHRvcDogdGhpcy5weChwLnRvcCArIChlbGVtLm91dGVySGVpZ2h0KCkgLyA0LjApKSxcbiAgICAgICAgbGVmdDogdGhpcy5weChwLmxlZnQgKyAoZWxlbS5vdXRlcldpZHRoKCkgLSAyMDApIC8gMi4wKSxcbiAgICAgICAgaGVpZ2h0OiBcIjE1MHB4XCJcbiAgICB9KTtcbiAgICBzcmMgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHNyYyA9IGVsZW0uY29udGVudHMoKS5nZXQoMCkubG9jYXRpb24uaHJlZjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNyYyA9IGVsZW0uYXR0cihcInNyY1wiKTtcbiAgICB9XG4gICAgaW5zdHJ1Y3Rpb25zLmFwcGVuZChqUXVlcnlTRyhcIjxhIHRhcmdldD0nX3RvcCc+Y2xpY2sgaGVyZSB0byBvcGVuIGl0PC9hPlwiKS5hdHRyKFwiaHJlZlwiLCBzcmMpKTtcbiAgICBpbnN0cnVjdGlvbnMuYXBwZW5kKGpRdWVyeVNHKFwiPHNwYW4+LCB0aGVuIHJlbGF1bmNoIFNlbGVjdG9yR2FkZ2V0Ljwvc3Bhbj5cIikpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5zdHJ1Y3Rpb25zLmdldCgwKSk7XG4gICAgYmxvY2suY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5zZWxlY3RhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQubW91c2Vkb3duKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChibG9jay5nZXQoMCkpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnVuaGlnaGxpZ2h0SWZyYW1lcyA9IGZ1bmN0aW9uIChlbGVtLCBjbGljaykge1xuICAgIHJldHVybiBqUXVlcnlTRyhcIi5zZWxlY3RvcmdhZGdldF9pZnJhbWVcIikucmVtb3ZlKCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2dNb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBlbGVtLCBnYWRnZXQsIHBvdGVudGlhbF9lbGVtLCBwcmVkaWN0aW9uLCB3X2VsZW07XG4gICAgZ2FkZ2V0ID0gZS5kYXRhLnNlbGY7XG4gICAgaWYgKGdhZGdldC51bmJvdW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbGVtID0gdGhpcztcbiAgICB3X2VsZW0gPSBqUXVlcnlTRyhlbGVtKTtcbiAgICBpZiAod19lbGVtLmhhc0NsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXInKSkge1xuICAgICAgICBlbGVtID0gZWxlbS50YXJnZXRfZWxlbSB8fCBlbGVtO1xuICAgICAgICB3X2VsZW0gPSBqUXVlcnlTRyhlbGVtKTtcbiAgICB9XG4gICAgaWYgKGVsZW0gPT09IGRvY3VtZW50LmJvZHkgfHwgZWxlbSA9PT0gZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGdhZGdldC5zcGVjaWFsX21vZGUgIT09ICdkJykge1xuICAgICAgICBwb3RlbnRpYWxfZWxlbSA9IGdhZGdldC5maXJzdFNlbGVjdGVkT3JTdWdnZXN0ZWRQYXJlbnQoZWxlbSk7XG4gICAgICAgIGlmIChwb3RlbnRpYWxfZWxlbSAhPT0gbnVsbCAmJiBwb3RlbnRpYWxfZWxlbSAhPT0gZWxlbSkge1xuICAgICAgICAgICAgZWxlbSA9IHBvdGVudGlhbF9lbGVtO1xuICAgICAgICAgICAgd19lbGVtID0galF1ZXJ5U0coZWxlbSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoalF1ZXJ5U0coJy5zZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcsIHRoaXMpLmdldCgwKSkge1xuICAgICAgICAgICAgZ2FkZ2V0LmJsb2NrQ2xpY2tzT24oZWxlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFnYWRnZXQuc2VsZWN0YWJsZSh3X2VsZW0pKSB7XG4gICAgICAgIGdhZGdldC5yZW1vdmVCb3JkZXJzKCk7XG4gICAgICAgIGdhZGdldC5ibG9ja0NsaWNrc09uKGVsZW0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh3X2VsZW0uaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkJykpIHtcbiAgICAgICAgd19lbGVtLnJlbW92ZUNsYXNzKCdzZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcpO1xuICAgICAgICBnYWRnZXQuc2VsZWN0ZWQuc3BsaWNlKGpRdWVyeVNHLmluQXJyYXkoZWxlbSwgZ2FkZ2V0LnNlbGVjdGVkKSwgMSk7XG4gICAgfSBlbHNlIGlmICh3X2VsZW0uaGFzQ2xhc3MoXCJzZWxlY3RvcmdhZGdldF9yZWplY3RlZFwiKSkge1xuICAgICAgICB3X2VsZW0ucmVtb3ZlQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3JlamVjdGVkJyk7XG4gICAgICAgIGdhZGdldC5yZWplY3RlZC5zcGxpY2UoalF1ZXJ5U0cuaW5BcnJheShlbGVtLCBnYWRnZXQucmVqZWN0ZWQpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHdfZWxlbS5oYXNDbGFzcyhcInNlbGVjdG9yZ2FkZ2V0X3N1Z2dlc3RlZFwiKSkge1xuICAgICAgICB3X2VsZW0uYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3JlamVjdGVkJyk7XG4gICAgICAgIGdhZGdldC5yZWplY3RlZC5wdXNoKGVsZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdfZWxlbS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWQnKTtcbiAgICAgICAgZ2FkZ2V0LnNlbGVjdGVkLnB1c2goZWxlbSk7XG4gICAgfVxuICAgIGdhZGdldC5jbGVhclN1Z2dlc3RlZCgpO1xuICAgIHByZWRpY3Rpb24gPSBnYWRnZXQucHJlZGljdGlvbl9oZWxwZXIucHJlZGljdENzcyhqUXVlcnlTRyhnYWRnZXQuc2VsZWN0ZWQpLCBqUXVlcnlTRyhnYWRnZXQucmVqZWN0ZWQuY29uY2F0KGdhZGdldC5yZXN0cmljdGVkX2VsZW1lbnRzKSkpO1xuICAgIGdhZGdldC5zdWdnZXN0UHJlZGljdGVkKHByZWRpY3Rpb24pO1xuICAgIGdhZGdldC5zZXRQYXRoKHByZWRpY3Rpb24pO1xuICAgIGdhZGdldC5yZW1vdmVCb3JkZXJzKCk7XG4gICAgZ2FkZ2V0LmJsb2NrQ2xpY2tzT24oZWxlbSk7XG4gICAgd19lbGVtLnRyaWdnZXIoXCJtb3VzZW92ZXIuc2dcIiwge1xuICAgICAgICAnc2VsZic6IGdhZGdldFxuICAgIH0pO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zZXR1cEV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgalF1ZXJ5U0coXCIqOm5vdCguc2VsZWN0b3JnYWRnZXRfaWdub3JlKVwiKS5iaW5kKFwibW91c2VvdmVyLnNnXCIsIHtcbiAgICAgICAgJ3NlbGYnOiB0aGlzXG4gICAgfSwgdGhpcy5zZ01vdXNlb3Zlcik7XG4gICAgalF1ZXJ5U0coXCIqOm5vdCguc2VsZWN0b3JnYWRnZXRfaWdub3JlKVwiKS5iaW5kKFwibW91c2VvdXQuc2dcIiwge1xuICAgICAgICAnc2VsZic6IHRoaXNcbiAgICB9LCB0aGlzLnNnTW91c2VvdXQpO1xuICAgIGpRdWVyeVNHKFwiKjpub3QoLnNlbGVjdG9yZ2FkZ2V0X2lnbm9yZSlcIikuYmluZChcIm1vdXNlZG93bi5zZ1wiLCB7XG4gICAgICAgICdzZWxmJzogdGhpc1xuICAgIH0sIHRoaXMuc2dNb3VzZWRvd24pO1xuICAgIGpRdWVyeVNHKFwiaHRtbFwiKS5iaW5kKFwia2V5ZG93bi5zZ1wiLCB7XG4gICAgICAgICdzZWxmJzogdGhpc1xuICAgIH0sIHRoaXMubGlzdGVuRm9yQWN0aW9uS2V5cyk7XG4gICAgcmV0dXJuIGpRdWVyeVNHKFwiaHRtbFwiKS5iaW5kKFwia2V5dXAuc2dcIiwge1xuICAgICAgICAnc2VsZic6IHRoaXNcbiAgICB9LCB0aGlzLmNsZWFyQWN0aW9uS2V5cyk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUubGlzdGVuRm9yQWN0aW9uS2V5cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGdhZGdldDtcbiAgICBnYWRnZXQgPSBlLmRhdGEuc2VsZjtcbiAgICBpZiAoZ2FkZ2V0LnVuYm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChlLmtleUNvZGUgPT09IDE2IHx8IGUua2V5Q29kZSA9PT0gNjgpIHtcbiAgICAgICAgZ2FkZ2V0LnNwZWNpYWxfbW9kZSA9ICdkJztcbiAgICAgICAgcmV0dXJuIGdhZGdldC5yZW1vdmVCb3JkZXJzKCk7XG4gICAgfVxufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmNsZWFyQWN0aW9uS2V5cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGdhZGdldDtcbiAgICBnYWRnZXQgPSBlLmRhdGEuc2VsZjtcbiAgICBpZiAoZ2FkZ2V0LnVuYm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdhZGdldC5yZW1vdmVCb3JkZXJzKCk7XG4gICAgcmV0dXJuIGdhZGdldC5zcGVjaWFsX21vZGUgPSBudWxsO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmJsb2NrQ2xpY2tzT24gPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBibG9jaywgcDtcbiAgICBlbGVtID0galF1ZXJ5U0coZWxlbSk7XG4gICAgcCA9IGVsZW0ub2Zmc2V0KCk7XG4gICAgYmxvY2sgPSBqUXVlcnlTRygnPGRpdj4nKS5jc3MoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJykuY3NzKCd6LWluZGV4JywgJzk5OTk5OTknKS5jc3MoJ3dpZHRoJywgdGhpcy5weChlbGVtLm91dGVyV2lkdGgoKSkpLmNzcygnaGVpZ2h0JywgdGhpcy5weChlbGVtLm91dGVySGVpZ2h0KCkpKS5jc3MoJ3RvcCcsIHRoaXMucHgocC50b3ApKS5jc3MoJ2xlZnQnLCB0aGlzLnB4KHAubGVmdCkpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsICcnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJsb2NrLmdldCgwKSk7XG4gICAgc2V0VGltZW91dCgoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmxvY2sucmVtb3ZlKCk7XG4gICAgfSksIDQwMCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNldE1vZGUgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIGlmIChtb2RlID09PSAnYnJvd3NlJykge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50SGFuZGxlcnMoKTtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbnRlcmFjdGl2ZScpIHtcbiAgICAgICAgdGhpcy5zZXR1cEV2ZW50SGFuZGxlcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xlYXJTZWxlY3RlZCgpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnN1Z2dlc3RQcmVkaWN0ZWQgPSBmdW5jdGlvbiAocHJlZGljdGlvbikge1xuICAgIHZhciBjb3VudDtcbiAgICBpZiAocHJlZGljdGlvbiAmJiBwcmVkaWN0aW9uICE9PSAnJykge1xuICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIGpRdWVyeVNHKHByZWRpY3Rpb24pLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmICghalF1ZXJ5U0codGhpcykuaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkJykgJiYgIWpRdWVyeVNHKHRoaXMpLmhhc0NsYXNzKCdzZWxlY3RvcmdhZGdldF9pZ25vcmUnKSAmJiAhalF1ZXJ5U0codGhpcykuaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3JlamVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5U0codGhpcykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3N1Z2dlc3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuY2xlYXJfYnV0dG9uKSB7XG4gICAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJfYnV0dG9uLmF0dHIoJ3ZhbHVlJywgJ0NsZWFyICgnICsgY291bnQgKyAnKScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9idXR0b24uYXR0cigndmFsdWUnLCAnQ2xlYXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIE1vZGlmeTogZW1pdCBzZXRQYXRoIGV2ZW50XG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uIChwcmVkaWN0aW9uKSB7XG4gICAgbGV0IHBhdGggPSAnJ1xuICAgIGlmIChwcmVkaWN0aW9uICYmIHByZWRpY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoID0gcHJlZGljdGlvblxuICAgIH1cbiAgICB0aGlzLnBhdGhfb3V0cHV0X2ZpZWxkLnZhbHVlID0gcGF0aFxuICAgIHRoaXMuZW1pdHRlciAmJiB0aGlzLmVtaXR0ZXIuZW1pdCgnc2V0UGF0aCcsIHBhdGgpXG4gICAgcmV0dXJuIHBhdGhcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5yZWZyZXNoRnJvbVBhdGggPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBwYXRoLCBzZWxmO1xuICAgIHNlbGYgPSAoZSAmJiBlLmRhdGEgJiYgZS5kYXRhLnNlbGYpIHx8IHRoaXM7XG5cbiAgICAvLyBNb2RpZnk6IHNldCBwYXRoIGZyb20gZVxuICAgIGlmIChlICYmIGUudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLnBhdGhfb3V0cHV0X2ZpZWxkLnZhbHVlID0gZS52YWx1ZVxuICAgIH1cblxuICAgIHBhdGggPSBzZWxmLnBhdGhfb3V0cHV0X2ZpZWxkLnZhbHVlO1xuICAgIHNlbGYuY2xlYXJTZWxlY3RlZCgpO1xuICAgIHNlbGYuc3VnZ2VzdFByZWRpY3RlZChwYXRoKTtcbiAgICByZXR1cm4gc2VsZi5zZXRQYXRoKHBhdGgpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNob3dYUGF0aCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHBhdGgsIHNlbGY7XG4gICAgc2VsZiA9IChlICYmIGUuZGF0YSAmJiBlLmRhdGEuc2VsZikgfHwgdGhpcztcbiAgICBwYXRoID0gc2VsZi5wYXRoX291dHB1dF9maWVsZC52YWx1ZTtcbiAgICBpZiAocGF0aCA9PT0gJ05vIHZhbGlkIHBhdGggZm91bmQuJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBwcm9tcHQoXCJUaGUgQ1NTIHNlbGVjdG9yICdcIiArIHBhdGggKyBcIicgYXMgYW4gWFBhdGggaXMgc2hvd24gYmVsb3cuICBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRoYXQgeW91IGZpbmQgd2l0aCB0aGlzIGNvbnZlcnRlci5cIiwgc2VsZi5wcmVkaWN0aW9uX2hlbHBlci5jc3NUb1hQYXRoKHBhdGgpKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5jbGVhclNlbGVjdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZjtcbiAgICBzZWxmID0gKGUgJiYgZS5kYXRhICYmIGUuZGF0YS5zZWxmKSB8fCB0aGlzO1xuICAgIHNlbGYuc2VsZWN0ZWQgPSBbXTtcbiAgICBzZWxmLnJlamVjdGVkID0gW107XG4gICAgalF1ZXJ5U0coJy5zZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcpO1xuICAgIGpRdWVyeVNHKCcuc2VsZWN0b3JnYWRnZXRfcmVqZWN0ZWQnKS5yZW1vdmVDbGFzcygnc2VsZWN0b3JnYWRnZXRfcmVqZWN0ZWQnKTtcbiAgICBzZWxmLnJlbW92ZUJvcmRlcnMoKTtcbiAgICByZXR1cm4gc2VsZi5jbGVhclN1Z2dlc3RlZCgpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmNsZWFyRXZlcnl0aGluZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGY7XG4gICAgc2VsZiA9IChlICYmIGUuZGF0YSAmJiBlLmRhdGEuc2VsZikgfHwgdGhpcztcbiAgICBzZWxmLmNsZWFyU2VsZWN0ZWQoKTtcbiAgICByZXR1cm4gc2VsZi5yZXNldE91dHB1dHMoKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5yZXNldE91dHB1dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UGF0aCgpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmNsZWFyU3VnZ2VzdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGpRdWVyeVNHKCcuc2VsZWN0b3JnYWRnZXRfc3VnZ2VzdGVkJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3N1Z2dlc3RlZCcpO1xuICAgIGlmICh0aGlzLmNsZWFyX2J1dHRvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9idXR0b24uYXR0cigndmFsdWUnLCAnQ2xlYXInKTtcbiAgICB9XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2hvd0hlbHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsZXJ0KFwiQ2xpY2sgb24gYSBwYWdlIGVsZW1lbnQgdGhhdCB5b3Ugd291bGQgbGlrZSB5b3VyIHNlbGVjdG9yIHRvIG1hdGNoIChpdCB3aWxsIHR1cm4gZ3JlZW4pLiBTZWxlY3RvckdhZGdldCB3aWxsIHRoZW4gZ2VuZXJhdGUgYSBtaW5pbWFsIENTUyBzZWxlY3RvciBmb3IgdGhhdCBlbGVtZW50LCBhbmQgd2lsbCBoaWdobGlnaHQgKHllbGxvdykgZXZlcnl0aGluZyB0aGF0IGlzIG1hdGNoZWQgYnkgdGhlIHNlbGVjdG9yLiBOb3cgY2xpY2sgb24gYSBoaWdobGlnaHRlZCBlbGVtZW50IHRvIHJlamVjdCBpdCAocmVkKSwgb3IgY2xpY2sgb24gYW4gdW5oaWdobGlnaHRlZCBlbGVtZW50IHRvIGFkZCBpdCAoZ3JlZW4pLiBUaHJvdWdoIHRoaXMgcHJvY2VzcyBvZiBzZWxlY3Rpb24gYW5kIHJlamVjdGlvbiwgU2VsZWN0b3JHYWRnZXQgaGVscHMgeW91IHRvIGNvbWUgdXAgd2l0aCB0aGUgcGVyZmVjdCBDU1Mgc2VsZWN0b3IgZm9yIHlvdXIgbmVlZHMuXFxuXFxuSG9sZGluZyAnc2hpZnQnIHdoaWxlIG1vdmluZyB0aGUgbW91c2Ugd2lsbCBsZXQgeW91IHNlbGVjdCBlbGVtZW50cyBpbnNpZGUgb2Ygb3RoZXIgc2VsZWN0ZWQgZWxlbWVudHMuXCIpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnVzZVJlbW90ZUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LnNnX29wdGlvbnMgJiYgd2luZG93LnNnX29wdGlvbnMucmVtb3RlX2ludGVyZmFjZTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS51cGRhdGVSZW1vdGVJbnRlcmZhY2UgPSBmdW5jdGlvbiAoZGF0YV9vYmopIHtcbiAgICByZXR1cm4gdGhpcy5hZGRTY3JpcHQodGhpcy5jb21wb3NlUmVtb3RlVXJsKHdpbmRvdy5zZ19vcHRpb25zLnJlbW90ZV9pbnRlcmZhY2UsIGRhdGFfb2JqKSk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuY29tcG9zZVJlbW90ZVVybCA9IGZ1bmN0aW9uICh1cmwsIGRhdGFfb2JqKSB7XG4gICAgdmFyIGtleSwgcGFyYW1zO1xuICAgIHBhcmFtcyA9ICh1cmwuc3BsaXQoXCI/XCIpWzFdICYmIHVybC5zcGxpdChcIj9cIilbMV0uc3BsaXQoXCImXCIpKSB8fCBbXTtcbiAgICBwYXJhbXMucHVzaChcInQ9XCIgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgICBwYXJhbXMucHVzaChcInVybD1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZikpO1xuICAgIGlmIChkYXRhX29iaikge1xuICAgICAgICBmb3IgKGtleSBpbiBkYXRhX29iaikge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YV9vYmpba2V5XSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbW90ZV9kYXRhKSB7XG4gICAgICAgIGZvciAoa2V5IGluIHRoaXMucmVtb3RlX2RhdGEpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChcImRhdGFbXCIgKyBrZXkgKyBcIl1cIikgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5yZW1vdGVfZGF0YVtrZXldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybC5zcGxpdChcIj9cIilbMF0gKyBcIj9cIiArIHBhcmFtcy5qb2luKFwiJlwiKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5hZGRTY3JpcHQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgdmFyIGhlYWQsIHM7XG4gICAgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xuICAgIHMuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuICAgIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIGlmIChoZWFkKSB7XG4gICAgICAgIHJldHVybiBoZWFkLmFwcGVuZENoaWxkKHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHMpO1xuICAgIH1cbn07XG5cbi8vIFNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5tYWtlSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuLy8gICAgIHRoaXMuc2dfZGl2ID0galF1ZXJ5U0coJzxkaXY+JykuYXR0cignaWQnLCAnc2VsZWN0b3JnYWRnZXRfbWFpbicpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3R0b20nKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfaWdub3JlJyk7XG4vLyAgICAgaWYgKHRoaXMudXNlUmVtb3RlSW50ZXJmYWNlKCkpIHtcbi8vICAgICAgICAgdGhpcy5wYXRoX291dHB1dF9maWVsZCA9IHtcbi8vICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4vLyAgICAgICAgIH07XG4vLyAgICAgICAgIHRoaXMucmVtb3RlX2RhdGEgPSB7fTtcbi8vICAgICAgICAgdGhpcy51cGRhdGVSZW1vdGVJbnRlcmZhY2UoKTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgICB0aGlzLm1ha2VTdGFuZGFyZEludGVyZmFjZSgpO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4galF1ZXJ5U0coJ2JvZHknKS5hcHBlbmQodGhpcy5zZ19kaXYpO1xuLy8gfTtcblxuLy8gTW9kaWZ5OiBub3RpZnkgcGFyZW50IHRvIHNob3cgaW50ZXJmYWNlXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUubWFrZUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhdGhfb3V0cHV0X2ZpZWxkID0geyB2YWx1ZTogXCJcIiB9XG59XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5tYWtlU3RhbmRhcmRJbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGgsIHNlbGY7XG4gICAgc2VsZiA9IHRoaXM7XG4gICAgcGF0aCA9IGpRdWVyeVNHKCc8aW5wdXQ+JykuYXR0cignaWQnLCAnc2VsZWN0b3JnYWRnZXRfcGF0aF9maWVsZCcpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pZ25vcmUnKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfaW5wdXRfZmllbGQnKS5rZXlkb3duKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yZWZyZXNoRnJvbVBhdGgoZSk7XG4gICAgICAgIH1cbiAgICB9KS5mb2N1cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnlTRyh0aGlzKS5zZWxlY3QoKTtcbiAgICB9KTtcbiAgICB0aGlzLnNnX2Rpdi5hcHBlbmQocGF0aCk7XG4gICAgdGhpcy5jbGVhcl9idXR0b24gPSBqUXVlcnlTRygnPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIkNsZWFyXCIvPicpLmJpbmQoXCJjbGlja1wiLCB7XG4gICAgICAgICdzZWxmJzogdGhpc1xuICAgIH0sIHRoaXMuY2xlYXJFdmVyeXRoaW5nKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfaWdub3JlJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lucHV0X2ZpZWxkJyk7XG4gICAgdGhpcy5zZ19kaXYuYXBwZW5kKHRoaXMuY2xlYXJfYnV0dG9uKTtcbiAgICB0aGlzLnNnX2Rpdi5hcHBlbmQoalF1ZXJ5U0coJzxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJUb2dnbGUgUG9zaXRpb25cIi8+JykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5zZ19kaXYuaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3RvcCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zZ19kaXYucmVtb3ZlQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3RvcCcpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3R0b20nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNnX2Rpdi5yZW1vdmVDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm90dG9tJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3RvcCcpO1xuICAgICAgICB9XG4gICAgfSkuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lnbm9yZScpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pbnB1dF9maWVsZCcpKTtcbiAgICB0aGlzLnNnX2Rpdi5hcHBlbmQoalF1ZXJ5U0coJzxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJYUGF0aFwiLz4nKS5iaW5kKFwiY2xpY2tcIiwge1xuICAgICAgICAnc2VsZic6IHRoaXNcbiAgICB9LCB0aGlzLnNob3dYUGF0aCkuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lnbm9yZScpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pbnB1dF9maWVsZCcpKTtcbiAgICB0aGlzLnNnX2Rpdi5hcHBlbmQoalF1ZXJ5U0coJzxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCI/XCIvPicpLmJpbmQoXCJjbGlja1wiLCB7XG4gICAgICAgICdzZWxmJzogdGhpc1xuICAgIH0sIHRoaXMuc2hvd0hlbHApLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pZ25vcmUnKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfaW5wdXRfZmllbGQnKSk7XG4gICAgdGhpcy5zZ19kaXYuYXBwZW5kKGpRdWVyeVNHKCc8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwiWFwiLz4nKS5iaW5kKFwiY2xpY2tcIiwge1xuICAgICAgICAnc2VsZic6IHRoaXNcbiAgICB9LCB0aGlzLnVuYmluZEFuZFJlbW92ZUludGVyZmFjZSkuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lnbm9yZScpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pbnB1dF9maWVsZCcpKTtcbiAgICByZXR1cm4gdGhpcy5wYXRoX291dHB1dF9maWVsZCA9IHBhdGguZ2V0KDApO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJlbW92ZUludGVyZmFjZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gTW9kaWZ5OiBkbyBub3RoaW5nLCBjYXVzZSBubyBlbGVtZW50IHdhcyBpbnNlcnQgb24gbWFrZUludGVyZmFjZVxuICAgIC8vIHRoaXMuc2dfZGl2LnJlbW92ZSgpO1xuICAgIC8vIHJldHVybiB0aGlzLnNnX2RpdiA9IG51bGw7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZjtcbiAgICBzZWxmID0gKGUgJiYgZS5kYXRhICYmIGUuZGF0YS5zZWxmKSB8fCB0aGlzO1xuICAgIHNlbGYudW5ib3VuZCA9IHRydWU7XG4gICAgc2VsZi5yZW1vdmVCb3JkZXJGcm9tRG9tKCk7XG4gICAgcmV0dXJuIHNlbGYuY2xlYXJTZWxlY3RlZCgpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnVuYmluZEFuZFJlbW92ZUludGVyZmFjZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNlbGY7XG4gICAgc2VsZiA9IChlICYmIGUuZGF0YSAmJiBlLmRhdGEuc2VsZikgfHwgdGhpcztcbiAgICBzZWxmLnVuYmluZCgpO1xuICAgIHJldHVybiBzZWxmLnJlbW92ZUludGVyZmFjZSgpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNldE91dHB1dE1vZGUgPSBmdW5jdGlvbiAoZSwgb3V0cHV0X21vZGUpIHtcbiAgICB2YXIgc2VsZjtcbiAgICBzZWxmID0gKGUgJiYgZS5kYXRhICYmIGUuZGF0YS5zZWxmKSB8fCB0aGlzO1xuICAgIHJldHVybiBzZWxmLm91dHB1dF9tb2RlID0gKGUgJiYgZS5kYXRhICYmIGUuZGF0YS5tb2RlKSB8fCBvdXRwdXRfbW9kZTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5yZWJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51bmJvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5jbGVhckV2ZXJ5dGhpbmcoKTtcbiAgICByZXR1cm4gdGhpcy5zZXR1cEJvcmRlcnMoKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5yZWJpbmRBbmRNYWtlSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubWFrZUludGVyZmFjZSgpO1xuICAgIHJldHVybiB0aGlzLnJlYmluZCgpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJhbmRCZXR3ZWVuID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYikgKyBhO1xufTtcblxuU2VsZWN0b3JHYWRnZXQudG9nZ2xlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAoIXdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQpIHtcbiAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldCA9IG5ldyBTZWxlY3RvckdhZGdldCgpO1xuICAgICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0Lm1ha2VJbnRlcmZhY2UoKTtcbiAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldC5jbGVhckV2ZXJ5dGhpbmcoKTtcbiAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldC5zZXRNb2RlKCdpbnRlcmFjdGl2ZScpO1xuICAgICAgICBpZiAoKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuYW5hbHl0aWNzIDogdm9pZCAwKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQuYW5hbHl0aWNzKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQudW5ib3VuZCkge1xuICAgICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LnJlYmluZEFuZE1ha2VJbnRlcmZhY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LnVuYmluZEFuZFJlbW92ZUludGVyZmFjZSgpO1xuICAgIH1cbiAgICByZXR1cm4galF1ZXJ5U0coJy5zZWxlY3Rvcl9nYWRnZXRfbG9hZGluZycpLnJlbW92ZSgpO1xufTtcblxuLy8gTW9kaWZ5OiBhZGQgU2VsZWN0b3JHYWRnZXQudG9nZ2xlT3BlblxuU2VsZWN0b3JHYWRnZXQudG9nZ2xlT3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKCF3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0KSB7XG4gICAgICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQgPSBuZXcgU2VsZWN0b3JHYWRnZXQoKTtcbiAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldC5tYWtlSW50ZXJmYWNlKCk7XG4gICAgICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQuY2xlYXJFdmVyeXRoaW5nKCk7XG4gICAgICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQuc2V0TW9kZSgnaW50ZXJhY3RpdmUnKTtcbiAgICAgICAgLy8gaWYgKChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmFuYWx5dGljcyA6IHZvaWQgMCkgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LmFuYWx5dGljcygpO1xuICAgICAgICAvLyB9XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LnVuYm91bmQpIHtcbiAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldC5yZWJpbmRBbmRNYWtlSW50ZXJmYWNlKCk7XG4gICAgfVxuICAgIGpRdWVyeVNHKCcuc2VsZWN0b3JfZ2FkZ2V0X2xvYWRpbmcnKS5yZW1vdmUoKTtcbiAgICByZXR1cm4gd2luZG93LnNlbGVjdG9yX2dhZGdldFxufVxuXG5TZWxlY3RvckdhZGdldC50b2dnbGVDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0ICYmICF3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LnVuYm91bmQgJiYgd2luZG93LnNlbGVjdG9yX2dhZGdldC51bmJpbmRBbmRSZW1vdmVJbnRlcmZhY2UoKTtcbiAgICByZXR1cm4galF1ZXJ5U0coJy5zZWxlY3Rvcl9nYWRnZXRfbG9hZGluZycpLnJlbW92ZSgpO1xufVxuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuYW5hbHl0aWNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb29raWUsIHJhbmRvbSwgcmVmZXJlciwgdG9kYXksIHVyY2hpblVybCwgdXNlcnZhciwgdXRtYWMsIHV0bWhuLCB1dG1uLCB1dG1wO1xuICAgIHV0bWFjID0gJ1VBLTE0ODk0OC05JztcbiAgICB1dG1obiA9IGVuY29kZVVSSUNvbXBvbmVudCgnd3d3LnNlbGVjdG9yZ2FkZ2V0LmNvbScpO1xuICAgIHV0bW4gPSB0aGlzLnJhbmRCZXR3ZWVuKDEwMDAwMDAwMDAsIDk5OTk5OTk5OTkpO1xuICAgIGNvb2tpZSA9IHRoaXMucmFuZEJldHdlZW4oMTAwMDAwMDAsIDk5OTk5OTk5KTtcbiAgICByYW5kb20gPSB0aGlzLnJhbmRCZXR3ZWVuKDEwMDAwMDAwMDAsIDIxNDc0ODM2NDcpO1xuICAgIHRvZGF5ID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDAuMCk7XG4gICAgcmVmZXJlciA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdXNlcnZhciA9ICctJztcbiAgICB1dG1wID0gJ3NnJztcbiAgICB1cmNoaW5VcmwgPSAnaHR0cDovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9fX3V0bS5naWY/dXRtd3Y9MSZ1dG1uPScgKyB1dG1uICsgJyZ1dG1zcj0tJnV0bXNjPS0mdXRtdWw9LSZ1dG1qZT0wJnV0bWZsPS0mdXRtZHQ9LSZ1dG1obj0nICsgdXRtaG4gKyAnJnV0bXI9JyArIHJlZmVyZXIgKyAnJnV0bXA9JyArIHV0bXAgKyAnJnV0bWFjPScgKyB1dG1hYyArICcmdXRtY2M9X191dG1hJTNEJyArIGNvb2tpZSArICcuJyArIHJhbmRvbSArICcuJyArIHRvZGF5ICsgJy4nICsgdG9kYXkgKyAnLicgKyB0b2RheSArICcuMiUzQiUyQl9fdXRtYiUzRCcgKyBjb29raWUgKyAnJTNCJTJCX191dG1jJTNEJyArIGNvb2tpZSArICclM0IlMkJfX3V0bXolM0QnICsgY29va2llICsgJy4nICsgdG9kYXkgKyAnLjIuMi51dG1jY24lM0QoZGlyZWN0KSU3Q3V0bWNzciUzRChkaXJlY3QpJTdDdXRtY21kJTNEKG5vbmUpJTNCJTJCX191dG12JTNEJyArIGNvb2tpZSArICcuJyArIHVzZXJ2YXIgKyAnJTNCJztcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChqUXVlcnlTRygnPGltZyAvPicpLmF0dHIoJ3NyYycsIHVyY2hpblVybCkuZ2V0KDApKTtcbn07IiwiXG4vKlxuIFRoZSBNSVQgTGljZW5zZVxuIENvcHlyaWdodCAoYykgMjAxMiBBbmRyZXcgQ2FudGlub1xuIENvcHlyaWdodCAoYykgMjAwOSBBbmRyZXcgQ2FudGlubyAmIEt5bGUgTWF4d2VsbFxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiBUSEUgU09GVFdBUkUuXG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gRG9tUHJlZGljdGlvbkhlbHBlcigpIHsgfVxuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5yZWN1cnNpdmVOb2RlcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG47XG4gICAgaWYgKGUubm9kZU5hbWUgJiYgZS5wYXJlbnROb2RlICYmIGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbiA9IHRoaXMucmVjdXJzaXZlTm9kZXMoZS5wYXJlbnROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbmV3IEFycmF5KCk7XG4gICAgfVxuICAgIG4ucHVzaChlKTtcbiAgICByZXR1cm4gbjtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLmVzY2FwZUNzc05hbWVzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxic2VsZWN0b3JnYWRnZXRfXFx3K1xcYi9nLCAnJykucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9bXFwjXFw7XFwmXFwsXFwuXFwrXFwqXFx+XFwnXFw6XFxcIlxcIVxcXlxcJFxcW1xcXVxcKFxcKVxcPVxcPlxcfFxcL10vZywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgZTtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoL1xccysvLCAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS0nKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImV4Y2VwdGlvbiBpbiBlc2NhcGVDc3NOYW1lc1wiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuY2hpbGRFbGVtTnVtYmVyID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgY291bnQ7XG4gICAgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbGVtLnByZXZpb3VzU2libGluZyAmJiAoZWxlbSA9IGVsZW0ucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5zaWJsaW5nc1dpdGhvdXRUZXh0Tm9kZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBmaWx0ZXJlZF9ub2Rlcywgbm9kZSwgbm9kZXMsIF9pLCBfbGVuO1xuICAgIG5vZGVzID0gZS5wYXJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgZmlsdGVyZWRfbm9kZXMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG5vZGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tfaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lLnN1YnN0cmluZygwLCAxKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSBlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJlZF9ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWRfbm9kZXM7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5wYXRoT2YgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBlLCBqLCBwYXRoLCBzaWJsaW5ncywgX2ksIF9sZW4sIF9yZWY7XG4gICAgcGF0aCA9IFwiXCI7XG4gICAgX3JlZiA9IHRoaXMucmVjdXJzaXZlTm9kZXMoZWxlbSk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGUgPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHNpYmxpbmdzID0gdGhpcy5zaWJsaW5nc1dpdGhvdXRUZXh0Tm9kZXMoZSk7XG4gICAgICAgICAgICBpZiAoZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImJvZHlcIikge1xuICAgICAgICAgICAgICAgIGogPSBzaWJsaW5ncy5sZW5ndGggLSAyIDwgMCA/IDAgOiBzaWJsaW5ncy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgc2libGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nc1tqXSA9PT0gZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWJsaW5nc1tqXS5ub2RlTmFtZS5tYXRjaCgvXihzY3JpcHR8Iy4qPykkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRoaXMuY3NzRGVzY3JpcHRvcihzaWJsaW5nc1tqXSkgKyAoaiArIDEgPT09IHNpYmxpbmdzLmxlbmd0aCA/IFwiKyBcIiA6IFwifiBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGggKz0gdGhpcy5jc3NEZXNjcmlwdG9yKGUpICsgXCIgPiBcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbGVhbkNzcyhwYXRoKTtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLmNzc0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBjc3NOYW1lLCBlc2NhcGVkLCBwYXRoLCBfaSwgX2xlbiwgX3JlZjtcbiAgICBwYXRoID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGVzY2FwZWQgPSBub2RlLmlkICYmIHRoaXMuZXNjYXBlQ3NzTmFtZXMobmV3IFN0cmluZyhub2RlLmlkKSk7XG4gICAgaWYgKGVzY2FwZWQgJiYgZXNjYXBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhdGggKz0gJyMnICsgZXNjYXBlZDtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2xhc3NOYW1lKSB7XG4gICAgICAgIF9yZWYgPSBub2RlLmNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgY3NzTmFtZSA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgZXNjYXBlZCA9IHRoaXMuZXNjYXBlQ3NzTmFtZXMoY3NzTmFtZSk7XG4gICAgICAgICAgICBpZiAoY3NzTmFtZSAmJiBlc2NhcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9ICcuJyArIGVzY2FwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJib2R5XCIpIHtcbiAgICAgICAgcGF0aCArPSAnOm50aC1jaGlsZCgnICsgKHRoaXMuY2hpbGRFbGVtTnVtYmVyKG5vZGUpICsgMSkgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuY3NzRGlmZiA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciBjb2xsZWN0aXZlX2NvbW1vbiwgY3NzRWxlbSwgZGlmZiwgZG1wLCBlbmNvZGVkX2Nzc19hcnJheSwgZXhpc3RpbmdfdG9rZW5zLCBwYXJ0LCBfaSwgX2osIF9sZW4sIF9sZW4xO1xuICAgIHRyeSB7XG4gICAgICAgIGRtcCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBcIlBsZWFzZSBpbmNsdWRlIHRoZSBkaWZmX21hdGNoX3BhdGNoIGxpYnJhcnkuXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJyYXkgPT09ICd1bmRlZmluZWQnIHx8IGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGV4aXN0aW5nX3Rva2VucyA9IHt9O1xuICAgIGVuY29kZWRfY3NzX2FycmF5ID0gdGhpcy5lbmNvZGVDc3NGb3JEaWZmKGFycmF5LCBleGlzdGluZ190b2tlbnMpO1xuICAgIGNvbGxlY3RpdmVfY29tbW9uID0gZW5jb2RlZF9jc3NfYXJyYXkucG9wKCk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBlbmNvZGVkX2Nzc19hcnJheS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjc3NFbGVtID0gZW5jb2RlZF9jc3NfYXJyYXlbX2ldO1xuICAgICAgICBkaWZmID0gZG1wLmRpZmZfbWFpbihjb2xsZWN0aXZlX2NvbW1vbiwgY3NzRWxlbSk7XG4gICAgICAgIGNvbGxlY3RpdmVfY29tbW9uID0gJyc7XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGRpZmYubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICBwYXJ0ID0gZGlmZltfal07XG4gICAgICAgICAgICBpZiAocGFydFswXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3RpdmVfY29tbW9uICs9IHBhcnRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlQ3NzKGNvbGxlY3RpdmVfY29tbW9uLCBleGlzdGluZ190b2tlbnMpO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUudG9rZW5pemVDc3MgPSBmdW5jdGlvbiAoY3NzX3N0cmluZykge1xuICAgIHZhciBjaGFyLCBza2lwLCB0b2tlbnMsIHdvcmQsIF9pLCBfbGVuLCBfcmVmO1xuICAgIHNraXAgPSBmYWxzZTtcbiAgICB3b3JkID0gJyc7XG4gICAgdG9rZW5zID0gW107XG4gICAgX3JlZiA9IHRoaXMuY2xlYW5Dc3MoY3NzX3N0cmluZyk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGNoYXIgPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICcuJyB8fCBjaGFyID09PSAnICcgfHwgY2hhciA9PT0gJyMnIHx8IGNoYXIgPT09ICc+JyB8fCBjaGFyID09PSAnOicgfHwgY2hhciA9PT0gJywnIHx8IGNoYXIgPT09ICcrJyB8fCBjaGFyID09PSAnficpIHtcbiAgICAgICAgICAgIGlmICh3b3JkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB3b3JkICs9IGNoYXI7XG4gICAgICAgIGlmIChjaGFyID09PSAnICcgfHwgY2hhciA9PT0gJywnKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh3b3JkKTtcbiAgICAgICAgICAgIHdvcmQgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod29yZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHdvcmQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUudG9rZW5pemVDc3NGb3JEaWZmID0gZnVuY3Rpb24gKGNzc19zdHJpbmcpIHtcbiAgICB2YXIgYmxvY2ssIGNvbWJpbmVkX3Rva2VucywgdG9rZW4sIF9pLCBfbGVuLCBfcmVmO1xuICAgIGNvbWJpbmVkX3Rva2VucyA9IFtdO1xuICAgIGJsb2NrID0gW107XG4gICAgX3JlZiA9IHRoaXMudG9rZW5pemVDc3MoY3NzX3N0cmluZyk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHRva2VuID0gX3JlZltfaV07XG4gICAgICAgIGJsb2NrLnB1c2godG9rZW4pO1xuICAgICAgICBpZiAodG9rZW4gPT09ICcgJyAmJiBibG9jay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb21iaW5lZF90b2tlbnMgPSBjb21iaW5lZF90b2tlbnMuY29uY2F0KGJsb2NrKTtcbiAgICAgICAgICAgIGJsb2NrID0gW107XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcrJyB8fCB0b2tlbiA9PT0gJ34nKSB7XG4gICAgICAgICAgICBibG9jayA9IFtibG9jay5qb2luKCcnKV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkX3Rva2Vucy5jb25jYXQoYmxvY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lZF90b2tlbnM7XG4gICAgfVxufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuZGVjb2RlQ3NzID0gZnVuY3Rpb24gKHN0cmluZywgZXhpc3RpbmdfdG9rZW5zKSB7XG4gICAgdmFyIGNoYXJhY3RlciwgaW52ZXJ0ZWQsIG91dCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgaW52ZXJ0ZWQgPSB0aGlzLmludmVydE9iamVjdChleGlzdGluZ190b2tlbnMpO1xuICAgIG91dCA9ICcnO1xuICAgIF9yZWYgPSBzdHJpbmcuc3BsaXQoJycpO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjaGFyYWN0ZXIgPSBfcmVmW19pXTtcbiAgICAgICAgb3V0ICs9IGludmVydGVkW2NoYXJhY3Rlcl07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsZWFuQ3NzKG91dCk7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5lbmNvZGVDc3NGb3JEaWZmID0gZnVuY3Rpb24gKHN0cmluZ3MsIGV4aXN0aW5nX3Rva2Vucykge1xuICAgIHZhciBjb2RlcG9pbnQsIG91dCwgc3RyaW5nLCBzdHJpbmdzX291dCwgdG9rZW4sIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWY7XG4gICAgY29kZXBvaW50ID0gNTA7XG4gICAgc3RyaW5nc19vdXQgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHN0cmluZ3MubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nc1tfaV07XG4gICAgICAgIG91dCA9IG5ldyBTdHJpbmcoKTtcbiAgICAgICAgX3JlZiA9IHRoaXMudG9rZW5pemVDc3NGb3JEaWZmKHN0cmluZyk7XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IF9yZWZbX2pdO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZ190b2tlbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdfdG9rZW5zW3Rva2VuXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZXBvaW50KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IGV4aXN0aW5nX3Rva2Vuc1t0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nc19vdXQucHVzaChvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nc19vdXQ7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS50b2tlblByaW9yaXRpZXMgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgdmFyIGVwc2lsb24sIGZpcnN0LCBpLCBwcmlvcml0aWVzLCBzZWNvbmQsIHRva2VuLCBfaSwgX2xlbjtcbiAgICBlcHNpbG9uID0gMC4wMDE7XG4gICAgcHJpb3JpdGllcyA9IG5ldyBBcnJheSgpO1xuICAgIGkgPSAwO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdG9rZW5zLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW19pXTtcbiAgICAgICAgZmlyc3QgPSB0b2tlbi5zdWJzdHJpbmcoMCwgMSk7XG4gICAgICAgIHNlY29uZCA9IHRva2VuLnN1YnN0cmluZygxLCAyKTtcbiAgICAgICAgaWYgKGZpcnN0ID09PSAnOicgJiYgc2Vjb25kID09PSAnbicpIHtcbiAgICAgICAgICAgIHByaW9yaXRpZXNbaV0gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSAnPicpIHtcbiAgICAgICAgICAgIHByaW9yaXRpZXNbaV0gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSAnKycgfHwgZmlyc3QgPT09ICd+Jykge1xuICAgICAgICAgICAgcHJpb3JpdGllc1tpXSA9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgIT09ICc6JyAmJiBmaXJzdCAhPT0gJy4nICYmIGZpcnN0ICE9PSAnIycgJiYgZmlyc3QgIT09ICcgJyAmJiBmaXJzdCAhPT0gJz4nICYmIGZpcnN0ICE9PSAnKycgJiYgZmlyc3QgIT09ICd+Jykge1xuICAgICAgICAgICAgcHJpb3JpdGllc1tpXSA9IDQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09ICcuJykge1xuICAgICAgICAgICAgcHJpb3JpdGllc1tpXSA9IDU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgPSAnIycpIHtcbiAgICAgICAgICAgIHByaW9yaXRpZXNbaV0gPSA2O1xuICAgICAgICAgICAgaWYgKHRva2VuLm1hdGNoKC9cXGR7Myx9LykpIHtcbiAgICAgICAgICAgICAgICBwcmlvcml0aWVzW2ldID0gMi41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJpb3JpdGllc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHJpb3JpdGllc1tpXSArPSBpICogZXBzaWxvbjtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcHJpb3JpdGllcztcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLm9yZGVyRnJvbVByaW9yaXRpZXMgPSBmdW5jdGlvbiAocHJpb3JpdGllcykge1xuICAgIHZhciBpLCBvcmRlcmluZywgdG1wLCBfaSwgX2osIF9yZWYsIF9yZWYxO1xuICAgIHRtcCA9IG5ldyBBcnJheSgpO1xuICAgIG9yZGVyaW5nID0gbmV3IEFycmF5KCk7XG4gICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gcHJpb3JpdGllcy5sZW5ndGg7IDAgPD0gX3JlZiA/IF9pIDwgX3JlZiA6IF9pID4gX3JlZjsgaSA9IDAgPD0gX3JlZiA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIHRtcFtpXSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBwcmlvcml0aWVzW2ldLFxuICAgICAgICAgICAgb3JpZ2luYWw6IGlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG1wLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEudmFsdWUgLSBiLnZhbHVlO1xuICAgIH0pO1xuICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZjEgPSBwcmlvcml0aWVzLmxlbmd0aDsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgIG9yZGVyaW5nW2ldID0gdG1wW2ldLm9yaWdpbmFsO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXJpbmc7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5zaW1wbGlmeUNzcyA9IGZ1bmN0aW9uIChjc3MsIHNlbGVjdGVkLCByZWplY3RlZCkge1xuICAgIHZhciBiZXN0X3NvX2ZhciwgZmlyc3QsIGdvdF9zaG9ydGVyLCBpLCBsb29rX2JhY2tfaW5kZXgsIG9yZGVyaW5nLCBwYXJ0LCBwYXJ0cywgcHJpb3JpdGllcywgc2Vjb25kLCBzZWxlY3RvciwgX2ksIF9yZWYsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICBwYXJ0cyA9IHRoaXMudG9rZW5pemVDc3MoY3NzKTtcbiAgICBwcmlvcml0aWVzID0gdGhpcy50b2tlblByaW9yaXRpZXMocGFydHMpO1xuICAgIG9yZGVyaW5nID0gdGhpcy5vcmRlckZyb21Qcmlvcml0aWVzKHByaW9yaXRpZXMpO1xuICAgIHNlbGVjdG9yID0gdGhpcy5jbGVhbkNzcyhjc3MpO1xuICAgIGxvb2tfYmFja19pbmRleCA9IC0xO1xuICAgIGJlc3Rfc29fZmFyID0gXCJcIjtcbiAgICBpZiAodGhpcy5zZWxlY3RvckdldHMoJ2FsbCcsIHNlbGVjdGVkLCBzZWxlY3RvcikgJiYgdGhpcy5zZWxlY3RvckdldHMoJ25vbmUnLCByZWplY3RlZCwgc2VsZWN0b3IpKSB7XG4gICAgICAgIGJlc3Rfc29fZmFyID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIGdvdF9zaG9ydGVyID0gdHJ1ZTtcbiAgICB3aGlsZSAoZ290X3Nob3J0ZXIpIHtcbiAgICAgICAgZ290X3Nob3J0ZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmID0gcGFydHMubGVuZ3RoOyAwIDw9IF9yZWYgPyBfaSA8IF9yZWYgOiBfaSA+IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19pIDogLS1faSkge1xuICAgICAgICAgICAgcGFydCA9IG9yZGVyaW5nW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnRzW3BhcnRdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3QgPSBwYXJ0c1twYXJ0XS5zdWJzdHJpbmcoMCwgMSk7XG4gICAgICAgICAgICBzZWNvbmQgPSBwYXJ0c1twYXJ0XS5zdWJzdHJpbmcoMSwgMik7XG4gICAgICAgICAgICBpZiAoZmlyc3QgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMud291bGRMZWF2ZUZyZWVGbG9hdGluZ050aENoaWxkKHBhcnRzLCBwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMocGFydCwgcGFydHMsIGZpcnN0LCBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2VsZWN0b3JHZXRzKCdhbGwnLCBzZWxlY3RlZCwgc2VsZWN0b3IpICYmIF90aGlzLnNlbGVjdG9yR2V0cygnbm9uZScsIHJlamVjdGVkLCBzZWxlY3RvcikgJiYgKHNlbGVjdG9yLmxlbmd0aCA8IGJlc3Rfc29fZmFyLmxlbmd0aCB8fCBiZXN0X3NvX2Zhci5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3Rfc29fZmFyID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIGdvdF9zaG9ydGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsZWFuQ3NzKGJlc3Rfc29fZmFyKTtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLl9yZW1vdmVFbGVtZW50cyA9IGZ1bmN0aW9uIChwYXJ0LCBwYXJ0cywgZmlyc3RDaGFyLCBjYWxsYmFjaykge1xuICAgIHZhciBqLCBsb29rX2JhY2tfaW5kZXgsIHNlbGVjdG9yLCB0bXAsIF9pLCBfajtcbiAgICBpZiAoZmlyc3RDaGFyID09PSAnKycgfHwgZmlyc3RDaGFyID09PSAnficpIHtcbiAgICAgICAgbG9va19iYWNrX2luZGV4ID0gdGhpcy5wb3NpdGlvbk9mU3BhY2VCZWZvcmVJbmRleE9yTGluZVN0YXJ0KHBhcnQsIHBhcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb29rX2JhY2tfaW5kZXggPSBwYXJ0O1xuICAgIH1cbiAgICB0bXAgPSBwYXJ0cy5zbGljZShsb29rX2JhY2tfaW5kZXgsIHBhcnQgKyAxKTtcbiAgICBmb3IgKGogPSBfaSA9IGxvb2tfYmFja19pbmRleDsgbG9va19iYWNrX2luZGV4IDw9IHBhcnQgPyBfaSA8PSBwYXJ0IDogX2kgPj0gcGFydDsgaiA9IGxvb2tfYmFja19pbmRleCA8PSBwYXJ0ID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgcGFydHNbal0gPSAnJztcbiAgICB9XG4gICAgc2VsZWN0b3IgPSB0aGlzLmNsZWFuQ3NzKHBhcnRzLmpvaW4oJycpKTtcbiAgICBpZiAoc2VsZWN0b3IgPT09ICcnIHx8ICFjYWxsYmFjayhzZWxlY3RvcikpIHtcbiAgICAgICAgZm9yIChqID0gX2ogPSBsb29rX2JhY2tfaW5kZXg7IGxvb2tfYmFja19pbmRleCA8PSBwYXJ0ID8gX2ogPD0gcGFydCA6IF9qID49IHBhcnQ7IGogPSBsb29rX2JhY2tfaW5kZXggPD0gcGFydCA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgICAgICBwYXJ0c1tqXSA9IHRtcFtqIC0gbG9va19iYWNrX2luZGV4XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5wb3NpdGlvbk9mU3BhY2VCZWZvcmVJbmRleE9yTGluZVN0YXJ0ID0gZnVuY3Rpb24gKHBhcnQsIHBhcnRzKSB7XG4gICAgdmFyIGk7XG4gICAgaSA9IHBhcnQ7XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBwYXJ0c1tpXSAhPT0gJyAnKSB7XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIGkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLndvdWxkTGVhdmVGcmVlRmxvYXRpbmdOdGhDaGlsZCA9IGZ1bmN0aW9uIChwYXJ0cywgcGFydCkge1xuICAgIHZhciBpLCBudGhfY2hpbGRfaXNfb25fcmlnaHQsIHNwYWNlX2lzX29uX2xlZnQ7XG4gICAgc3BhY2VfaXNfb25fbGVmdCA9IG50aF9jaGlsZF9pc19vbl9yaWdodCA9IGZhbHNlO1xuICAgIGkgPSBwYXJ0ICsgMTtcbiAgICB3aGlsZSAoaSA8IHBhcnRzLmxlbmd0aCAmJiBwYXJ0c1tpXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoaSA8IHBhcnRzLmxlbmd0aCAmJiBwYXJ0c1tpXS5zdWJzdHJpbmcoMCwgMikgPT09ICc6bicpIHtcbiAgICAgICAgbnRoX2NoaWxkX2lzX29uX3JpZ2h0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaSA9IHBhcnQgLSAxO1xuICAgIHdoaWxlIChpID4gLTEgJiYgcGFydHNbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPCAwIHx8IHBhcnRzW2ldID09PSAnICcpIHtcbiAgICAgICAgc3BhY2VfaXNfb25fbGVmdCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzcGFjZV9pc19vbl9sZWZ0ICYmIG50aF9jaGlsZF9pc19vbl9yaWdodDtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLmNsZWFuQ3NzID0gZnVuY3Rpb24gKGNzcykge1xuICAgIHZhciBjbGVhbmVkX2NzcywgbGFzdF9jbGVhbmVkX2NzcztcbiAgICBjbGVhbmVkX2NzcyA9IGNzcztcbiAgICBsYXN0X2NsZWFuZWRfY3NzID0gbnVsbDtcbiAgICB3aGlsZSAobGFzdF9jbGVhbmVkX2NzcyAhPT0gY2xlYW5lZF9jc3MpIHtcbiAgICAgICAgbGFzdF9jbGVhbmVkX2NzcyA9IGNsZWFuZWRfY3NzO1xuICAgICAgICBjbGVhbmVkX2NzcyA9IGNsZWFuZWRfY3NzLnJlcGxhY2UoLyhefFxccyspKFxcK3xcXH4pLywgJycpLnJlcGxhY2UoLyhcXCt8XFx+KVxccyokLywgJycpLnJlcGxhY2UoLz4vZywgJyA+ICcpLnJlcGxhY2UoL1xccyooPlxccyopKy9nLCAnID4gJykucmVwbGFjZSgvLC9nLCAnICwgJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKS5yZXBsYWNlKC9cXHMqLCQvZywgJycpLnJlcGxhY2UoL15cXHMqLFxccyovZywgJycpLnJlcGxhY2UoL1xccyo+JC9nLCAnJykucmVwbGFjZSgvXj5cXHMqL2csICcnKS5yZXBsYWNlKC9bXFwrXFx+XFw+XVxccyosL2csICcsJykucmVwbGFjZSgvW1xcK1xcfl1cXHMqPi9nLCAnPicpLnJlcGxhY2UoL1xccyooLFxccyopKy9nLCAnICwgJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGVhbmVkX2Nzcztcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLmdldFBhdGhzRm9yID0gZnVuY3Rpb24gKG5vZGVzZXQpIHtcbiAgICB2YXIgbm9kZSwgb3V0LCBfaSwgX2xlbjtcbiAgICBvdXQgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG5vZGVzZXQubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzZXRbX2ldO1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICBvdXQucHVzaCh0aGlzLnBhdGhPZihub2RlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLnByZWRpY3RDc3MgPSBmdW5jdGlvbiAocywgcikge1xuICAgIHZhciBjc3MsIHNlbGVjdGVkLCBzZWxlY3RlZF9wYXRocywgc2ltcGxlc3QsIHVuaW9uLCBfaSwgX2xlbjtcbiAgICBpZiAocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBzZWxlY3RlZF9wYXRocyA9IHRoaXMuZ2V0UGF0aHNGb3Iocyk7XG4gICAgY3NzID0gdGhpcy5jc3NEaWZmKHNlbGVjdGVkX3BhdGhzKTtcbiAgICBzaW1wbGVzdCA9IHRoaXMuc2ltcGxpZnlDc3MoY3NzLCBzLCByKTtcbiAgICBpZiAoc2ltcGxlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc2ltcGxlc3Q7XG4gICAgfVxuICAgIHVuaW9uID0gJyc7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHNlbGVjdGVkID0gc1tfaV07XG4gICAgICAgIHVuaW9uID0gdGhpcy5wYXRoT2Yoc2VsZWN0ZWQpICsgXCIsIFwiICsgdW5pb247XG4gICAgfVxuICAgIHVuaW9uID0gdGhpcy5jbGVhbkNzcyh1bmlvbik7XG4gICAgcmV0dXJuIHRoaXMuc2ltcGxpZnlDc3ModW5pb24sIHMsIHIpO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuc2VsZWN0b3JHZXRzID0gZnVuY3Rpb24gKHR5cGUsIGxpc3QsIHRoZV9zZWxlY3Rvcikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCAmJiB0eXBlID09PSAnYWxsJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCAmJiB0eXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnYWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3Qubm90KHRoZV9zZWxlY3RvcikubGVuZ3RoID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICEobGlzdC5pcyh0aGVfc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIG9uIHNlbGVjdG9yOiBcIiArIHRoZV9zZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5pbnZlcnRPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleSwgbmV3X29iamVjdCwgdmFsdWU7XG4gICAgbmV3X29iamVjdCA9IHt9O1xuICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBuZXdfb2JqZWN0W3ZhbHVlXSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld19vYmplY3Q7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5jc3NUb1hQYXRoID0gZnVuY3Rpb24gKGNzc19zdHJpbmcpIHtcbiAgICB2YXIgY3NzX2Jsb2NrLCBvdXQsIHRva2VuLCB0b2tlbnMsIF9pLCBfbGVuO1xuICAgIHRva2VucyA9IHRoaXMudG9rZW5pemVDc3MoY3NzX3N0cmluZyk7XG4gICAgaWYgKHRva2Vuc1swXSAmJiB0b2tlbnNbMF0gPT09ICcgJykge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKDAsIDEpO1xuICAgIH1cbiAgICBpZiAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZSh0b2tlbnMubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICAgIGNzc19ibG9jayA9IFtdO1xuICAgIG91dCA9IFwiXCI7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0b2tlbnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbX2ldO1xuICAgICAgICBpZiAodG9rZW4gPT09ICcgJykge1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuY3NzVG9YUGF0aEJsb2NrSGVscGVyKGNzc19ibG9jayk7XG4gICAgICAgICAgICBjc3NfYmxvY2sgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzc19ibG9jay5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0ICsgdGhpcy5jc3NUb1hQYXRoQmxvY2tIZWxwZXIoY3NzX2Jsb2NrKTtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLmNzc1RvWFBhdGhCbG9ja0hlbHBlciA9IGZ1bmN0aW9uIChjc3NfYmxvY2spIHtcbiAgICB2YXIgY3VycmVudCwgZXhwcmVzc2lvbnMsIGZpcnN0LCBpLCBvdXQsIHJlLCByZXN0LCBfaSwgX2osIF9sZW4sIF9yZWY7XG4gICAgaWYgKGNzc19ibG9jay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcvLyc7XG4gICAgfVxuICAgIG91dCA9ICcvLyc7XG4gICAgZmlyc3QgPSBjc3NfYmxvY2tbMF0uc3Vic3RyaW5nKDAsIDEpO1xuICAgIGlmIChmaXJzdCA9PT0gJywnKSB7XG4gICAgICAgIHJldHVybiBcIiB8IFwiO1xuICAgIH1cbiAgICBpZiAoZmlyc3QgPT09ICc6JyB8fCBmaXJzdCA9PT0gJyMnIHx8IGZpcnN0ID09PSAnLicpIHtcbiAgICAgICAgb3V0ICs9ICcqJztcbiAgICB9XG4gICAgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICByZSA9IG51bGw7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjc3NfYmxvY2subGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgY3VycmVudCA9IGNzc19ibG9ja1tfaV07XG4gICAgICAgIGZpcnN0ID0gY3VycmVudC5zdWJzdHJpbmcoMCwgMSk7XG4gICAgICAgIHJlc3QgPSBjdXJyZW50LnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKGZpcnN0ID09PSAnOicpIHtcbiAgICAgICAgICAgIGlmIChyZSA9IHJlc3QubWF0Y2goL15udGgtY2hpbGRcXCgoXFxkKylcXCkkLykpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcoKChjb3VudChwcmVjZWRpbmctc2libGluZzo6KikgKyAxKSA9ICcgKyByZVsxXSArICcpIGFuZCBwYXJlbnQ6OiopJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09ICcuJykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCgnY29udGFpbnMoY29uY2F0KCBcIiBcIiwgQGNsYXNzLCBcIiBcIiApLCBjb25jYXQoIFwiIFwiLCBcIicgKyByZXN0ICsgJ1wiLCBcIiBcIiApKScpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSAnIycpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goJyhAaWQgPSBcIicgKyByZXN0ICsgJ1wiKScpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSAnLCcpIHtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0ICs9ICdbJztcbiAgICB9XG4gICAgZm9yIChpID0gX2ogPSAwLCBfcmVmID0gZXhwcmVzc2lvbnMubGVuZ3RoOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IGkgPSAwIDw9IF9yZWYgPyArK19qIDogLS1faikge1xuICAgICAgICBvdXQgKz0gZXhwcmVzc2lvbnNbaV07XG4gICAgICAgIGlmIChpIDwgZXhwcmVzc2lvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgYW5kICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0ICs9ICddJztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG4iLCIvKipcbiAqIERpZmYgTWF0Y2ggYW5kIFBhdGNoXG4gKlxuICogQ29weXJpZ2h0IDIwMDYgR29vZ2xlIEluYy5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC9cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0ZXh0cyB0byBjcmVhdGUgYSBwYXRjaC5cbiAqIEFwcGxpZXMgdGhlIHBhdGNoIG9udG8gYW5vdGhlciB0ZXh0LCBhbGxvd2luZyBmb3IgZXJyb3JzLlxuICogQGF1dGhvciBmcmFzZXJAZ29vZ2xlLmNvbSAoTmVpbCBGcmFzZXIpXG4gKi9cblxuLyoqXG4gKiBDbGFzcyBjb250YWluaW5nIHRoZSBkaWZmLCBtYXRjaCBhbmQgcGF0Y2ggbWV0aG9kcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBkaWZmX21hdGNoX3BhdGNoKCkge1xuXG4gIC8vIERlZmF1bHRzLlxuICAvLyBSZWRlZmluZSB0aGVzZSBpbiB5b3VyIHByb2dyYW0gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuXG4gIC8vIE51bWJlciBvZiBzZWNvbmRzIHRvIG1hcCBhIGRpZmYgYmVmb3JlIGdpdmluZyB1cC4gICgwIGZvciBpbmZpbml0eSlcbiAgdGhpcy5EaWZmX1RpbWVvdXQgPSAxLjA7XG4gIC8vIENvc3Qgb2YgYW4gZW1wdHkgZWRpdCBvcGVyYXRpb24gaW4gdGVybXMgb2YgZWRpdCBjaGFyYWN0ZXJzLlxuICB0aGlzLkRpZmZfRWRpdENvc3QgPSA0O1xuICAvLyBUaGUgc2l6ZSBiZXlvbmQgd2hpY2ggdGhlIGRvdWJsZS1lbmRlZCBkaWZmIGFjdGl2YXRlcy5cbiAgLy8gRG91YmxlLWVuZGluZyBpcyB0d2ljZSBhcyBmYXN0LCBidXQgbGVzcyBhY2N1cmF0ZS5cbiAgdGhpcy5EaWZmX0R1YWxUaHJlc2hvbGQgPSAzMjtcbiAgLy8gVHdlYWsgdGhlIHJlbGF0aXZlIGltcG9ydGFuY2UgKDAuMCA9IGFjY3VyYWN5LCAxLjAgPSBwcm94aW1pdHkpXG4gIHRoaXMuTWF0Y2hfQmFsYW5jZSA9IDAuNTtcbiAgLy8gQXQgd2hhdCBwb2ludCBpcyBubyBtYXRjaCBkZWNsYXJlZCAoMC4wID0gcGVyZmVjdGlvbiwgMS4wID0gdmVyeSBsb29zZSlcbiAgdGhpcy5NYXRjaF9UaHJlc2hvbGQgPSAwLjU7XG4gIC8vIFRoZSBtaW4gYW5kIG1heCBjdXRvZmZzIHVzZWQgd2hlbiBjb21wdXRpbmcgdGV4dCBsZW5ndGhzLlxuICB0aGlzLk1hdGNoX01pbkxlbmd0aCA9IDEwMDtcbiAgdGhpcy5NYXRjaF9NYXhMZW5ndGggPSAxMDAwO1xuICAvLyBDaHVuayBzaXplIGZvciBjb250ZXh0IGxlbmd0aC5cbiAgdGhpcy5QYXRjaF9NYXJnaW4gPSA0O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBudW1iZXIgb2YgYml0cyBpbiBhbiBpbnQuXG4gICAqIFRoZSBub3JtYWwgYW5zd2VyIGZvciBKYXZhU2NyaXB0IGlzIDMyLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBiaXRzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRNYXhCaXRzKCkge1xuICAgIHZhciBtYXhiaXRzID0gMDtcbiAgICB2YXIgb2xkaSA9IDE7XG4gICAgdmFyIG5ld2kgPSAyO1xuICAgIHdoaWxlIChvbGRpICE9IG5ld2kpIHtcbiAgICAgIG1heGJpdHMrKztcbiAgICAgIG9sZGkgPSBuZXdpO1xuICAgICAgbmV3aSA9IG5ld2kgPDwgMTtcbiAgICB9XG4gICAgcmV0dXJuIG1heGJpdHM7XG4gIH1cbiAgLy8gSG93IG1hbnkgYml0cyBpbiBhIG51bWJlcj9cbiAgdGhpcy5NYXRjaF9NYXhCaXRzID0gZ2V0TWF4Qml0cygpO1xufVxuXG5cbi8vICBESUZGIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIGRpZmYgaXMgYW4gYXJyYXkgb2YgdHVwbGVzOlxuICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXG4gKiB3aGljaCBtZWFuczogZGVsZXRlICdIZWxsbycsIGFkZCAnR29vZGJ5ZScgYW5kIGtlZXAgJyB3b3JsZC4nXG4gKi9cbnZhciBESUZGX0RFTEVURSA9IC0xO1xudmFyIERJRkZfSU5TRVJUID0gMTtcbnZhciBESUZGX0VRVUFMID0gMDtcblxuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgU2ltcGxpZmllcyB0aGUgcHJvYmxlbSBieSBzdHJpcHBpbmdcbiAqIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeCBvZmYgdGhlIHRleHRzIGJlZm9yZSBkaWZmaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2NoZWNrbGluZXMgT3B0aW9uYWwgc3BlZWR1cCBmbGFnLiAgSWYgcHJlc2VudCBhbmQgZmFsc2UsXG4gKiAgICAgdGhlbiBkb24ndCBydW4gYSBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXG4gKiAgICAgRGVmYXVsdHMgdG8gdHJ1ZSwgd2hpY2ggZG9lcyBhIGZhc3Rlciwgc2xpZ2h0bHkgbGVzcyBvcHRpbWFsIGRpZmZcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48Kj4+fSBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX21haW4gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyLCBvcHRfY2hlY2tsaW5lcykge1xuICAvLyBDaGVjayBmb3IgZXF1YWxpdHkgKHNwZWVkdXApXG4gIGlmICh0ZXh0MSA9PSB0ZXh0Mikge1xuICAgIHJldHVybiBbW0RJRkZfRVFVQUwsIHRleHQxXV07XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdF9jaGVja2xpbmVzID09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0X2NoZWNrbGluZXMgPSB0cnVlO1xuICB9XG4gIHZhciBjaGVja2xpbmVzID0gb3B0X2NoZWNrbGluZXM7XG5cbiAgLy8gVHJpbSBvZmYgY29tbW9uIHByZWZpeCAoc3BlZWR1cClcbiAgdmFyIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApXG4gIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuXG4gIC8vIENvbXB1dGUgdGhlIGRpZmYgb24gdGhlIG1pZGRsZSBibG9ja1xuICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfY29tcHV0ZSh0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMpO1xuXG4gIC8vIFJlc3RvcmUgdGhlIHByZWZpeCBhbmQgc3VmZml4XG4gIGlmIChjb21tb25wcmVmaXgpIHtcbiAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKTtcbiAgfVxuICBpZiAoY29tbW9uc3VmZml4KSB7XG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSk7XG4gIH1cbiAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIEFzc3VtZXMgdGhhdCB0aGUgdGV4dHMgZG8gbm90XG4gKiBoYXZlIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrbGluZXMgU3BlZWR1cCBmbGFnLiAgSWYgZmFsc2UsIHRoZW4gZG9uJ3QgcnVuIGFcbiAqICAgICBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXG4gKiAgICAgSWYgdHJ1ZSwgdGhlbiBydW4gYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPCo+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tcHV0ZSA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMpIHtcbiAgdmFyIGRpZmZzO1xuXG4gIGlmICghdGV4dDEpIHtcbiAgICAvLyBKdXN0IGFkZCBzb21lIHRleHQgKHNwZWVkdXApXG4gICAgcmV0dXJuIFtbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cblxuICBpZiAoIXRleHQyKSB7XG4gICAgLy8gSnVzdCBkZWxldGUgc29tZSB0ZXh0IChzcGVlZHVwKVxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV1dO1xuICB9XG5cbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIHZhciBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPSAtMSkge1xuICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKVxuICAgIGRpZmZzID0gW1tESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpXSxcbiAgICBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSxcbiAgICBbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXTtcbiAgICAvLyBTd2FwIGluc2VydGlvbnMgZm9yIGRlbGV0aW9ucyBpZiBkaWZmIGlzIHJldmVyc2VkLlxuICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICAgIGRpZmZzWzBdWzBdID0gZGlmZnNbMl1bMF0gPSBESUZGX0RFTEVURTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzO1xuICB9XG4gIGxvbmd0ZXh0ID0gc2hvcnR0ZXh0ID0gbnVsbDsgIC8vIEdhcmJhZ2UgY29sbGVjdFxuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcHJvYmxlbSBjYW4gYmUgc3BsaXQgaW4gdHdvLlxuICB2YXIgaG0gPSB0aGlzLmRpZmZfaGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChobSkge1xuICAgIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHZhciB0ZXh0MV9iID0gaG1bMV07XG4gICAgdmFyIHRleHQyX2EgPSBobVsyXTtcbiAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xuICAgIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gICAgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgZGlmZnNfYSA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EsIGNoZWNrbGluZXMpO1xuICAgIHZhciBkaWZmc19iID0gdGhpcy5kaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYiwgY2hlY2tsaW5lcyk7XG4gICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXG4gICAgcmV0dXJuIGRpZmZzX2EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkX2NvbW1vbl1dLCBkaWZmc19iKTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYSByZWFsIGRpZmYuXG4gIGlmIChjaGVja2xpbmVzICYmICh0ZXh0MS5sZW5ndGggPCAxMDAgfHwgdGV4dDIubGVuZ3RoIDwgMTAwKSkge1xuICAgIC8vIFRvbyB0cml2aWFsIGZvciB0aGUgb3ZlcmhlYWQuXG4gICAgY2hlY2tsaW5lcyA9IGZhbHNlO1xuICB9XG4gIHZhciBsaW5lYXJyYXk7XG4gIGlmIChjaGVja2xpbmVzKSB7XG4gICAgLy8gU2NhbiB0aGUgdGV4dCBvbiBhIGxpbmUtYnktbGluZSBiYXNpcyBmaXJzdC5cbiAgICB2YXIgYSA9IHRoaXMuZGlmZl9saW5lc1RvQ2hhcnModGV4dDEsIHRleHQyKTtcbiAgICB0ZXh0MSA9IGFbMF07XG4gICAgdGV4dDIgPSBhWzFdO1xuICAgIGxpbmVhcnJheSA9IGFbMl07XG4gIH1cbiAgZGlmZnMgPSB0aGlzLmRpZmZfbWFwKHRleHQxLCB0ZXh0Mik7XG4gIGlmICghZGlmZnMpIHtcbiAgICAvLyBObyBhY2NlcHRhYmxlIHJlc3VsdC5cbiAgICBkaWZmcyA9IFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICB9XG4gIGlmIChjaGVja2xpbmVzKSB7XG4gICAgLy8gQ29udmVydCB0aGUgZGlmZiBiYWNrIHRvIG9yaWdpbmFsIHRleHQuXG4gICAgdGhpcy5kaWZmX2NoYXJzVG9MaW5lcyhkaWZmcywgbGluZWFycmF5KTtcbiAgICAvLyBFbGltaW5hdGUgZnJlYWsgbWF0Y2hlcyAoZS5nLiBibGFuayBsaW5lcylcbiAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcblxuICAgIC8vIFJlZGlmZiBhbnkgcmVwbGFjZW1lbnQgYmxvY2tzLCB0aGlzIHRpbWUgY2hhcmFjdGVyLWJ5LWNoYXJhY3Rlci5cbiAgICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsICcnXSk7XG4gICAgdmFyIHBvaW50ZXIgPSAwO1xuICAgIHZhciBjb3VudF9kZWxldGUgPSAwO1xuICAgIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICAgIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgIHZhciB0ZXh0X2luc2VydCA9ICcnO1xuICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgPj0gMSAmJiBjb3VudF9pbnNlcnQgPj0gMSkge1xuICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5kaWZmX21haW4odGV4dF9kZWxldGUsIHRleHRfaW5zZXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0KTtcbiAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGFbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgKyBhLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICAgIHRleHRfZGVsZXRlID0gJyc7XG4gICAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHBvaW50ZXIrKztcbiAgICB9XG4gICAgZGlmZnMucG9wKCk7ICAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vKipcbiAqIFNwbGl0IHR3byB0ZXh0cyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuICBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXG4gKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmdcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8QXJyYXkuPHN0cmluZz4+fSBUaHJlZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZVxuICogICAgIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZCB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuICBUaGVcbiAqICAgICB6ZXJvdGggZWxlbWVudCBvZiB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MgaXMgaW50ZW50aW9uYWxseSBibGFuay5cbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGluZXNUb0NoYXJzID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICB2YXIgbGluZUFycmF5ID0gW107ICAvLyBlLmcuIGxpbmVBcnJheVs0XSA9PSAnSGVsbG9cXG4nXG4gIHZhciBsaW5lSGFzaCA9IHt9OyAgIC8vIGUuZy4gbGluZUhhc2hbJ0hlbGxvXFxuJ10gPT0gNFxuXG4gIC8vICdcXHgwMCcgaXMgYSB2YWxpZCBjaGFyYWN0ZXIsIGJ1dCB2YXJpb3VzIGRlYnVnZ2VycyBkb24ndCBsaWtlIGl0LlxuICAvLyBTbyB3ZSdsbCBpbnNlcnQgYSBqdW5rIGVudHJ5IHRvIGF2b2lkIGdlbmVyYXRpbmcgYSBudWxsIGNoYXJhY3Rlci5cbiAgbGluZUFycmF5WzBdID0gJyc7XG5cbiAgLyoqXG4gICAqIFNwbGl0IGEgdGV4dCBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuICBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXG4gICAqIGhhc2hlcyB3aGVyZSBlYWNoIFVuaWNvZGUgY2hhcmFjdGVyIHJlcHJlc2VudHMgb25lIGxpbmUuXG4gICAqIE1vZGlmaWVzIGxpbmVhcnJheSBhbmQgbGluZWhhc2ggdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFN0cmluZyB0byBlbmNvZGVcbiAgICogQHJldHVybiB7c3RyaW5nfSBFbmNvZGVkIHN0cmluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZSh0ZXh0KSB7XG4gICAgdmFyIGNoYXJzID0gJyc7XG4gICAgLy8gV2FsayB0aGUgdGV4dCwgcHVsbGluZyBvdXQgYSBzdWJzdHJpbmcgZm9yIGVhY2ggbGluZS5cbiAgICAvLyB0ZXh0LnNwbGl0KCdcXG4nKSB3b3VsZCB3b3VsZCB0ZW1wb3JhcmlseSBkb3VibGUgb3VyIG1lbW9yeSBmb290cHJpbnQuXG4gICAgLy8gTW9kaWZ5aW5nIHRleHQgd291bGQgY3JlYXRlIG1hbnkgbGFyZ2Ugc3RyaW5ncyB0byBnYXJiYWdlIGNvbGxlY3QuXG4gICAgdmFyIGxpbmVTdGFydCA9IDA7XG4gICAgdmFyIGxpbmVFbmQgPSAtMTtcbiAgICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhcmlhYmxlIGlzIGZhc3RlciB0aGFuIGxvb2tpbmcgaXQgdXAuXG4gICAgdmFyIGxpbmVBcnJheUxlbmd0aCA9IGxpbmVBcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxpbmVFbmQgPCB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoJ1xcbicsIGxpbmVTdGFydCk7XG4gICAgICBpZiAobGluZUVuZCA9PSAtMSkge1xuICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmUgPSB0ZXh0LnN1YnN0cmluZyhsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuXG4gICAgICBpZiAobGluZUhhc2guaGFzT3duUHJvcGVydHkgPyBsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eShsaW5lKSA6XG4gICAgICAgIChsaW5lSGFzaFtsaW5lXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKTtcbiAgICAgICAgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGg7XG4gICAgICAgIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cblxuICB2YXIgY2hhcnMxID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZSh0ZXh0MSk7XG4gIHZhciBjaGFyczIgPSBkaWZmX2xpbmVzVG9DaGFyc011bmdlKHRleHQyKTtcbiAgcmV0dXJuIFtjaGFyczEsIGNoYXJzMiwgbGluZUFycmF5XTtcbn07XG5cblxuLyoqXG4gKiBSZWh5ZHJhdGUgdGhlIHRleHQgaW4gYSBkaWZmIGZyb20gYSBzdHJpbmcgb2YgbGluZSBoYXNoZXMgdG8gcmVhbCBsaW5lcyBvZlxuICogdGV4dC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjwqPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsaW5lQXJyYXkgQXJyYXkgb2YgdW5pcXVlIHN0cmluZ3NcbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2hhcnNUb0xpbmVzID0gZnVuY3Rpb24gKGRpZmZzLCBsaW5lQXJyYXkpIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBjaGFycyA9IGRpZmZzW3hdWzFdO1xuICAgIHZhciB0ZXh0ID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKykge1xuICAgICAgdGV4dFt5XSA9IGxpbmVBcnJheVtjaGFycy5jaGFyQ29kZUF0KHkpXTtcbiAgICB9XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oJycpO1xuICB9XG59O1xuXG5cbi8qKlxuICogRXhwbG9yZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBiZXR3ZWVuIHRoZSB0d28gdGV4dHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZFxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjwqPj4/fSBBcnJheSBvZiBkaWZmIHR1cGxlcyBvciBudWxsIGlmIG5vIGRpZmZcbiAqICAgICBhdmFpbGFibGVcbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbWFwID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICAvLyBEb24ndCBydW4gZm9yIHRvbyBsb25nLlxuICB2YXIgbXNfZW5kID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIHRoaXMuRGlmZl9UaW1lb3V0ICogMTAwMDtcbiAgdmFyIG1heF9kID0gdGV4dDEubGVuZ3RoICsgdGV4dDIubGVuZ3RoIC0gMTtcbiAgdmFyIGRvdWJsZUVuZCA9IHRoaXMuRGlmZl9EdWFsVGhyZXNob2xkICogMiA8IG1heF9kO1xuICB2YXIgdl9tYXAxID0gW107XG4gIHZhciB2X21hcDIgPSBbXTtcbiAgdmFyIHYxID0ge307XG4gIHZhciB2MiA9IHt9O1xuICB2MVsxXSA9IDA7XG4gIHYyWzFdID0gMDtcbiAgdmFyIHgsIHk7XG4gIHZhciBmb290c3RlcDsgIC8vIFVzZWQgdG8gdHJhY2sgb3ZlcmxhcHBpbmcgcGF0aHMuXG4gIHZhciBmb290c3RlcHMgPSB7fTtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgLy8gU2FmYXJpIDEueCBkb2Vzbid0IGhhdmUgaGFzT3duUHJvcGVydHlcbiAgdmFyIGhhc093blByb3BlcnR5ID0gISEoZm9vdHN0ZXBzLmhhc093blByb3BlcnR5KTtcbiAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGlzIG9kZCwgdGhlbiB0aGUgZnJvbnQgcGF0aCB3aWxsIGNvbGxpZGVcbiAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxuICB2YXIgZnJvbnQgPSAodGV4dDEubGVuZ3RoICsgdGV4dDIubGVuZ3RoKSAlIDI7XG4gIGZvciAodmFyIGQgPSAwOyBkIDwgbWF4X2Q7IGQrKykge1xuICAgIC8vIEJhaWwgb3V0IGlmIHRpbWVvdXQgcmVhY2hlZC5cbiAgICBpZiAodGhpcy5EaWZmX1RpbWVvdXQgPiAwICYmIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgPiBtc19lbmQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFdhbGsgdGhlIGZyb250IHBhdGggb25lIHN0ZXAuXG4gICAgdl9tYXAxW2RdID0ge307XG4gICAgZm9yICh2YXIgayA9IC1kOyBrIDw9IGQ7IGsgKz0gMikge1xuICAgICAgaWYgKGsgPT0gLWQgfHwgayAhPSBkICYmIHYxW2sgLSAxXSA8IHYxW2sgKyAxXSkge1xuICAgICAgICB4ID0gdjFbayArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHYxW2sgLSAxXSArIDE7XG4gICAgICB9XG4gICAgICB5ID0geCAtIGs7XG4gICAgICBpZiAoZG91YmxlRW5kKSB7XG4gICAgICAgIGZvb3RzdGVwID0geCArICcsJyArIHk7XG4gICAgICAgIGlmIChmcm9udCAmJiAoaGFzT3duUHJvcGVydHkgPyBmb290c3RlcHMuaGFzT3duUHJvcGVydHkoZm9vdHN0ZXApIDpcbiAgICAgICAgICAoZm9vdHN0ZXBzW2Zvb3RzdGVwXSAhPT0gdW5kZWZpbmVkKSkpIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyb250KSB7XG4gICAgICAgICAgZm9vdHN0ZXBzW2Zvb3RzdGVwXSA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICghZG9uZSAmJiB4IDwgdGV4dDEubGVuZ3RoICYmIHkgPCB0ZXh0Mi5sZW5ndGggJiZcbiAgICAgICAgdGV4dDEuY2hhckF0KHgpID09IHRleHQyLmNoYXJBdCh5KSkge1xuICAgICAgICB4Kys7XG4gICAgICAgIHkrKztcbiAgICAgICAgaWYgKGRvdWJsZUVuZCkge1xuICAgICAgICAgIGZvb3RzdGVwID0geCArICcsJyArIHk7XG4gICAgICAgICAgaWYgKGZyb250ICYmIChoYXNPd25Qcm9wZXJ0eSA/IGZvb3RzdGVwcy5oYXNPd25Qcm9wZXJ0eShmb290c3RlcCkgOlxuICAgICAgICAgICAgKGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkpKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmcm9udCkge1xuICAgICAgICAgICAgZm9vdHN0ZXBzW2Zvb3RzdGVwXSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2MVtrXSA9IHg7XG4gICAgICB2X21hcDFbZF1beCArICcsJyArIHldID0gdHJ1ZTtcbiAgICAgIGlmICh4ID09IHRleHQxLmxlbmd0aCAmJiB5ID09IHRleHQyLmxlbmd0aCkge1xuICAgICAgICAvLyBSZWFjaGVkIHRoZSBlbmQgaW4gc2luZ2xlLXBhdGggbW9kZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlmZl9wYXRoMSh2X21hcDEsIHRleHQxLCB0ZXh0Mik7XG4gICAgICB9IGVsc2UgaWYgKGRvbmUpIHtcbiAgICAgICAgLy8gRnJvbnQgcGF0aCByYW4gb3ZlciByZXZlcnNlIHBhdGguXG4gICAgICAgIHZfbWFwMiA9IHZfbWFwMi5zbGljZSgwLCBmb290c3RlcHNbZm9vdHN0ZXBdICsgMSk7XG4gICAgICAgIHZhciBhID0gdGhpcy5kaWZmX3BhdGgxKHZfbWFwMSwgdGV4dDEuc3Vic3RyaW5nKDAsIHgpLFxuICAgICAgICAgIHRleHQyLnN1YnN0cmluZygwLCB5KSk7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdCh0aGlzLmRpZmZfcGF0aDIodl9tYXAyLCB0ZXh0MS5zdWJzdHJpbmcoeCksXG4gICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHkpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvdWJsZUVuZCkge1xuICAgICAgLy8gV2FsayB0aGUgcmV2ZXJzZSBwYXRoIG9uZSBzdGVwLlxuICAgICAgdl9tYXAyW2RdID0ge307XG4gICAgICBmb3IgKHZhciBrID0gLWQ7IGsgPD0gZDsgayArPSAyKSB7XG4gICAgICAgIGlmIChrID09IC1kIHx8IGsgIT0gZCAmJiB2MltrIC0gMV0gPCB2MltrICsgMV0pIHtcbiAgICAgICAgICB4ID0gdjJbayArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSB2MltrIC0gMV0gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHkgPSB4IC0gaztcbiAgICAgICAgZm9vdHN0ZXAgPSAodGV4dDEubGVuZ3RoIC0geCkgKyAnLCcgKyAodGV4dDIubGVuZ3RoIC0geSk7XG4gICAgICAgIGlmICghZnJvbnQgJiYgKGhhc093blByb3BlcnR5ID8gZm9vdHN0ZXBzLmhhc093blByb3BlcnR5KGZvb3RzdGVwKSA6XG4gICAgICAgICAgKGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkpKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgZm9vdHN0ZXBzW2Zvb3RzdGVwXSA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCFkb25lICYmIHggPCB0ZXh0MS5sZW5ndGggJiYgeSA8IHRleHQyLmxlbmd0aCAmJlxuICAgICAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSkgPT1cbiAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpKSB7XG4gICAgICAgICAgeCsrO1xuICAgICAgICAgIHkrKztcbiAgICAgICAgICBmb290c3RlcCA9ICh0ZXh0MS5sZW5ndGggLSB4KSArICcsJyArICh0ZXh0Mi5sZW5ndGggLSB5KTtcbiAgICAgICAgICBpZiAoIWZyb250ICYmIChoYXNPd25Qcm9wZXJ0eSA/IGZvb3RzdGVwcy5oYXNPd25Qcm9wZXJ0eShmb290c3RlcCkgOlxuICAgICAgICAgICAgKGZvb3RzdGVwc1tmb290c3RlcF0gIT09IHVuZGVmaW5lZCkpKSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdjJba10gPSB4O1xuICAgICAgICB2X21hcDJbZF1beCArICcsJyArIHldID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAvLyBSZXZlcnNlIHBhdGggcmFuIG92ZXIgZnJvbnQgcGF0aC5cbiAgICAgICAgICB2X21hcDEgPSB2X21hcDEuc2xpY2UoMCwgZm9vdHN0ZXBzW2Zvb3RzdGVwXSArIDEpO1xuICAgICAgICAgIHZhciBhID0gdGhpcy5kaWZmX3BhdGgxKHZfbWFwMSwgdGV4dDEuc3Vic3RyaW5nKDAsIHRleHQxLmxlbmd0aCAtIHgpLFxuICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyLmxlbmd0aCAtIHkpKTtcbiAgICAgICAgICByZXR1cm4gYS5jb25jYXQodGhpcy5kaWZmX3BhdGgyKHZfbWFwMixcbiAgICAgICAgICAgIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSB4KSxcbiAgICAgICAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSB5KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE51bWJlciBvZiBkaWZmcyBlcXVhbHMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIG5vIGNvbW1vbmFsaXR5IGF0IGFsbC5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogV29yayBmcm9tIHRoZSBtaWRkbGUgYmFjayB0byB0aGUgc3RhcnQgdG8gZGV0ZXJtaW5lIHRoZSBwYXRoLlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gdl9tYXAgQXJyYXkgb2YgcGF0aHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIGZyYWdtZW50IHRvIGJlIGRpZmZlZFxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjwqPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3BhdGgxID0gZnVuY3Rpb24gKHZfbWFwLCB0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgdmFyIHggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB5ID0gdGV4dDIubGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcj99ICovXG4gIHZhciBsYXN0X29wID0gbnVsbDtcbiAgZm9yICh2YXIgZCA9IHZfbWFwLmxlbmd0aCAtIDI7IGQgPj0gMDsgZC0tKSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGlmICh2X21hcFtkXS5oYXNPd25Qcm9wZXJ0eSA/IHZfbWFwW2RdLmhhc093blByb3BlcnR5KCh4IC0gMSkgKyAnLCcgKyB5KSA6XG4gICAgICAgICh2X21hcFtkXVsoeCAtIDEpICsgJywnICsgeV0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgeC0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICBwYXRoWzBdWzFdID0gdGV4dDEuY2hhckF0KHgpICsgcGF0aFswXVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoW0RJRkZfREVMRVRFLCB0ZXh0MS5jaGFyQXQoeCldKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9ERUxFVEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh2X21hcFtkXS5oYXNPd25Qcm9wZXJ0eSA/XG4gICAgICAgIHZfbWFwW2RdLmhhc093blByb3BlcnR5KHggKyAnLCcgKyAoeSAtIDEpKSA6XG4gICAgICAgICh2X21hcFtkXVt4ICsgJywnICsgKHkgLSAxKV0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRoWzBdWzFdID0gdGV4dDIuY2hhckF0KHkpICsgcGF0aFswXVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoW0RJRkZfSU5TRVJULCB0ZXh0Mi5jaGFyQXQoeSldKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC0tO1xuICAgICAgICB5LS07XG4gICAgICAgIC8vaWYgKHRleHQxLmNoYXJBdCh4KSAhPSB0ZXh0Mi5jaGFyQXQoeSkpIHtcbiAgICAgICAgLy8gIHRocm93IG5ldyBFcnJvcignTm8gZGlhZ29uYWwuICBDYW5cXCd0IGhhcHBlbi4gKGRpZmZfcGF0aDEpJyk7XG4gICAgICAgIC8vfVxuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIHBhdGhbMF1bMV0gPSB0ZXh0MS5jaGFyQXQoeCkgKyBwYXRoWzBdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChbRElGRl9FUVVBTCwgdGV4dDEuY2hhckF0KHgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfRVFVQUw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vKipcbiAqIFdvcmsgZnJvbSB0aGUgbWlkZGxlIGJhY2sgdG8gdGhlIGVuZCB0byBkZXRlcm1pbmUgdGhlIHBhdGguXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSB2X21hcCBBcnJheSBvZiBwYXRocy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIGZyYWdtZW50IHRvIGJlIGRpZmZlZFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgZnJhZ21lbnQgdG8gYmUgZGlmZmVkXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPCo+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfcGF0aDIgPSBmdW5jdGlvbiAodl9tYXAsIHRleHQxLCB0ZXh0Mikge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgcGF0aExlbmd0aCA9IDA7XG4gIHZhciB4ID0gdGV4dDEubGVuZ3RoO1xuICB2YXIgeSA9IHRleHQyLmxlbmd0aDtcbiAgLyoqIEB0eXBlIHtudW1iZXI/fSAqL1xuICB2YXIgbGFzdF9vcCA9IG51bGw7XG4gIGZvciAodmFyIGQgPSB2X21hcC5sZW5ndGggLSAyOyBkID49IDA7IGQtLSkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBpZiAodl9tYXBbZF0uaGFzT3duUHJvcGVydHkgPyB2X21hcFtkXS5oYXNPd25Qcm9wZXJ0eSgoeCAtIDEpICsgJywnICsgeSkgOlxuICAgICAgICAodl9tYXBbZF1bKHggLSAxKSArICcsJyArIHldICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHgtLTtcbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfREVMRVRFKSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoIC0gMV1bMV0gKz0gdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIHggLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGgrK10gPVxuICAgICAgICAgICAgW0RJRkZfREVMRVRFLCB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9ERUxFVEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh2X21hcFtkXS5oYXNPd25Qcm9wZXJ0eSA/XG4gICAgICAgIHZfbWFwW2RdLmhhc093blByb3BlcnR5KHggKyAnLCcgKyAoeSAtIDEpKSA6XG4gICAgICAgICh2X21hcFtkXVt4ICsgJywnICsgKHkgLSAxKV0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICBbRElGRl9JTlNFUlQsIHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSB5IC0gMSldO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0lOU0VSVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LS07XG4gICAgICAgIHktLTtcbiAgICAgICAgLy9pZiAodGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIHggLSAxKSAhPVxuICAgICAgICAvLyAgICB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0geSAtIDEpKSB7XG4gICAgICAgIC8vICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRpYWdvbmFsLiAgQ2FuXFwndCBoYXBwZW4uIChkaWZmX3BhdGgyKScpO1xuICAgICAgICAvL31cbiAgICAgICAgaWYgKGxhc3Rfb3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICBbRElGRl9FUVVBTCwgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIHggLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfRVFVQUw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHByZWZpeCBvZiB0d28gc3RyaW5nc1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxuICogICAgIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25QcmVmaXggPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckNvZGVBdCgwKSAhPT0gdGV4dDIuY2hhckNvZGVBdCgwKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PVxuICAgICAgdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcnN0YXJ0ID0gcG9pbnRlcm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgfVxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gc3VmZml4IG9mIHR3byBzdHJpbmdzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgZWFjaCBzdHJpbmcuXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uU3VmZml4ID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJDb2RlQXQodGV4dDEubGVuZ3RoIC0gMSkgIT09XG4gICAgdGV4dDIuY2hhckNvZGVBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJlbmQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJlbmQpID09XG4gICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERvIHRoZSB0d28gdGV4dHMgc2hhcmUgYSBzdWJzdHJpbmcgd2hpY2ggaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZVxuICogbG9uZ2VyIHRleHQ/XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZ1xuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz4/fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuICogICAgIHRleHQxLCB0aGUgc3VmZml4IG9mIHRleHQxLCB0aGUgcHJlZml4IG9mIHRleHQyLCB0aGUgc3VmZml4IG9mXG4gKiAgICAgdGV4dDIgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfaGFsZk1hdGNoID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDEwIHx8IHNob3J0dGV4dC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG51bGw7ICAvLyBQb2ludGxlc3MuXG4gIH1cbiAgdmFyIGRtcCA9IHRoaXM7ICAvLyAndGhpcycgYmVjb21lcyAnd2luZG93JyBpbiBhIGNsb3N1cmUuXG5cbiAgLyoqXG4gICAqIERvZXMgYSBzdWJzdHJpbmcgb2Ygc2hvcnR0ZXh0IGV4aXN0IHdpdGhpbiBsb25ndGV4dCBzdWNoIHRoYXQgdGhlIHN1YnN0cmluZ1xuICAgKiBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgbG9uZ3RleHQ/XG4gICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIHZhcmlhYmxlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvbmd0ZXh0IExvbmdlciBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0dGV4dCBTaG9ydGVyIHN0cmluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gaSBTdGFydCBpbmRleCBvZiBxdWFydGVyIGxlbmd0aCBzdWJzdHJpbmcgd2l0aGluIGxvbmd0ZXh0XG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+P30gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgKiAgICAgb2Ygc2hvcnR0ZXh0IGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsIGkpIHtcbiAgICAvLyBTdGFydCB3aXRoIGEgMS80IGxlbmd0aCBzdWJzdHJpbmcgYXQgcG9zaXRpb24gaSBhcyBhIHNlZWQuXG4gICAgdmFyIHNlZWQgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSwgaSArIE1hdGguZmxvb3IobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xuICAgIHZhciBqID0gLTE7XG4gICAgdmFyIGJlc3RfY29tbW9uID0gJyc7XG4gICAgdmFyIGJlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLCBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iO1xuICAgIHdoaWxlICgoaiA9IHNob3J0dGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT0gLTEpIHtcbiAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25QcmVmaXgobG9uZ3RleHQuc3Vic3RyaW5nKGkpLFxuICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGopKTtcbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25TdWZmaXgobG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLFxuICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcbiAgICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGgpIHtcbiAgICAgICAgYmVzdF9jb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICtcbiAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGosIGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2EgPSBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYiA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYSA9IHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaiAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2IgPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoID49IGxvbmd0ZXh0Lmxlbmd0aCAvIDIpIHtcbiAgICAgIHJldHVybiBbYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsXG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2IsIGJlc3RfY29tbW9uXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHNlY29uZCBxdWFydGVyIGlzIHRoZSBzZWVkIGZvciBhIGhhbGYtbWF0Y2guXG4gIHZhciBobTEgPSBkaWZmX2hhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCxcbiAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xuICAvLyBDaGVjayBhZ2FpbiBiYXNlZCBvbiB0aGUgdGhpcmQgcXVhcnRlci5cbiAgdmFyIGhtMiA9IGRpZmZfaGFsZk1hdGNoSShsb25ndGV4dCwgc2hvcnR0ZXh0LFxuICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyAyKSk7XG4gIHZhciBobTtcbiAgaWYgKCFobTEgJiYgIWhtMikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKCFobTIpIHtcbiAgICBobSA9IGhtMTtcbiAgfSBlbHNlIGlmICghaG0xKSB7XG4gICAgaG0gPSBobTI7XG4gIH0gZWxzZSB7XG4gICAgLy8gQm90aCBtYXRjaGVkLiAgU2VsZWN0IHRoZSBsb25nZXN0LlxuICAgIGhtID0gaG0xWzRdLmxlbmd0aCA+IGhtMls0XS5sZW5ndGggPyBobTEgOiBobTI7XG4gIH1cblxuICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXG4gIHZhciB0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iO1xuICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHRleHQxX2IgPSBobVsxXTtcbiAgICB0ZXh0Ml9hID0gaG1bMl07XG4gICAgdGV4dDJfYiA9IGhtWzNdO1xuICB9IGVsc2Uge1xuICAgIHRleHQyX2EgPSBobVswXTtcbiAgICB0ZXh0Ml9iID0gaG1bMV07XG4gICAgdGV4dDFfYSA9IGhtWzJdO1xuICAgIHRleHQxX2IgPSBobVszXTtcbiAgfVxuICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICByZXR1cm4gW3RleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2IsIG1pZF9jb21tb25dO1xufTtcblxuXG4vKipcbiAqIFJlZHVjZSB0aGUgbnVtYmVyIG9mIGVkaXRzIGJ5IGVsaW1pbmF0aW5nIHNlbWFudGljYWxseSB0cml2aWFsIGVxdWFsaXRpZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48Kj4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpYyA9IGZ1bmN0aW9uIChkaWZmcykge1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICB2YXIgbGFzdGVxdWFsaXR5ID0gbnVsbDsgIC8vIEFsd2F5cyBlcXVhbCB0byBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgtMV1bMV1cbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvbi5cbiAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIHByaW9yIHRvIHRoZSBlcXVhbGl0eS5cbiAgdmFyIGxlbmd0aF9jaGFuZ2VzMSA9IDA7XG4gIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBhZnRlciB0aGUgZXF1YWxpdHkuXG4gIHZhciBsZW5ndGhfY2hhbmdlczIgPSAwO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0VRVUFMKSB7ICAvLyBlcXVhbGl0eSBmb3VuZFxuICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgIGxlbmd0aF9jaGFuZ2VzMSA9IGxlbmd0aF9jaGFuZ2VzMjtcbiAgICAgIGxlbmd0aF9jaGFuZ2VzMiA9IDA7XG4gICAgICBsYXN0ZXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICB9IGVsc2UgeyAgLy8gYW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uXG4gICAgICBsZW5ndGhfY2hhbmdlczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoO1xuICAgICAgaWYgKGxhc3RlcXVhbGl0eSAhPT0gbnVsbCAmJiAobGFzdGVxdWFsaXR5Lmxlbmd0aCA8PSBsZW5ndGhfY2hhbmdlczEpICYmXG4gICAgICAgIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9IGxlbmd0aF9jaGFuZ2VzMikpIHtcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZFxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXG4gICAgICAgICAgW0RJRkZfREVMRVRFLCBsYXN0ZXF1YWxpdHldKTtcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkgKGl0IG5lZWRzIHRvIGJlIHJlZXZhbHVhdGVkKS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xuICAgICAgICBsZW5ndGhfY2hhbmdlczEgPSAwOyAgLy8gUmVzZXQgdGhlIGNvdW50ZXJzLlxuICAgICAgICBsZW5ndGhfY2hhbmdlczIgPSAwO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbiAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbn07XG5cblxuLyoqXG4gKiBMb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAqIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGFsaWduIHRoZSBlZGl0IHRvIGEgd29yZCBib3VuZGFyeS5cbiAqIGUuZzogVGhlIGM8aW5zPmF0IGM8L2lucz5hbWUuIC0+IFRoZSA8aW5zPmNhdCA8L2lucz5jYW1lLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAvLyBEZWZpbmUgc29tZSByZWdleCBwYXR0ZXJucyBmb3IgbWF0Y2hpbmcgYm91bmRhcmllcy4gXG4gIHZhciBwdW5jdHVhdGlvbiA9IC9bXmEtekEtWjAtOV0vO1xuICB2YXIgd2hpdGVzcGFjZSA9IC9cXHMvO1xuICB2YXIgbGluZWJyZWFrID0gL1tcXHJcXG5dLztcbiAgdmFyIGJsYW5rbGluZUVuZCA9IC9cXG5cXHI/XFxuJC87XG4gIHZhciBibGFua2xpbmVTdGFydCA9IC9eXFxyP1xcblxccj9cXG4vO1xuXG4gIC8qKlxuICAgKiBHaXZlbiB0d28gc3RyaW5ncywgY29tcHV0ZSBhIHNjb3JlIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBpbnRlcm5hbFxuICAgKiBib3VuZGFyeSBmYWxscyBvbiBsb2dpY2FsIGJvdW5kYXJpZXMuXG4gICAqIFNjb3JlcyByYW5nZSBmcm9tIDUgKGJlc3QpIHRvIDAgKHdvcnN0KS5cbiAgICogQ2xvc3VyZSwgbWFrZXMgcmVmZXJlbmNlIHRvIHJlZ2V4IHBhdHRlcm5zIGRlZmluZWQgYWJvdmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbmUgRmlyc3Qgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0d28gU2Vjb25kIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKSB7XG4gICAgICAvLyBFZGdlcyBhcmUgdGhlIGJlc3QuXG4gICAgICByZXR1cm4gNTtcbiAgICB9XG5cbiAgICAvLyBFYWNoIHBvcnQgb2YgdGhpcyBmdW5jdGlvbiBiZWhhdmVzIHNsaWdodGx5IGRpZmZlcmVudGx5IGR1ZSB0b1xuICAgIC8vIHN1YnRsZSBkaWZmZXJlbmNlcyBpbiBlYWNoIGxhbmd1YWdlJ3MgZGVmaW5pdGlvbiBvZiB0aGluZ3MgbGlrZVxuICAgIC8vICd3aGl0ZXNwYWNlJy4gIFNpbmNlIHRoaXMgZnVuY3Rpb24ncyBwdXJwb3NlIGlzIGxhcmdlbHkgY29zbWV0aWMsXG4gICAgLy8gdGhlIGNob2ljZSBoYXMgYmVlbiBtYWRlIHRvIHVzZSBlYWNoIGxhbmd1YWdlJ3MgbmF0aXZlIGZlYXR1cmVzXG4gICAgLy8gcmF0aGVyIHRoYW4gZm9yY2UgdG90YWwgY29uZm9ybWl0eS5cbiAgICB2YXIgc2NvcmUgPSAwO1xuICAgIC8vIE9uZSBwb2ludCBmb3Igbm9uLWFscGhhbnVtZXJpYy5cbiAgICBpZiAob25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSkubWF0Y2gocHVuY3R1YXRpb24pIHx8XG4gICAgICB0d28uY2hhckF0KDApLm1hdGNoKHB1bmN0dWF0aW9uKSkge1xuICAgICAgc2NvcmUrKztcbiAgICAgIC8vIFR3byBwb2ludHMgZm9yIHdoaXRlc3BhY2UuXG4gICAgICBpZiAob25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSkubWF0Y2god2hpdGVzcGFjZSkgfHxcbiAgICAgICAgdHdvLmNoYXJBdCgwKS5tYXRjaCh3aGl0ZXNwYWNlKSkge1xuICAgICAgICBzY29yZSsrO1xuICAgICAgICAvLyBUaHJlZSBwb2ludHMgZm9yIGxpbmUgYnJlYWtzLlxuICAgICAgICBpZiAob25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSkubWF0Y2gobGluZWJyZWFrKSB8fFxuICAgICAgICAgIHR3by5jaGFyQXQoMCkubWF0Y2gobGluZWJyZWFrKSkge1xuICAgICAgICAgIHNjb3JlKys7XG4gICAgICAgICAgLy8gRm91ciBwb2ludHMgZm9yIGJsYW5rIGxpbmVzLlxuICAgICAgICAgIGlmIChvbmUubWF0Y2goYmxhbmtsaW5lRW5kKSB8fCB0d28ubWF0Y2goYmxhbmtsaW5lU3RhcnQpKSB7XG4gICAgICAgICAgICBzY29yZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICB2YXIgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgIHZhciBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XG4gICAgICB2YXIgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgdmFyIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcblxuICAgICAgLy8gRmlyc3QsIHNoaWZ0IHRoZSBlZGl0IGFzIGZhciBsZWZ0IGFzIHBvc3NpYmxlLlxuICAgICAgdmFyIGNvbW1vbk9mZnNldCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcbiAgICAgICAgdmFyIGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWNvbmQsIHN0ZXAgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlciByaWdodCwgbG9va2luZyBmb3IgdGhlIGJlc3QgZml0LlxuICAgICAgdmFyIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICB2YXIgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgdmFyIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICB2YXIgYmVzdFNjb3JlID0gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgd2hpbGUgKGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKTtcbiAgICAgICAgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKTtcbiAgICAgICAgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgdmFyIHNjb3JlID0gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICtcbiAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICAgIC8vIFRoZSA+PSBlbmNvdXJhZ2VzIHRyYWlsaW5nIHJhdGhlciB0aGFuIGxlYWRpbmcgd2hpdGVzcGFjZSBvbiBlZGl0cy5cbiAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSkge1xuICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICAgICAgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSAhPSBiZXN0RXF1YWxpdHkxKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gaW1wcm92ZW1lbnQsIHNhdmUgaXQgYmFjayB0byB0aGUgZGlmZi5cbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQ7XG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkyKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBvcGVyYXRpb25hbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjwqPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cEVmZmljaWVuY3kgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgdmFyIGVxdWFsaXRpZXMgPSBbXTsgIC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXG4gIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgdmFyIGxhc3RlcXVhbGl0eSA9ICcnOyAgLy8gQWx3YXlzIGVxdWFsIHRvIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aC0xXVsxXVxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHByZV9pbnMgPSBmYWxzZTtcbiAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYmVmb3JlIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcHJlX2RlbCA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcG9zdF9pbnMgPSBmYWxzZTtcbiAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwb3N0X2RlbCA9IGZhbHNlO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0VRVUFMKSB7ICAvLyBlcXVhbGl0eSBmb3VuZFxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAmJlxuICAgICAgICAocG9zdF9pbnMgfHwgcG9zdF9kZWwpKSB7XG4gICAgICAgIC8vIENhbmRpZGF0ZSBmb3VuZC5cbiAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgICAgcHJlX2lucyA9IHBvc3RfaW5zO1xuICAgICAgICBwcmVfZGVsID0gcG9zdF9kZWw7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IGEgY2FuZGlkYXRlLCBhbmQgY2FuIG5ldmVyIGJlY29tZSBvbmUuXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSAnJztcbiAgICAgIH1cbiAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSBmYWxzZTtcbiAgICB9IGVsc2UgeyAgLy8gYW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zdF9pbnMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqIEZpdmUgdHlwZXMgdG8gYmUgc3BsaXQ6XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YWTxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxpbnM+QzwvaW5zPlxuICAgICAgICogPGlucz5BPC9kZWw+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxkZWw+QzwvZGVsPlxuICAgICAgICovXG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICYmICgocHJlX2lucyAmJiBwcmVfZGVsICYmIHBvc3RfaW5zICYmIHBvc3RfZGVsKSB8fFxuICAgICAgICAoKGxhc3RlcXVhbGl0eS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgLyAyKSAmJlxuICAgICAgICAgIChwcmVfaW5zICsgcHJlX2RlbCArIHBvc3RfaW5zICsgcG9zdF9kZWwpID09IDMpKSkge1xuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkXG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCxcbiAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xuICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZDtcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gJyc7XG4gICAgICAgIGlmIChwcmVfaW5zICYmIHByZV9kZWwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzIG1hZGUgd2hpY2ggY291bGQgYWZmZWN0IHByZXZpb3VzIGVudHJ5LCBrZWVwIGdvaW5nLlxuICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5O1xuICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cblxuICBpZiAoY2hhbmdlcykge1xuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cbiAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwTWVyZ2UgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTsgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICB2YXIgdGV4dF9kZWxldGUgPSAnJztcbiAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gIHZhciBjb21tb25sZW5ndGg7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICBpZiAoY291bnRfZGVsZXRlICE9PSAwIHx8IGNvdW50X2luc2VydCAhPT0gMCkge1xuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgJiYgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gcHJlZml4aWVzLlxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAoKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQpID4gMCAmJlxuICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgLSAxXVswXSA9PVxuICAgICAgICAgICAgICAgIERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz1cbiAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCxcbiAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSk7XG4gICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gc3VmZml4aWVzLlxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyh0ZXh0X2luc2VydC5sZW5ndGggLVxuICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC1cbiAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLVxuICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERlbGV0ZSB0aGUgb2ZmZW5kaW5nIHJlY29yZHMgYW5kIGFkZCB0aGUgbWVyZ2VkIG9uZXMuXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA9PT0gMCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRfaW5zZXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdLFxuICAgICAgICAgICAgICBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0ICtcbiAgICAgICAgICAgIChjb3VudF9kZWxldGUgPyAxIDogMCkgKyAoY291bnRfaW5zZXJ0ID8gMSA6IDApICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgLy8gTWVyZ2UgdGhpcyBlcXVhbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gJycpIHtcbiAgICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAgLy8gd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gZWxpbWluYXRlIGFuIGVxdWFsaXR5LlxuICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArXG4gICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKTtcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpXG4gICAgICAgID09IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBuZXh0IGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9XG4gICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIGxvYyBpcyBhIGxvY2F0aW9uIGluIHRleHQxLCBjb21wdXRlIGFuZCByZXR1cm4gdGhlIGVxdWl2YWxlbnQgbG9jYXRpb24gaW5cbiAqIHRleHQyLlxuICogZS5nLiAnVGhlIGNhdCcgdnMgJ1RoZSBiaWcgY2F0JywgMS0+MSwgNS0+OFxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb2MgTG9jYXRpb24gd2l0aGluIHRleHQxXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExvY2F0aW9uIHdpdGhpbiB0ZXh0MlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3hJbmRleCA9IGZ1bmN0aW9uIChkaWZmcywgbG9jKSB7XG4gIHZhciBjaGFyczEgPSAwO1xuICB2YXIgY2hhcnMyID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMxID0gMDtcbiAgdmFyIGxhc3RfY2hhcnMyID0gMDtcbiAgdmFyIHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHsgIC8vIEVxdWFsaXR5IG9yIGRlbGV0aW9uLlxuICAgICAgY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkgeyAgLy8gRXF1YWxpdHkgb3IgaW5zZXJ0aW9uLlxuICAgICAgY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGNoYXJzMSA+IGxvYykgeyAgLy8gT3ZlcnNob3QgdGhlIGxvY2F0aW9uLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfY2hhcnMxID0gY2hhcnMxO1xuICAgIGxhc3RfY2hhcnMyID0gY2hhcnMyO1xuICB9XG4gIC8vIFdhcyB0aGUgbG9jYXRpb24gd2FzIGRlbGV0ZWQ/XG4gIGlmIChkaWZmcy5sZW5ndGggIT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XG4gIH1cbiAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hhcmFjdGVyIGxlbmd0aC5cbiAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgZGlmZiBhcnJheSBpbnRvIGEgcHJldHR5IEhUTUwgcmVwb3J0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvblxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3ByZXR0eUh0bWwgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgdmFyIGh0bWwgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIG9wID0gZGlmZnNbeF1bMF07ICAgLy8gT3BlcmF0aW9uIChpbnNlcnQsIGRlbGV0ZSwgZXF1YWwpXG4gICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTsgLy8gVGV4dCBvZiBjaGFuZ2UuXG4gICAgdmFyIHRleHQgPSBkYXRhLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1xcbi9nLCAnJnBhcmE7PEJSPicpO1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGh0bWxbeF0gPSAnPElOUyBTVFlMRT1cImJhY2tncm91bmQ6I0U2RkZFNjtcIiBUSVRMRT1cImk9JyArIGkgKyAnXCI+JyArXG4gICAgICAgICAgdGV4dCArICc8L0lOUz4nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGh0bWxbeF0gPSAnPERFTCBTVFlMRT1cImJhY2tncm91bmQ6I0ZGRTZFNjtcIiBUSVRMRT1cImk9JyArIGkgKyAnXCI+JyArXG4gICAgICAgICAgdGV4dCArICc8L0RFTD4nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaHRtbFt4XSA9ICc8U1BBTiBUSVRMRT1cImk9JyArIGkgKyAnXCI+JyArIHRleHQgKyAnPC9TUEFOPic7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAob3AgIT09IERJRkZfREVMRVRFKSB7XG4gICAgICBpICs9IGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaHRtbC5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNvdXJjZSB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgZGVsZXRpb25zKS5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjwqPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFNvdXJjZSB0ZXh0XG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfdGV4dDEgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgdmFyIHR4dCA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkge1xuICAgICAgdHh0W3hdID0gZGlmZnNbeF1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0eHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgaW5zZXJ0aW9ucykuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48Kj4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHJldHVybiB7c3RyaW5nfSBEZXN0aW5hdGlvbiB0ZXh0XG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfdGV4dDIgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgdmFyIHR4dCA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgdHh0W3hdID0gZGlmZnNbeF1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0eHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ3J1c2ggdGhlIGRpZmYgaW50byBhbiBlbmNvZGVkIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlIG9wZXJhdGlvbnNcbiAqIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLlxuICogRS5nLiA9M1xcdC0yXFx0K2luZyAgLT4gS2VlcCAzIGNoYXJzLCBkZWxldGUgMiBjaGFycywgaW5zZXJ0ICdpbmcnLlxuICogT3BlcmF0aW9ucyBhcmUgdGFiLXNlcGFyYXRlZC4gIEluc2VydGVkIHRleHQgaXMgZXNjYXBlZCB1c2luZyAleHggbm90YXRpb24uXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48Kj4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHJldHVybiB7c3RyaW5nfSBEZWx0YSB0ZXh0XG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfdG9EZWx0YSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICB2YXIgdHh0ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3hdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICB0eHRbeF0gPSAnKycgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIHR4dFt4XSA9ICctJyArIGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIHR4dFt4XSA9ICc9JyArIGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qga25vdyBob3cgdG8gZW5jb2RlIGNoYXIgMC5cbiAgcmV0dXJuIHR4dC5qb2luKCdcXHQnKS5yZXBsYWNlKC9cXDAvZywgJyUwMCcpLnJlcGxhY2UoLyUyMC9nLCAnICcpO1xufTtcblxuXG4vKipcbiAqIEdpdmVuIHRoZSBvcmlnaW5hbCB0ZXh0MSwgYW5kIGFuIGVuY29kZWQgc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGVcbiAqIG9wZXJhdGlvbnMgcmVxdWlyZWQgdG8gdHJhbnNmb3JtIHRleHQxIGludG8gdGV4dDIsIGNvbXB1dGUgdGhlIGZ1bGwgZGlmZi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBTb3VyY2Ugc3RyaW5nIGZvciB0aGUgZGlmZlxuICogQHBhcmFtIHtzdHJpbmd9IGRlbHRhIERlbHRhIHRleHRcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48Kj4+fSBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHRocm93cyB7RXJyb3J9IElmIGludmFsaWQgaW5wdXRcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9mcm9tRGVsdGEgPSBmdW5jdGlvbiAodGV4dDEsIGRlbHRhKSB7XG4gIHZhciBkaWZmcyA9IFtdO1xuICB2YXIgZGlmZnNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBDdXJzb3IgaW4gdGV4dDFcbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBkZWNvZGUgY2hhciAwLlxuICBkZWx0YSA9IGRlbHRhLnJlcGxhY2UoLyUwMC9nLCAnXFwwJyk7XG4gIHZhciB0b2tlbnMgPSBkZWx0YS5zcGxpdCgvXFx0L2cpO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2Vucy5sZW5ndGg7IHgrKykge1xuICAgIC8vIEVhY2ggdG9rZW4gYmVnaW5zIHdpdGggYSBvbmUgY2hhcmFjdGVyIHBhcmFtZXRlciB3aGljaCBzcGVjaWZpZXMgdGhlXG4gICAgLy8gb3BlcmF0aW9uIG9mIHRoaXMgdG9rZW4gKGRlbGV0ZSwgaW5zZXJ0LCBlcXVhbGl0eSkuXG4gICAgdmFyIHBhcmFtID0gdG9rZW5zW3hdLnN1YnN0cmluZygxKTtcbiAgICBzd2l0Y2ggKHRva2Vuc1t4XS5jaGFyQXQoMCkpIHtcbiAgICAgIGNhc2UgJysnOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfSU5TRVJULCBkZWNvZGVVUkkocGFyYW0pXTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAvLyBNYWxmb3JtZWQgVVJJIHNlcXVlbmNlLlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICctJzpcbiAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJz0nOlxuICAgICAgICB2YXIgbiA9IHBhcnNlSW50KHBhcmFtLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihuKSB8fCBuIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlciwgcG9pbnRlciArPSBuKTtcbiAgICAgICAgaWYgKHRva2Vuc1t4XS5jaGFyQXQoMCkgPT0gJz0nKSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9FUVVBTCwgdGV4dF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9ERUxFVEUsIHRleHRdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gQmxhbmsgdG9rZW5zIGFyZSBvayAoZnJvbSBhIHRyYWlsaW5nIFxcdCkuXG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgYW4gZXJyb3IuXG4gICAgICAgIGlmICh0b2tlbnNbeF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlmZiBvcGVyYXRpb24gaW4gZGlmZl9mcm9tRGVsdGE6ICcgK1xuICAgICAgICAgICAgdG9rZW5zW3hdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocG9pbnRlciAhPSB0ZXh0MS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbHRhIGxlbmd0aCAoJyArIHBvaW50ZXIgK1xuICAgICAgJykgZG9lcyBub3QgZXF1YWwgc291cmNlIHRleHQgbGVuZ3RoICgnICsgdGV4dDEubGVuZ3RoICsgJykuJyk7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vLyAgTUFUQ0ggRlVOQ1RJT05TXG5cblxuLyoqXG4gKiBMb2NhdGUgdGhlIGJlc3QgaW5zdGFuY2Ugb2YgJ3BhdHRlcm4nIGluICd0ZXh0JyBuZWFyICdsb2MnLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kXG4gKiBAcmV0dXJuIHtudW1iZXI/fSBCZXN0IG1hdGNoIGluZGV4IG9yIG51bGxcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfbWFpbiA9IGZ1bmN0aW9uICh0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcbiAgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jLCB0ZXh0Lmxlbmd0aCAtIHBhdHRlcm4ubGVuZ3RoKSk7XG4gIGlmICh0ZXh0ID09IHBhdHRlcm4pIHtcbiAgICAvLyBTaG9ydGN1dCAocG90ZW50aWFsbHkgbm90IGd1YXJhbnRlZWQgYnkgdGhlIGFsZ29yaXRobSlcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT0gcGF0dGVybikge1xuICAgIC8vIFBlcmZlY3QgbWF0Y2ggYXQgdGhlIHBlcmZlY3Qgc3BvdCEgIChJbmNsdWRlcyBjYXNlIG9mIG51bGwgcGF0dGVybilcbiAgICByZXR1cm4gbG9jO1xuICB9IGVsc2Uge1xuICAgIC8vIERvIGEgZnV6enkgY29tcGFyZS5cbiAgICByZXR1cm4gdGhpcy5tYXRjaF9iaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xuICB9XG59O1xuXG5cbi8qKlxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJyB1c2luZyB0aGVcbiAqIEJpdGFwIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZFxuICogQHJldHVybiB7bnVtYmVyP30gQmVzdCBtYXRjaCBpbmRleCBvciBudWxsXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9iaXRhcCA9IGZ1bmN0aW9uICh0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXR0ZXJuIHRvbyBsb25nIGZvciB0aGlzIGJyb3dzZXIuJyk7XG4gIH1cblxuICAvLyBJbml0aWFsaXNlIHRoZSBhbHBoYWJldC5cbiAgdmFyIHMgPSB0aGlzLm1hdGNoX2FscGhhYmV0KHBhdHRlcm4pO1xuXG4gIHZhciBzY29yZV90ZXh0X2xlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAvLyBDb2VyY2UgdGhlIHRleHQgbGVuZ3RoIGJldHdlZW4gcmVhc29uYWJsZSBtYXhpbXVtcyBhbmQgbWluaW11bXMuXG4gIHNjb3JlX3RleHRfbGVuZ3RoID0gTWF0aC5tYXgoc2NvcmVfdGV4dF9sZW5ndGgsIHRoaXMuTWF0Y2hfTWluTGVuZ3RoKTtcbiAgc2NvcmVfdGV4dF9sZW5ndGggPSBNYXRoLm1pbihzY29yZV90ZXh0X2xlbmd0aCwgdGhpcy5NYXRjaF9NYXhMZW5ndGgpO1xuXG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNjb3JlIGZvciBhIG1hdGNoIHdpdGggZSBlcnJvcnMgYW5kIHggbG9jYXRpb24uXG4gICAqIEFjY2Vzc2VzIGxvYywgc2NvcmVfdGV4dF9sZW5ndGggYW5kIHBhdHRlcm4gdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlIE51bWJlciBvZiBlcnJvcnMgaW4gbWF0Y2hcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTG9jYXRpb24gb2YgbWF0Y2hcbiAgICogQHJldHVybiB7bnVtYmVyfSBPdmVyYWxsIHNjb3JlIGZvciBtYXRjaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbWF0Y2hfYml0YXBTY29yZShlLCB4KSB7XG4gICAgdmFyIGQgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICByZXR1cm4gKGUgLyBwYXR0ZXJuLmxlbmd0aCAvIGRtcC5NYXRjaF9CYWxhbmNlKSArXG4gICAgICAoZCAvIHNjb3JlX3RleHRfbGVuZ3RoIC8gKDEuMCAtIGRtcC5NYXRjaF9CYWxhbmNlKSk7XG4gIH1cblxuICAvLyBIaWdoZXN0IHNjb3JlIGJleW9uZCB3aGljaCB3ZSBnaXZlIHVwLlxuICB2YXIgc2NvcmVfdGhyZXNob2xkID0gdGhpcy5NYXRjaF9UaHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgdmFyIGJlc3RfbG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gIGlmIChiZXN0X2xvYyAhPSAtMSkge1xuICAgIHNjb3JlX3RocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICB9XG4gIC8vIFdoYXQgYWJvdXQgaW4gdGhlIG90aGVyIGRpcmVjdGlvbj8gKHNwZWVkdXApXG4gIGJlc3RfbG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCk7XG4gIGlmIChiZXN0X2xvYyAhPSAtMSkge1xuICAgIHNjb3JlX3RocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGlzZSB0aGUgYml0IGFycmF5cy5cbiAgdmFyIG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gIGJlc3RfbG9jID0gbnVsbDtcblxuICB2YXIgYmluX21pbiwgYmluX21pZDtcbiAgdmFyIGJpbl9tYXggPSBNYXRoLm1heChsb2MgKyBsb2MsIHRleHQubGVuZ3RoKTtcbiAgdmFyIGxhc3RfcmQ7XG4gIGZvciAodmFyIGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIHZhciByZCA9IEFycmF5KHRleHQubGVuZ3RoKTtcblxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSAnbG9jJyB3ZSBjYW4gc3RyYXkgYXQgdGhpc1xuICAgIC8vIGVycm9yIGxldmVsLlxuICAgIGJpbl9taW4gPSBsb2M7XG4gICAgYmluX21pZCA9IGJpbl9tYXg7XG4gICAgd2hpbGUgKGJpbl9taW4gPCBiaW5fbWlkKSB7XG4gICAgICBpZiAobWF0Y2hfYml0YXBTY29yZShkLCBiaW5fbWlkKSA8IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgICBiaW5fbWluID0gYmluX21pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgICAgfVxuICAgICAgYmluX21pZCA9IE1hdGguZmxvb3IoKGJpbl9tYXggLSBiaW5fbWluKSAvIDIgKyBiaW5fbWluKTtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCwgbG9jIC0gKGJpbl9taWQgLSBsb2MpIC0gMSk7XG4gICAgdmFyIGZpbmlzaCA9IE1hdGgubWluKHRleHQubGVuZ3RoIC0gMSwgcGF0dGVybi5sZW5ndGggKyBiaW5fbWlkKTtcblxuICAgIGlmICh0ZXh0LmNoYXJBdChmaW5pc2gpID09IHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkpIHtcbiAgICAgIHJkW2ZpbmlzaF0gPSAoMSA8PCAoZCArIDEpKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJkW2ZpbmlzaF0gPSAoMSA8PCBkKSAtIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSBmaW5pc2ggLSAxOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgIC8vIFRoZSBhbHBoYWJldCAocykgaXMgYSBzcGFyc2UgaGFzaCwgc28gdGhlIGZvbGxvd2luZyBsaW5lcyBnZW5lcmF0ZVxuICAgICAgLy8gd2FybmluZ3MuXG4gICAgICBpZiAoZCA9PT0gMCkgeyAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2guXG4gICAgICAgIHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIHNbdGV4dC5jaGFyQXQoaildO1xuICAgICAgfSBlbHNlIHsgIC8vIFN1YnNlcXVlbnQgcGFzc2VzOiBmdXp6eSBtYXRjaC5cbiAgICAgICAgcmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgc1t0ZXh0LmNoYXJBdChqKV0gfFxuICAgICAgICAgICgobGFzdF9yZFtqICsgMV0gPDwgMSkgfCAxKSB8ICgobGFzdF9yZFtqXSA8PCAxKSB8IDEpIHxcbiAgICAgICAgICBsYXN0X3JkW2ogKyAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xuICAgICAgICB2YXIgc2NvcmUgPSBtYXRjaF9iaXRhcFNjb3JlKGQsIGopO1xuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXG4gICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXG4gICAgICAgIGlmIChzY29yZSA8PSBzY29yZV90aHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBUb2xkIHlvdSBzby5cbiAgICAgICAgICBzY29yZV90aHJlc2hvbGQgPSBzY29yZTtcbiAgICAgICAgICBiZXN0X2xvYyA9IGo7XG4gICAgICAgICAgaWYgKGogPiBsb2MpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBsb2MsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGxvYy5cbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgbG9jIC0gKGogLSBsb2MpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgbG9jLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBpZiAobWF0Y2hfYml0YXBTY29yZShkICsgMSwgbG9jKSA+IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfcmQgPSByZDtcbiAgfVxuICByZXR1cm4gYmVzdF9sb2M7XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQgZm9yIHRoZSBCaXRhcCBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgdGV4dCB0byBlbmNvZGVcbiAqIEByZXR1cm4ge09iamVjdH0gSGFzaCBvZiBjaGFyYWN0ZXIgbG9jYXRpb25zXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9hbHBoYWJldCA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIHZhciBzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSB8PSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cblxuLy8gIFBBVENIIEZVTkNUSU9OU1xuXG5cbi8qKlxuICogSW5jcmVhc2UgdGhlIGNvbnRleHQgdW50aWwgaXQgaXMgdW5pcXVlLFxuICogYnV0IGRvbid0IGxldCB0aGUgcGF0dGVybiBleHBhbmQgYmV5b25kIE1hdGNoX01heEJpdHMuXG4gKiBAcGFyYW0ge3BhdGNoX29ian0gcGF0Y2ggVGhlIHBhdGNoIHRvIGdyb3dcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFNvdXJjZSB0ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRDb250ZXh0ID0gZnVuY3Rpb24gKHBhdGNoLCB0ZXh0KSB7XG4gIHZhciBwYXR0ZXJuID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyLCBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxKTtcbiAgdmFyIHBhZGRpbmcgPSAwO1xuICB3aGlsZSAodGV4dC5pbmRleE9mKHBhdHRlcm4pICE9IHRleHQubGFzdEluZGV4T2YocGF0dGVybikgJiZcbiAgICBwYXR0ZXJuLmxlbmd0aCA8IHRoaXMuTWF0Y2hfTWF4Qml0cyAtIHRoaXMuUGF0Y2hfTWFyZ2luXG4gICAgLSB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XG4gICAgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsXG4gICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIH1cbiAgLy8gQWRkIG9uZSBjaHVuayBmb3IgZ29vZCBsdWNrLlxuICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xuICAvLyBBZGQgdGhlIHByZWZpeC5cbiAgdmFyIHByZWZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsIHBhdGNoLnN0YXJ0Mik7XG4gIGlmIChwcmVmaXggIT09ICcnKSB7XG4gICAgcGF0Y2guZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgcHJlZml4XSk7XG4gIH1cbiAgLy8gQWRkIHRoZSBzdWZmaXguXG4gIHZhciBzdWZmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxLFxuICAgIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgaWYgKHN1ZmZpeCAhPT0gJycpIHtcbiAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBzdWZmaXhdKTtcbiAgfVxuXG4gIC8vIFJvbGwgYmFjayB0aGUgc3RhcnQgcG9pbnRzLlxuICBwYXRjaC5zdGFydDEgLT0gcHJlZml4Lmxlbmd0aDtcbiAgcGF0Y2guc3RhcnQyIC09IHByZWZpeC5sZW5ndGg7XG4gIC8vIEV4dGVuZCB0aGUgbGVuZ3Rocy5cbiAgcGF0Y2gubGVuZ3RoMSArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcbiAgcGF0Y2gubGVuZ3RoMiArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIGEgbGlzdCBvZiBwYXRjaGVzIHRvIHR1cm4gdGV4dDEgaW50byB0ZXh0Mi5cbiAqIFVzZSBkaWZmcyBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGNvbXB1dGUgaXQgb3Vyc2VsdmVzLlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIGNhbGwgdGhpcyBmdW5jdGlvbjpcbiAqIE1ldGhvZCAxOlxuICogYSA9IE9sZCB0ZXh0LCBiID0gTmV3IHRleHQsIGMgPSBhcnJheSBvZiBkaWZmIHR1cGxsZSBmb3IgYSB0byBiXG4gKiBNZXRob2QgMjpcbiAqIGEgPSBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dCAxIHRvIHRleHQgMiwgYiBhbmQgYyB1bmRlZmluZWRcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxBcnJheS48Kj4+fSBhIE9sZCB0ZXh0IChtZXRob2QgMSkgb3IgQXJyYXkgb2YgZGlmZlxuICogdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDIpXG4gKiBAcGFyYW0ge3N0cmluZz99IGIgTmV3IHRleHQgKG1ldGhvZCAxKVxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gYyBPcHRpb25hbCBhcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dDEgdG8gdGV4dDJcbiAqIChtZXRob2QgMSlcbiAqIEByZXR1cm4ge0FycmF5LjxwYXRjaF9vYmo+fSBBcnJheSBvZiBwYXRjaCBvYmplY3RzXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX21ha2UgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICB2YXIgdGV4dDEsIHRleHQyLCBkaWZmcztcbiAgaWYgKHR5cGVvZiBiID09ICd1bmRlZmluZWQnKSB7XG4gICAgZGlmZnMgPSBhO1xuICAgIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKGRpZmZzKTtcbiAgICB0ZXh0MiA9ICcnOyAgLy8gdGV4dDIgaXMgbm90IGFjdHVhbGx5IHVzZWQuXG4gIH0gZWxzZSB7XG4gICAgdGV4dDEgPSBhO1xuICAgIHRleHQyID0gYjtcbiAgICBpZiAodHlwZW9mIGMgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRpZmZzID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIHRydWUpO1xuICAgICAgaWYgKGRpZmZzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpYyhkaWZmcyk7XG4gICAgICAgIHRoaXMuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeShkaWZmcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTsgIC8vIEdldCByaWQgb2YgdGhlIG51bGwgY2FzZS5cbiAgfVxuICB2YXIgcGF0Y2hlcyA9IFtdO1xuICB2YXIgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gIHZhciBwYXRjaERpZmZMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICB2YXIgY2hhcl9jb3VudDEgPSAwOyAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW50byB0aGUgdGV4dDEgc3RyaW5nLlxuICB2YXIgY2hhcl9jb3VudDIgPSAwOyAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW50byB0aGUgdGV4dDIgc3RyaW5nLlxuICB2YXIgcHJlcGF0Y2hfdGV4dCA9IHRleHQxOyAgLy8gUmVjcmVhdGUgdGhlIHBhdGNoZXMgdG8gZGV0ZXJtaW5lIGNvbnRleHQgaW5mby5cbiAgdmFyIHBvc3RwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgZGlmZl90eXBlID0gZGlmZnNbeF1bMF07XG4gICAgdmFyIGRpZmZfdGV4dCA9IGRpZmZzW3hdWzFdO1xuXG4gICAgaWYgKCFwYXRjaERpZmZMZW5ndGggJiYgZGlmZl90eXBlICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBBIG5ldyBwYXRjaCBzdGFydHMgaGVyZS5cbiAgICAgIHBhdGNoLnN0YXJ0MSA9IGNoYXJfY291bnQxO1xuICAgICAgcGF0Y2guc3RhcnQyID0gY2hhcl9jb3VudDI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkaWZmX3R5cGUpIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIHBvc3RwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKDAsIGNoYXJfY291bnQyKSArIGRpZmZfdGV4dCArXG4gICAgICAgICAgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgK1xuICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50MiArIGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaWYgKGRpZmZfdGV4dC5sZW5ndGggPD0gMiAqIHRoaXMuUGF0Y2hfTWFyZ2luICYmXG4gICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZzLmxlbmd0aCAhPSB4ICsgMSkge1xuICAgICAgICAgIC8vIFNtYWxsIGVxdWFsaXR5IGluc2lkZSBhIHBhdGNoLlxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogdGhpcy5QYXRjaF9NYXJnaW4pIHtcbiAgICAgICAgICAvLyBUaW1lIGZvciBhIG5ldyBwYXRjaC5cbiAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGNoX2FkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoX3RleHQpO1xuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHByZXBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNoYXJhY3RlciBjb3VudC5cbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0lOU0VSVCkge1xuICAgICAgY2hhcl9jb3VudDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGRpZmZfdHlwZSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIGNoYXJfY291bnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgfVxuICB9XG4gIC8vIFBpY2sgdXAgdGhlIGxlZnRvdmVyIHBhdGNoIGlmIG5vdCBlbXB0eS5cbiAgaWYgKHBhdGNoRGlmZkxlbmd0aCkge1xuICAgIHRoaXMucGF0Y2hfYWRkQ29udGV4dChwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgfVxuXG4gIHJldHVybiBwYXRjaGVzO1xufTtcblxuXG4vKipcbiAqIE1lcmdlIGEgc2V0IG9mIHBhdGNoZXMgb250byB0aGUgdGV4dC4gIFJldHVybiBhIHBhdGNoZWQgdGV4dCwgYXMgd2VsbFxuICogYXMgYSBsaXN0IG9mIHRydWUvZmFsc2UgdmFsdWVzIGluZGljYXRpbmcgd2hpY2ggcGF0Y2hlcyB3ZXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IE9sZCB0ZXh0XG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nfEFycmF5Ljxib29sZWFuPj59IFR3byBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZVxuICogICAgICBuZXcgdGV4dCBhbmQgYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXNcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYXBwbHkgPSBmdW5jdGlvbiAocGF0Y2hlcywgdGV4dCkge1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiBbdGV4dCwgW11dO1xuICB9XG5cbiAgLy8gRGVlcCBjb3B5IHRoZSBwYXRjaGVzIHNvIHRoYXQgbm8gY2hhbmdlcyBhcmUgbWFkZSB0byBvcmlnaW5hbHMuXG4gIHZhciBwYXRjaGVzQ29weSA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIHZhciBwYXRjaENvcHkgPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgcGF0Y2hDb3B5LmRpZmZzID0gcGF0Y2guZGlmZnMuc2xpY2UoKTtcbiAgICBwYXRjaENvcHkuc3RhcnQxID0gcGF0Y2guc3RhcnQxO1xuICAgIHBhdGNoQ29weS5zdGFydDIgPSBwYXRjaC5zdGFydDI7XG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgxO1xuICAgIHBhdGNoQ29weS5sZW5ndGgyID0gcGF0Y2gubGVuZ3RoMjtcbiAgICBwYXRjaGVzQ29weVt4XSA9IHBhdGNoQ29weTtcbiAgfVxuICBwYXRjaGVzID0gcGF0Y2hlc0NvcHk7XG5cbiAgdmFyIG51bGxQYWRkaW5nID0gdGhpcy5wYXRjaF9hZGRQYWRkaW5nKHBhdGNoZXMpO1xuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XG5cbiAgdGhpcy5wYXRjaF9zcGxpdE1heChwYXRjaGVzKTtcbiAgLy8gZGVsdGEga2VlcHMgdHJhY2sgb2YgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIGxvY2F0aW9uXG4gIC8vIG9mIHRoZSBwcmV2aW91cyBwYXRjaC4gIElmIHRoZXJlIGFyZSBwYXRjaGVzIGV4cGVjdGVkIGF0IHBvc2l0aW9ucyAxMCBhbmRcbiAgLy8gMjAsIGJ1dCB0aGUgZmlyc3QgcGF0Y2ggd2FzIGZvdW5kIGF0IDEyLCBkZWx0YSBpcyAyIGFuZCB0aGUgc2Vjb25kIHBhdGNoXG4gIC8vIGhhcyBhbiBlZmZlY3RpdmUgZXhwZWN0ZWQgcG9zaXRpb24gb2YgMjIuXG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciByZXN1bHRzID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBleHBlY3RlZF9sb2MgPSBwYXRjaGVzW3hdLnN0YXJ0MiArIGRlbHRhO1xuICAgIHZhciB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcbiAgICB2YXIgc3RhcnRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsIHRleHQxLCBleHBlY3RlZF9sb2MpO1xuICAgIGlmIChzdGFydF9sb2MgPT09IG51bGwpIHtcbiAgICAgIC8vIE5vIG1hdGNoIGZvdW5kLiAgOihcbiAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm91bmQgYSBtYXRjaC4gIDopXG4gICAgICByZXN1bHRzW3hdID0gdHJ1ZTtcbiAgICAgIGRlbHRhID0gc3RhcnRfbG9jIC0gZXhwZWN0ZWRfbG9jO1xuICAgICAgdmFyIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgICAgIC8vIFBlcmZlY3QgbWF0Y2gsIGp1c3Qgc2hvdmUgdGhlIHJlcGxhY2VtZW50IHRleHQgaW4uXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICtcbiAgICAgICAgICB0aGlzLmRpZmZfdGV4dDIocGF0Y2hlc1t4XS5kaWZmcykgK1xuICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJbXBlcmZlY3QgbWF0Y2guICBSdW4gYSBkaWZmIHRvIGdldCBhIGZyYW1ld29yayBvZiBlcXVpdmFsZW50XG4gICAgICAgIC8vIGluZGljaWVzLlxuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgdmFyIGluZGV4MSA9IDA7XG4gICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2hlc1t4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgIHZhciBtb2QgPSBwYXRjaGVzW3hdLmRpZmZzW3ldO1xuICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsIGluZGV4MSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RbMF0gPT09IERJRkZfSU5TRVJUKSB7ICAvLyBJbnNlcnRpb25cbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICtcbiAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgaW5kZXgyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1vZFswXSA9PT0gRElGRl9ERUxFVEUpIHsgIC8vIERlbGV0aW9uXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRfbG9jICsgaW5kZXgyKSArXG4gICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsXG4gICAgICAgICAgICAgICAgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgaW5kZXgxICs9IG1vZFsxXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFN0cmlwIHRoZSBwYWRkaW5nIG9mZi5cbiAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xufTtcblxuXG4vKipcbiAqIEFkZCBzb21lIHBhZGRpbmcgb24gdGV4dCBzdGFydCBhbmQgZW5kIHNvIHRoYXQgZWRnZXMgY2FuIG1hdGNoIHNvbWV0aGluZy5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0c1xuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGFkZGluZyBzdHJpbmcgYWRkZWQgdG8gZWFjaCBzaWRlLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYWRkUGFkZGluZyA9IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gIHZhciBudWxsUGFkZGluZyA9ICcnO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuUGF0Y2hfTWFyZ2luOyB4KyspIHtcbiAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICB9XG5cbiAgLy8gQnVtcCBhbGwgdGhlIHBhdGNoZXMgZm9yd2FyZC5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDEgKz0gbnVsbFBhZGRpbmcubGVuZ3RoO1xuICAgIHBhdGNoZXNbeF0uc3RhcnQyICs9IG51bGxQYWRkaW5nLmxlbmd0aDtcbiAgfVxuXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gc3RhcnQgb2YgZmlyc3QgZGlmZi5cbiAgdmFyIHBhdGNoID0gcGF0Y2hlc1swXTtcbiAgdmFyIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1swXVswXSAhPSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XG4gICAgcGF0Y2guc3RhcnQxIC09IG51bGxQYWRkaW5nLmxlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxuICAgIHBhdGNoLnN0YXJ0MiAtPSBudWxsUGFkZGluZy5sZW5ndGg7ICAvLyBTaG91bGQgYmUgMC5cbiAgICBwYXRjaC5sZW5ndGgxICs9IG51bGxQYWRkaW5nLmxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IG51bGxQYWRkaW5nLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChudWxsUGFkZGluZy5sZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcbiAgICAvLyBHcm93IGZpcnN0IGVxdWFsaXR5LlxuICAgIHZhciBleHRyYUxlbmd0aCA9IG51bGxQYWRkaW5nLmxlbmd0aCAtIGRpZmZzWzBdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhkaWZmc1swXVsxXS5sZW5ndGgpICsgZGlmZnNbMF1bMV07XG4gICAgcGF0Y2guc3RhcnQxIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLnN0YXJ0MiAtPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cblxuICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIGVuZCBvZiBsYXN0IGRpZmYuXG4gIHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdO1xuICBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT0gRElGRl9FUVVBTCkge1xuICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBudWxsUGFkZGluZ10pO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gbnVsbFBhZGRpbmcubGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gbnVsbFBhZGRpbmcubGVuZ3RoO1xuICB9IGVsc2UgaWYgKG51bGxQYWRkaW5nLmxlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xuICAgIC8vIEdyb3cgbGFzdCBlcXVhbGl0eS5cbiAgICB2YXIgZXh0cmFMZW5ndGggPSBudWxsUGFkZGluZy5sZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKTtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59O1xuXG5cbi8qKlxuICogTG9vayB0aHJvdWdoIHRoZSBwYXRjaGVzIGFuZCBicmVhayB1cCBhbnkgd2hpY2ggYXJlIGxvbmdlciB0aGFuIHRoZSBtYXhpbXVtXG4gKiBsaW1pdCBvZiB0aGUgbWF0Y2ggYWxnb3JpdGhtLlxuICogQHBhcmFtIHtBcnJheS48cGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBwYXRjaCBvYmplY3RzXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3NwbGl0TWF4ID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xuICAgICAgdmFyIGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgYmlnIG9sZCBwYXRjaC5cbiAgICAgIHBhdGNoZXMuc3BsaWNlKHgsIDEpO1xuICAgICAgdmFyIHBhdGNoX3NpemUgPSB0aGlzLk1hdGNoX01heEJpdHM7XG4gICAgICB2YXIgc3RhcnQxID0gYmlncGF0Y2guc3RhcnQxO1xuICAgICAgdmFyIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MjtcbiAgICAgIHZhciBwcmVjb250ZXh0ID0gJyc7XG4gICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvbmUgb2Ygc2V2ZXJhbCBzbWFsbGVyIHBhdGNoZXMuXG4gICAgICAgIHZhciBwYXRjaCA9IG5ldyBwYXRjaF9vYmooKTtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgcGF0Y2guc3RhcnQxID0gc3RhcnQxIC0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLnN0YXJ0MiA9IHN0YXJ0MiAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocHJlY29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMiA9IHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHByZWNvbnRleHRdKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSA8IHBhdGNoX3NpemUgLSB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgICAgICAgIHZhciBkaWZmX3R5cGUgPSBiaWdwYXRjaC5kaWZmc1swXVswXTtcbiAgICAgICAgICB2YXIgZGlmZl90ZXh0ID0gYmlncGF0Y2guZGlmZnNbMF1bMV07XG4gICAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICAgIC8vIEluc2VydGlvbnMgYXJlIGhhcm1sZXNzLlxuICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgc3RhcnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVsZXRpb24gb3IgZXF1YWxpdHkuICBPbmx5IHRha2UgYXMgbXVjaCBhcyB3ZSBjYW4gc3RvbWFjaC5cbiAgICAgICAgICAgIGRpZmZfdGV4dCA9IGRpZmZfdGV4dC5zdWJzdHJpbmcoMCwgcGF0Y2hfc2l6ZSAtIHBhdGNoLmxlbmd0aDEgLVxuICAgICAgICAgICAgICB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmX3R5cGUsIGRpZmZfdGV4dF0pO1xuICAgICAgICAgICAgaWYgKGRpZmZfdGV4dCA9PSBiaWdwYXRjaC5kaWZmc1swXVsxXSkge1xuICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0gPVxuICAgICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaGVhZCBjb250ZXh0IGZvciB0aGUgbmV4dCBwYXRjaC5cbiAgICAgICAgcHJlY29udGV4dCA9IHRoaXMuZGlmZl90ZXh0MihwYXRjaC5kaWZmcyk7XG4gICAgICAgIHByZWNvbnRleHQgPVxuICAgICAgICAgIHByZWNvbnRleHQuc3Vic3RyaW5nKHByZWNvbnRleHQubGVuZ3RoIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xuICAgICAgICAvLyBBcHBlbmQgdGhlIGVuZCBjb250ZXh0IGZvciB0aGlzIHBhdGNoLlxuICAgICAgICB2YXIgcG9zdGNvbnRleHQgPSB0aGlzLmRpZmZfdGV4dDEoYmlncGF0Y2guZGlmZnMpXG4gICAgICAgICAgLnN1YnN0cmluZygwLCB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgIGlmIChwb3N0Y29udGV4dCAhPT0gJycpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdGNvbnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHBvc3Rjb250ZXh0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgICBwYXRjaGVzLnNwbGljZSh4KyssIDAsIHBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFRha2UgYSBsaXN0IG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHNcbiAqIEByZXR1cm4ge3N0cmluZ30gVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3RvVGV4dCA9IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gIHZhciB0ZXh0ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHRleHRbeF0gPSBwYXRjaGVzW3hdO1xuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIFBhcnNlIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSBsaXN0IG9mIHBhdGNoIG9iamVjdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dGxpbmUgVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzXG4gKiBAcmV0dXJuIHtBcnJheS48cGF0Y2hfb2JqPn0gQXJyYXkgb2YgcGF0Y2ggb2JqZWN0c1xuICogQHRocm93cyB7RXJyb3J9IElmIGludmFsaWQgaW5wdXRcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZnJvbVRleHQgPSBmdW5jdGlvbiAodGV4dGxpbmUpIHtcbiAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgaWYgKCF0ZXh0bGluZSkge1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qga25vdyBob3cgdG8gZGVjb2RlIGNoYXIgMC5cbiAgdGV4dGxpbmUgPSB0ZXh0bGluZS5yZXBsYWNlKC8lMDAvZywgJ1xcMCcpO1xuICB2YXIgdGV4dCA9IHRleHRsaW5lLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHRleHRQb2ludGVyID0gMDtcbiAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgbSA9IHRleHRbdGV4dFBvaW50ZXJdLm1hdGNoKC9eQEAgLShcXGQrKSw/KFxcZCopIFxcKyhcXGQrKSw/KFxcZCopIEBAJC8pO1xuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhdGNoIHN0cmluZzogJyArIHRleHRbdGV4dFBvaW50ZXJdKTtcbiAgICB9XG4gICAgdmFyIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgcGF0Y2guc3RhcnQxID0gcGFyc2VJbnQobVsxXSwgMTApO1xuICAgIGlmIChtWzJdID09PSAnJykge1xuICAgICAgcGF0Y2guc3RhcnQxLS07XG4gICAgICBwYXRjaC5sZW5ndGgxID0gMTtcbiAgICB9IGVsc2UgaWYgKG1bMl0gPT0gJzAnKSB7XG4gICAgICBwYXRjaC5sZW5ndGgxID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2guc3RhcnQxLS07XG4gICAgICBwYXRjaC5sZW5ndGgxID0gcGFyc2VJbnQobVsyXSwgMTApO1xuICAgIH1cblxuICAgIHBhdGNoLnN0YXJ0MiA9IHBhcnNlSW50KG1bM10sIDEwKTtcbiAgICBpZiAobVs0XSA9PT0gJycpIHtcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IDE7XG4gICAgfSBlbHNlIGlmIChtWzRdID09ICcwJykge1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IHBhcnNlSW50KG1bNF0sIDEwKTtcbiAgICB9XG4gICAgdGV4dFBvaW50ZXIrKztcblxuICAgIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XG4gICAgICB2YXIgc2lnbiA9IHRleHRbdGV4dFBvaW50ZXJdLmNoYXJBdCgwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBsaW5lID0gZGVjb2RlVVJJKHRleHRbdGV4dFBvaW50ZXJdLnN1YnN0cmluZygxKSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAvLyBNYWxmb3JtZWQgVVJJIHNlcXVlbmNlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgZXNjYXBlIGluIHBhdGNoX2Zyb21UZXh0OiAnICsgbGluZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbiA9PSAnLScpIHtcbiAgICAgICAgLy8gRGVsZXRpb24uXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfREVMRVRFLCBsaW5lXSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJysnKSB7XG4gICAgICAgIC8vIEluc2VydGlvbi5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9JTlNFUlQsIGxpbmVdKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnICcpIHtcbiAgICAgICAgLy8gTWlub3IgZXF1YWxpdHkuXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGxpbmVdKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnQCcpIHtcbiAgICAgICAgLy8gU3RhcnQgb2YgbmV4dCBwYXRjaC5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT09ICcnKSB7XG4gICAgICAgIC8vIEJsYW5rIGxpbmU/ICBXaGF0ZXZlci5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdURj9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhdGNoIG1vZGUgXCInICsgc2lnbiArICdcIiBpbjogJyArIGxpbmUpO1xuICAgICAgfVxuICAgICAgdGV4dFBvaW50ZXIrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59O1xuXG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIG9uZSBwYXRjaCBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gcGF0Y2hfb2JqKCkge1xuICB0aGlzLmRpZmZzID0gW107XG4gIC8qKiBAdHlwZSB7bnVtYmVyP30gKi9cbiAgdGhpcy5zdGFydDEgPSBudWxsO1xuICAvKiogQHR5cGUge251bWJlcj99ICovXG4gIHRoaXMuc3RhcnQyID0gbnVsbDtcbiAgdGhpcy5sZW5ndGgxID0gMDtcbiAgdGhpcy5sZW5ndGgyID0gMDtcbn1cblxuXG4vKipcbiAqIEVtbXVsYXRlIEdOVSBkaWZmJ3MgZm9ybWF0LlxuICogSGVhZGVyOiBAQCAtMzgyLDggKzQ4MSw5IEBAXG4gKiBJbmRpY2llcyBhcmUgcHJpbnRlZCBhcyAxLWJhc2VkLCBub3QgMC1iYXNlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdOVSBkaWZmIHN0cmluZ1xuICovXG5wYXRjaF9vYmoucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29vcmRzMSwgY29vcmRzMjtcbiAgaWYgKHRoaXMubGVuZ3RoMSA9PT0gMCkge1xuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArICcsMCc7XG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGgxID09IDEpIHtcbiAgICBjb29yZHMxID0gdGhpcy5zdGFydDEgKyAxO1xuICB9IGVsc2Uge1xuICAgIGNvb3JkczEgPSAodGhpcy5zdGFydDEgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMTtcbiAgfVxuICBpZiAodGhpcy5sZW5ndGgyID09PSAwKSB7XG4gICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgJywwJztcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDIgPT0gMSkge1xuICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArIDE7XG4gIH0gZWxzZSB7XG4gICAgY29vcmRzMiA9ICh0aGlzLnN0YXJ0MiArIDEpICsgJywnICsgdGhpcy5sZW5ndGgyO1xuICB9XG4gIHZhciB0eHQgPSBbJ0BAIC0nICsgY29vcmRzMSArICcgKycgKyBjb29yZHMyICsgJyBAQFxcbiddO1xuICB2YXIgb3A7XG4gIC8vIEVzY2FwZSB0aGUgYm9keSBvZiB0aGUgcGF0Y2ggd2l0aCAleHggbm90YXRpb24uXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5kaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHN3aXRjaCAodGhpcy5kaWZmc1t4XVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgb3AgPSAnKyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgb3AgPSAnLSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBvcCA9ICcgJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHR4dFt4ICsgMV0gPSBvcCArIGVuY29kZVVSSSh0aGlzLmRpZmZzW3hdWzFdKSArICdcXG4nO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qga25vdyBob3cgdG8gZW5jb2RlIGNoYXIgMC5cbiAgcmV0dXJuIHR4dC5qb2luKCcnKS5yZXBsYWNlKC9cXDAvZywgJyUwMCcpLnJlcGxhY2UoLyUyMC9nLCAnICcpO1xufTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICB3aW5kb3cuZGlmZl9tYXRjaF9wYXRjaCA9IGRpZmZfbWF0Y2hfcGF0Y2g7XG5cbn0pLmNhbGwodGhpcyk7IiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYxLjQuM1xuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTAsIEpvaG4gUmVzaWdcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqIENvcHlyaWdodCAyMDEwLCBUaGUgRG9qbyBGb3VuZGF0aW9uXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlULCBCU0QsIGFuZCBHUEwgTGljZW5zZXMuXG4gKlxuICogRGF0ZTogVGh1IE9jdCAxNCAyMzoxMDowNiAyMDEwIC0wNDAwXG4gKi9cblxuKGZ1bmN0aW9uICh3aW5kb3csIHVuZGVmaW5lZCkge1xuXG4gICAgLy8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB2YXIgalF1ZXJ5ID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuICAgICAgICB2YXIgalF1ZXJ5ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICAgICAgICAgIF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG4gICAgICAgICAgICAvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgICAgICAgICAgXyQgPSB3aW5kb3cuJCxcblxuICAgICAgICAgICAgLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG4gICAgICAgICAgICByb290alF1ZXJ5LFxuXG4gICAgICAgICAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5ncyBvciBJRCBzdHJpbmdzXG4gICAgICAgICAgICAvLyAoYm90aCBvZiB3aGljaCB3ZSBvcHRpbWl6ZSBmb3IpXG4gICAgICAgICAgICBxdWlja0V4cHIgPSAvXig/OltePF0qKDxbXFx3XFxXXSs+KVtePl0qJHwjKFtcXHdcXC1dKykkKS8sXG5cbiAgICAgICAgICAgIC8vIElzIGl0IGEgc2ltcGxlIHNlbGVjdG9yXG4gICAgICAgICAgICBpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLyxcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBzdHJpbmcgaGFzIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIGluIGl0XG4gICAgICAgICAgICBybm90d2hpdGUgPSAvXFxTLyxcbiAgICAgICAgICAgIHJ3aGl0ZSA9IC9cXHMvLFxuXG4gICAgICAgICAgICAvLyBVc2VkIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB0cmltTGVmdCA9IC9eXFxzKy8sXG4gICAgICAgICAgICB0cmltUmlnaHQgPSAvXFxzKyQvLFxuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igbm9uLXdvcmQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgcm5vbndvcmQgPSAvXFxXLyxcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRpZ2l0c1xuICAgICAgICAgICAgcmRpZ2l0ID0gL1xcZC8sXG5cbiAgICAgICAgICAgIC8vIE1hdGNoIGEgc3RhbmRhbG9uZSB0YWdcbiAgICAgICAgICAgIHJzaW5nbGVUYWcgPSAvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPik/JC8sXG5cbiAgICAgICAgICAgIC8vIEpTT04gUmVnRXhwXG4gICAgICAgICAgICBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvLFxuICAgICAgICAgICAgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZyxcbiAgICAgICAgICAgIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZyxcbiAgICAgICAgICAgIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZyxcblxuICAgICAgICAgICAgLy8gVXNlcmFnZW50IFJlZ0V4cFxuICAgICAgICAgICAgcndlYmtpdCA9IC8od2Via2l0KVsgXFwvXShbXFx3Ll0rKS8sXG4gICAgICAgICAgICByb3BlcmEgPSAvKG9wZXJhKSg/Oi4qdmVyc2lvbik/WyBcXC9dKFtcXHcuXSspLyxcbiAgICAgICAgICAgIHJtc2llID0gLyhtc2llKSAoW1xcdy5dKykvLFxuICAgICAgICAgICAgcm1vemlsbGEgPSAvKG1vemlsbGEpKD86Lio/IHJ2OihbXFx3Ll0rKSk/LyxcblxuICAgICAgICAgICAgLy8gS2VlcCBhIFVzZXJBZ2VudCBzdHJpbmcgZm9yIHVzZSB3aXRoIGpRdWVyeS5icm93c2VyXG4gICAgICAgICAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxuXG4gICAgICAgICAgICAvLyBGb3IgbWF0Y2hpbmcgdGhlIGVuZ2luZSBhbmQgdmVyc2lvbiBvZiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgYnJvd3Nlck1hdGNoLFxuXG4gICAgICAgICAgICAvLyBIYXMgdGhlIHJlYWR5IGV2ZW50cyBhbHJlYWR5IGJlZW4gYm91bmQ/XG4gICAgICAgICAgICByZWFkeUJvdW5kID0gZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIFRoZSBmdW5jdGlvbnMgdG8gZXhlY3V0ZSBvbiBET00gcmVhZHlcbiAgICAgICAgICAgIHJlYWR5TGlzdCA9IFtdLFxuXG4gICAgICAgICAgICAvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgRE9NQ29udGVudExvYWRlZCxcblxuICAgICAgICAgICAgLy8gU2F2ZSBhIHJlZmVyZW5jZSB0byBzb21lIGNvcmUgbWV0aG9kc1xuICAgICAgICAgICAgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICAgICAgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgICAgIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaCxcbiAgICAgICAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgICAgICAgICAgdHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbSxcbiAgICAgICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZixcblxuICAgICAgICAgICAgLy8gW1tDbGFzc11dIC0+IHR5cGUgcGFpcnNcbiAgICAgICAgICAgIGNsYXNzMnR5cGUgPSB7fTtcblxuICAgICAgICBqUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoLCBlbGVtLCByZXQsIGRvYztcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSAkKFwiXCIpLCAkKG51bGwpLCBvciAkKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSAkKERPTUVsZW1lbnQpXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYm9keSBlbGVtZW50IG9ubHkgZXhpc3RzIG9uY2UsIG9wdGltaXplIGZpbmRpbmcgaXRcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IFwiYm9keVwiICYmICFjb250ZXh0ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbMF0gPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gXCJib2R5XCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJlIHdlIGRlYWxpbmcgd2l0aCBIVE1MIHN0cmluZyBvciBhbiBJRD9cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBxdWlja0V4cHIuZXhlYyhzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IGEgbWF0Y2gsIGFuZCB0aGF0IG5vIGNvbnRleHQgd2FzIHNwZWNpZmllZCBmb3IgI2lkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gKGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgc2luZ2xlIHN0cmluZyBpcyBwYXNzZWQgaW4gYW5kIGl0J3MgYSBzaW5nbGUgdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBkbyBhIGNyZWF0ZUVsZW1lbnQgYW5kIHNraXAgdGhlIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSByc2luZ2xlVGFnLmV4ZWMoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gW2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQocmV0WzFdKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZm4uYXR0ci5jYWxsKHNlbGVjdG9yLCBjb250ZXh0LCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBbZG9jLmNyZWF0ZUVsZW1lbnQocmV0WzFdKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KFttYXRjaFsxXV0sIFtkb2NdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAocmV0LmNhY2hlYWJsZSA/IHJldC5mcmFnbWVudC5jbG9uZU5vZGUodHJ1ZSkgOiByZXQuZnJhZ21lbnQpLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSh0aGlzLCBzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoXCIjaWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdGNoWzJdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUgYW5kIE9wZXJhIHJldHVybiBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uaWQgIT09IG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdGpRdWVyeS5maW5kKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgaW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChcIlRBR1wiKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjb250ZXh0ICYmICFybm9ud29yZC50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UodGhpcywgc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNvbnRleHQgfHwgcm9vdGpRdWVyeSkuZmluZChzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5KGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdGpRdWVyeS5yZWFkeShzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWFrZUFycmF5KHNlbGVjdG9yLCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3JcbiAgICAgICAgICAgIHNlbGVjdG9yOiBcIlwiLFxuXG4gICAgICAgICAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG4gICAgICAgICAgICBqcXVlcnk6IFwiMS40LjNcIixcblxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG4gICAgICAgICAgICBsZW5ndGg6IDAsXG5cbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XG4gICAgICAgICAgICBzaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKHRoaXMsIDApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuICAgICAgICAgICAgLy8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKG51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW0gPT0gbnVsbCA/XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGEgJ2NsZWFuJyBhcnJheVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvQXJyYXkoKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGp1c3QgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAobnVtIDwgMCA/IHRoaXMuc2xpY2UobnVtKVswXSA6IHRoaXNbbnVtXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG4gICAgICAgICAgICAvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcbiAgICAgICAgICAgIHB1c2hTdGFjazogZnVuY3Rpb24gKGVsZW1zLCBuYW1lLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGpRdWVyeSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KGVsZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJldCwgZWxlbXMpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHJldCwgZWxlbXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG4gICAgICAgICAgICAgICAgcmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgcmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJmaW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArICh0aGlzLnNlbGVjdG9yID8gXCIgXCIgOiBcIlwiKSArIHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yICsgXCIuXCIgKyBuYW1lICsgXCIoXCIgKyBzZWxlY3RvciArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG4gICAgICAgICAgICAvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xuICAgICAgICAgICAgLy8gb25seSB1c2VkIGludGVybmFsbHkuKVxuICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKHRoaXMsIGNhbGxiYWNrLCBhcmdzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlYWR5OiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2ggdGhlIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIGpRdWVyeS5iaW5kUmVhZHkoKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBET00gaXMgYWxyZWFkeSByZWFkeVxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKGRvY3VtZW50LCBqUXVlcnkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcmVtZW1iZXIgdGhlIGZ1bmN0aW9uIGZvciBsYXRlclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVhZHlMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZnVuY3Rpb24gdG8gdGhlIHdhaXQgbGlzdFxuICAgICAgICAgICAgICAgICAgICByZWFkeUxpc3QucHVzaChmbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlcTogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gLTEgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWNlKGkpIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGljZShpLCAraSArIDEpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgwKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGxhc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzbGljZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICBcInNsaWNlXCIsIHNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtYXA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uIChlbGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGVsZW0sIGksIGVsZW0pO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgalF1ZXJ5KG51bGwpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAgICAgICAgLy8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG4gICAgICAgICAgICBwdXNoOiBwdXNoLFxuICAgICAgICAgICAgc29ydDogW10uc29ydCxcbiAgICAgICAgICAgIHNwbGljZTogW10uc3BsaWNlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuICAgICAgICBqUXVlcnkuZm4uaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbiAgICAgICAgalF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjb3B5IHJlZmVyZW5jZSB0byB0YXJnZXQgb2JqZWN0XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LCBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwgZGVlcCA9IGZhbHNlLCBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5O1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBkZWVwID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgaSA9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG4gICAgICAgICAgICBpZiAobGVuZ3RoID09PSBpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjb3B5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXAgJiYgY29weSAmJiAoalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0galF1ZXJ5LmV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvcHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICAgICAgbm9Db25mbGljdDogZnVuY3Rpb24gKGRlZXApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuJCA9IF8kO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG4gICAgICAgICAgICBpc1JlYWR5OiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuICAgICAgICAgICAgLy8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcbiAgICAgICAgICAgIHJlYWR5V2FpdDogMSxcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuICAgICAgICAgICAgcmVhZHk6IGZ1bmN0aW9uICh3YWl0KSB7XG4gICAgICAgICAgICAgICAgLy8gQSB0aGlyZC1wYXJ0eSBpcyBwdXNoaW5nIHRoZSByZWFkeSBldmVudCBmb3J3YXJkc1xuICAgICAgICAgICAgICAgIGlmICh3YWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeVdhaXQtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgRE9NIGlzIG5vdCBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LnJlYWR5V2FpdCB8fCAod2FpdCAhPT0gdHJ1ZSAmJiAhalF1ZXJ5LmlzUmVhZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBib2R5IGV4aXN0cywgYXQgbGVhc3QsIGluIGNhc2UgSUUgZ2V0cyBhIGxpdHRsZSBvdmVyemVhbG91cyAodGlja2V0ICM1NDQzKS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChqUXVlcnkucmVhZHksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuICAgICAgICAgICAgICAgICAgICBpZiAod2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkeUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgYWxsIG9mIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiwgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGZuID0gcmVhZHlMaXN0W2krK10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChkb2N1bWVudCwgalF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGxpc3Qgb2YgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkeUxpc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeShkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXCJyZWFkeVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJpbmRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeUJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWFkeUJvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoalF1ZXJ5LnJlYWR5LCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNb3ppbGxhLCBPcGVyYSBhbmQgd2Via2l0IG5pZ2h0bGllcyBjdXJyZW50bHkgc3VwcG9ydCB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBET01Db250ZW50TG9hZGVkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGpRdWVyeS5yZWFkeSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIElFIGV2ZW50IG1vZGVsIGlzIHVzZWRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBmaXJpbmcgYmVmb3JlIG9ubG9hZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF5YmUgbGF0ZSBidXQgc2FmZSBhbHNvIGZvciBpZnJhbWVzXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIERPTUNvbnRlbnRMb2FkZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudChcIm9ubG9hZFwiLCBqUXVlcnkucmVhZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIElFIGFuZCBub3QgYSBmcmFtZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51YWxseSBjaGVjayB0byBzZWUgaWYgdGhlIGRvY3VtZW50IGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BsZXZlbCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BsZXZlbCA9IHdpbmRvdy5mcmFtZUVsZW1lbnQgPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0b3BsZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9TY3JvbGxDaGVjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gU2VlIHRlc3QvdW5pdC9jb3JlLmpzIGZvciBkZXRhaWxzIGNvbmNlcm5pbmcgaXNGdW5jdGlvbi5cbiAgICAgICAgICAgIC8vIFNpbmNlIHZlcnNpb24gMS4zLCBET00gbWV0aG9kcyBhbmQgZnVuY3Rpb25zIGxpa2UgYWxlcnRcbiAgICAgICAgICAgIC8vIGFyZW4ndCBzdXBwb3J0ZWQuIFRoZXkgcmV0dXJuIGZhbHNlIG9uIElFICgjMjk2OCkuXG4gICAgICAgICAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImFycmF5XCI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBIGNydWRlIHdheSBvZiBkZXRlcm1pbmluZyBpZiBhbiBvYmplY3QgaXMgYSB3aW5kb3dcbiAgICAgICAgICAgIGlzV2luZG93OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIFwic2V0SW50ZXJ2YWxcIiBpbiBvYmo7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc05hTjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogPT0gbnVsbCB8fCAhcmRpZ2l0LnRlc3Qob2JqKSB8fCBpc05hTihvYmopO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdHlwZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgIFN0cmluZyhvYmopIDpcbiAgICAgICAgICAgICAgICAgICAgY2xhc3MydHlwZVt0b1N0cmluZy5jYWxsKG9iaildIHx8IFwib2JqZWN0XCI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBhbiBPYmplY3QuXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBvZiBJRSwgd2UgYWxzbyBoYXZlIHRvIGNoZWNrIHRoZSBwcmVzZW5jZSBvZiB0aGUgY29uc3RydWN0b3IgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgRE9NIG5vZGVzIGFuZCB3aW5kb3cgb2JqZWN0cyBkb24ndCBwYXNzIHRocm91Z2gsIGFzIHdlbGxcbiAgICAgICAgICAgICAgICBpZiAoIW9iaiB8fCBqUXVlcnkudHlwZShvYmopICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3cob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuICAgICAgICAgICAgICAgIGlmIChvYmouY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgIWhhc093bi5jYWxsKG9iaiwgXCJjb25zdHJ1Y3RvclwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcbiAgICAgICAgICAgICAgICAvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblxuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7IH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbChvYmosIGtleSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbXNnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGFyc2VKU09OOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQgKElFIGNhbid0IGhhbmRsZSBpdClcbiAgICAgICAgICAgICAgICBkYXRhID0galF1ZXJ5LnRyaW0oZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGluY29taW5nIGRhdGEgaXMgYWN0dWFsIEpTT05cbiAgICAgICAgICAgICAgICAvLyBMb2dpYyBib3Jyb3dlZCBmcm9tIGh0dHA6Ly9qc29uLm9yZy9qc29uMi5qc1xuICAgICAgICAgICAgICAgIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsIFwiQFwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsIFwiXVwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShydmFsaWRicmFjZXMsIFwiXCIpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byB1c2UgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LkpTT04gJiYgd2luZG93LkpTT04ucGFyc2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LkpTT04ucGFyc2UoZGF0YSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbihcInJldHVybiBcIiArIGRhdGEpKSgpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKFwiSW52YWxpZCBKU09OOiBcIiArIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHsgfSxcblxuICAgICAgICAgICAgLy8gRXZhbHVsYXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG4gICAgICAgICAgICBnbG9iYWxFdmFsOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIHJub3R3aGl0ZS50ZXN0KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3BpcmVkIGJ5IGNvZGUgYnkgQW5kcmVhIEdpYW1tYXJjaGlcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3dlYnJlZmxlY3Rpb24uYmxvZ3Nwb3QuY29tLzIwMDcvMDgvZ2xvYmFsLXNjb3BlLWV2YWx1YXRpb24tYW5kLWRvbS5odG1sXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuc3VwcG9ydC5zY3JpcHRFdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnRleHQgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIGFwcGVuZENoaWxkIHRvIGNpcmN1bXZlbnQgYW4gSUU2IGJ1Zy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhcmlzZXMgd2hlbiBhIGJhc2Ugbm9kZSBpcyB1c2VkICgjMjcwOSkuXG4gICAgICAgICAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG5vZGVOYW1lOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gYXJncyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSwgaSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqID0gbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5hcHBseShvYmplY3RbbmFtZV0sIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suYXBwbHkob2JqZWN0W2krK10sIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9iamVjdFtuYW1lXSwgbmFtZSwgb2JqZWN0W25hbWVdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdmFsdWUgPSBvYmplY3RbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA8IGxlbmd0aCAmJiBjYWxsYmFjay5jYWxsKHZhbHVlLCBpLCB2YWx1ZSkgIT09IGZhbHNlOyB2YWx1ZSA9IG9iamVjdFsrK2ldKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBVc2UgbmF0aXZlIFN0cmluZy50cmltIGZ1bmN0aW9uIHdoZXJldmVyIHBvc3NpYmxlXG4gICAgICAgICAgICB0cmltOiB0cmltID9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpbS5jYWxsKHRleHQpO1xuICAgICAgICAgICAgICAgIH0gOlxuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHVzZSBvdXIgb3duIHRyaW1taW5nIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC50b1N0cmluZygpLnJlcGxhY2UodHJpbUxlZnQsIFwiXCIpLnJlcGxhY2UodHJpbVJpZ2h0LCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICAgICAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uIChhcnJheSwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHdpbmRvdywgc3RyaW5ncyAoYW5kIGZ1bmN0aW9ucykgYWxzbyBoYXZlICdsZW5ndGgnXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleHRyYSB0eXBlb2YgZnVuY3Rpb24gY2hlY2sgaXMgdG8gcHJldmVudCBjcmFzaGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIFNhZmFyaSAyIChTZWU6ICMzMDM5KVxuICAgICAgICAgICAgICAgICAgICAvLyBUd2Vha2VkIGxvZ2ljIHNsaWdodGx5IHRvIGhhbmRsZSBCbGFja2JlcnJ5IDQuNyBSZWdFeHAgaXNzdWVzICM2OTMwXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0galF1ZXJ5LnR5cGUoYXJyYXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlID09PSBcInJlZ2V4cFwiIHx8IGpRdWVyeS5pc1dpbmRvdyhhcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guY2FsbChyZXQsIGFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShyZXQsIGFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbkFycmF5OiBmdW5jdGlvbiAoZWxlbSwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXkuaW5kZXhPZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gZmlyc3QubGVuZ3RoLCBqID0gMDtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gc2Vjb25kLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RbaSsrXSA9IHNlY29uZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNlY29uZFtqXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFtpKytdID0gc2Vjb25kW2orK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJzdC5sZW5ndGggPSBpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ3JlcDogZnVuY3Rpb24gKGVsZW1zLCBjYWxsYmFjaywgaW52KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdLCByZXRWYWw7XG4gICAgICAgICAgICAgICAgaW52ID0gISFpbnY7XG5cbiAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0VmFsID0gISFjYWxsYmFjayhlbGVtc1tpXSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnYgIT09IHJldFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goZWxlbXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgICAgICAgICAgbWFwOiBmdW5jdGlvbiAoZWxlbXMsIGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW10sIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyXG4gICAgICAgICAgICAgICAgLy8gbmV3IHZhbHVlIChvciB2YWx1ZXMpLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1zW2ldLCBpLCBhcmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbcmV0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQuY29uY2F0LmFwcGx5KFtdLCByZXQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG4gICAgICAgICAgICBndWlkOiAxLFxuXG4gICAgICAgICAgICBwcm94eTogZnVuY3Rpb24gKGZuLCBwcm94eSwgdGhpc09iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJveHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNPYmplY3QgPSBmbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gdGhpc09iamVjdFtwcm94eV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3h5ICYmICFqUXVlcnkuaXNGdW5jdGlvbihwcm94eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNPYmplY3QgPSBwcm94eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm94eSAmJiBmbikge1xuICAgICAgICAgICAgICAgICAgICBwcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzT2JqZWN0IHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBwcm94eS5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU28gcHJveHkgY2FuIGJlIGRlY2xhcmVkIGFzIGFuIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gTXV0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyB0byBhIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZS9zIGNhbiBiZSBvcHRpb25hbGx5IGJ5IGV4ZWN1dGVkIGlmIGl0cyBhIGZ1bmN0aW9uXG4gICAgICAgICAgICBhY2Nlc3M6IGZ1bmN0aW9uIChlbGVtcywga2V5LCB2YWx1ZSwgZXhlYywgZm4sIHBhc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBtYW55IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmFjY2VzcyhlbGVtcywgaywga2V5W2tdLCBleGVjLCBmbiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIG9uZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5LCBmdW5jdGlvbiB2YWx1ZXMgZ2V0IGV4ZWN1dGVkIGlmIGV4ZWMgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBleGVjID0gIXBhc3MgJiYgZXhlYyAmJiBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4oZWxlbXNbaV0sIGtleSwgZXhlYyA/IHZhbHVlLmNhbGwoZWxlbXNbaV0sIGksIGZuKGVsZW1zW2ldLCBrZXkpKSA6IHZhbHVlLCBwYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXR0aW5nIGFuIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggPyBmbihlbGVtc1swXSwga2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG5vdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gVXNlIG9mIGpRdWVyeS5icm93c2VyIGlzIGZyb3duZWQgdXBvbi5cbiAgICAgICAgICAgIC8vIE1vcmUgZGV0YWlsczogaHR0cDovL2RvY3MuanF1ZXJ5LmNvbS9VdGlsaXRpZXMvalF1ZXJ5LmJyb3dzZXJcbiAgICAgICAgICAgIHVhTWF0Y2g6IGZ1bmN0aW9uICh1YSkge1xuICAgICAgICAgICAgICAgIHVhID0gdWEudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHJ3ZWJraXQuZXhlYyh1YSkgfHxcbiAgICAgICAgICAgICAgICAgICAgcm9wZXJhLmV4ZWModWEpIHx8XG4gICAgICAgICAgICAgICAgICAgIHJtc2llLmV4ZWModWEpIHx8XG4gICAgICAgICAgICAgICAgICAgIHVhLmluZGV4T2YoXCJjb21wYXRpYmxlXCIpIDwgMCAmJiBybW96aWxsYS5leGVjKHVhKSB8fFxuICAgICAgICAgICAgICAgICAgICBbXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGJyb3dzZXI6IG1hdGNoWzFdIHx8IFwiXCIsIHZlcnNpb246IG1hdGNoWzJdIHx8IFwiMFwiIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBicm93c2VyOiB7fVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbiAgICAgICAgalF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0XCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xuICAgICAgICAgICAgY2xhc3MydHlwZVtcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCJdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBicm93c2VyTWF0Y2ggPSBqUXVlcnkudWFNYXRjaCh1c2VyQWdlbnQpO1xuICAgICAgICBpZiAoYnJvd3Nlck1hdGNoLmJyb3dzZXIpIHtcbiAgICAgICAgICAgIGpRdWVyeS5icm93c2VyW2Jyb3dzZXJNYXRjaC5icm93c2VyXSA9IHRydWU7XG4gICAgICAgICAgICBqUXVlcnkuYnJvd3Nlci52ZXJzaW9uID0gYnJvd3Nlck1hdGNoLnZlcnNpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXByZWNhdGVkLCB1c2UgalF1ZXJ5LmJyb3dzZXIud2Via2l0IGluc3RlYWRcbiAgICAgICAgaWYgKGpRdWVyeS5icm93c2VyLndlYmtpdCkge1xuICAgICAgICAgICAgalF1ZXJ5LmJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleE9mKSB7XG4gICAgICAgICAgICBqUXVlcnkuaW5BcnJheSA9IGZ1bmN0aW9uIChlbGVtLCBhcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoYXJyYXksIGVsZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IFxccyBtYXRjaGVzIG5vbi1icmVha2luZyBzcGFjZXNcbiAgICAgICAgLy8gKElFIGZhaWxzIG9uIHRoaXMgdGVzdClcbiAgICAgICAgaWYgKCFyd2hpdGUudGVzdChcIlxceEEwXCIpKSB7XG4gICAgICAgICAgICB0cmltTGVmdCA9IC9eW1xcc1xceEEwXSsvO1xuICAgICAgICAgICAgdHJpbVJpZ2h0ID0gL1tcXHNcXHhBMF0rJC87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGwgalF1ZXJ5IG9iamVjdHMgc2hvdWxkIHBvaW50IGJhY2sgdG8gdGhlc2VcbiAgICAgICAgcm9vdGpRdWVyeSA9IGpRdWVyeShkb2N1bWVudCk7XG5cbiAgICAgICAgLy8gQ2xlYW51cCBmdW5jdGlvbnMgZm9yIHRoZSBkb2N1bWVudCByZWFkeSBtZXRob2RcbiAgICAgICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgRE9NQ29udGVudExvYWRlZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBET01Db250ZW50TG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBib2R5IGV4aXN0cywgYXQgbGVhc3QsIGluIGNhc2UgSUUgZ2V0cyBhIGxpdHRsZSBvdmVyemVhbG91cyAodGlja2V0ICM1NDQzKS5cbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIERPTUNvbnRlbnRMb2FkZWQpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkucmVhZHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIERPTSByZWFkeSBjaGVjayBmb3IgSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgZnVuY3Rpb24gZG9TY3JvbGxDaGVjaygpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNSZWFkeSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBJZiBJRSBpcyB1c2VkLCB1c2UgdGhlIHRyaWNrIGJ5IERpZWdvIFBlcmluaVxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9JRUNvbnRlbnRMb2FkZWQvXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKFwibGVmdFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGRvU2Nyb2xsQ2hlY2ssIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG4gICAgICAgICAgICBqUXVlcnkucmVhZHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cG9zZSBqUXVlcnkgdG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICAgICAgcmV0dXJuICh3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnkpO1xuXG4gICAgfSkoKTtcblxuXG4gICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBqUXVlcnkuc3VwcG9ydCA9IHt9O1xuXG4gICAgICAgIHZhciByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICBpZCA9IFwic2NyaXB0XCIgKyBqUXVlcnkubm93KCk7XG5cbiAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiICAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJyBzdHlsZT0nY29sb3I6cmVkO2Zsb2F0OmxlZnQ7b3BhY2l0eTouNTU7Jz5hPC9hPjxpbnB1dCB0eXBlPSdjaGVja2JveCcvPlwiO1xuXG4gICAgICAgIHZhciBhbGwgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLFxuICAgICAgICAgICAgYSA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIilbMF0sXG4gICAgICAgICAgICBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLFxuICAgICAgICAgICAgb3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpO1xuXG4gICAgICAgIC8vIENhbid0IGdldCBiYXNpYyB0ZXN0IHN1cHBvcnRcbiAgICAgICAgaWYgKCFhbGwgfHwgIWFsbC5sZW5ndGggfHwgIWEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGpRdWVyeS5zdXBwb3J0ID0ge1xuICAgICAgICAgICAgLy8gSUUgc3RyaXBzIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVuIC5pbm5lckhUTUwgaXMgdXNlZFxuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2U6IGRpdi5maXJzdENoaWxkLm5vZGVUeXBlID09PSAzLFxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0Ym9keSBlbGVtZW50cyBhcmVuJ3QgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gSUUgd2lsbCBpbnNlcnQgdGhlbSBpbnRvIGVtcHR5IHRhYmxlc1xuICAgICAgICAgICAgdGJvZHk6ICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKS5sZW5ndGgsXG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxpbmsgZWxlbWVudHMgZ2V0IHNlcmlhbGl6ZWQgY29ycmVjdGx5IGJ5IGlubmVySFRNTFxuICAgICAgICAgICAgLy8gVGhpcyByZXF1aXJlcyBhIHdyYXBwZXIgZWxlbWVudCBpbiBJRVxuICAgICAgICAgICAgaHRtbFNlcmlhbGl6ZTogISFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpLmxlbmd0aCxcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBzdHlsZSBpbmZvcm1hdGlvbiBmcm9tIGdldEF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gKElFIHVzZXMgLmNzc1RleHQgaW5zdGVkKVxuICAgICAgICAgICAgc3R5bGU6IC9yZWQvLnRlc3QoYS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSksXG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IFVSTHMgYXJlbid0IG1hbmlwdWxhdGVkXG4gICAgICAgICAgICAvLyAoSUUgbm9ybWFsaXplcyBpdCBieSBkZWZhdWx0KVxuICAgICAgICAgICAgaHJlZk5vcm1hbGl6ZWQ6IGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIvYVwiLFxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBlbGVtZW50IG9wYWNpdHkgZXhpc3RzXG4gICAgICAgICAgICAvLyAoSUUgdXNlcyBmaWx0ZXIgaW5zdGVhZClcbiAgICAgICAgICAgIC8vIFVzZSBhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgV2ViS2l0IGlzc3VlLiBTZWUgIzUxNDVcbiAgICAgICAgICAgIG9wYWNpdHk6IC9eMC41NSQvLnRlc3QoYS5zdHlsZS5vcGFjaXR5KSxcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IHN0eWxlIGZsb2F0IGV4aXN0ZW5jZVxuICAgICAgICAgICAgLy8gKElFIHVzZXMgc3R5bGVGbG9hdCBpbnN0ZWFkIG9mIGNzc0Zsb2F0KVxuICAgICAgICAgICAgY3NzRmxvYXQ6ICEhYS5zdHlsZS5jc3NGbG9hdCxcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgaWYgbm8gdmFsdWUgaXMgc3BlY2lmaWVkIGZvciBhIGNoZWNrYm94XG4gICAgICAgICAgICAvLyB0aGF0IGl0IGRlZmF1bHRzIHRvIFwib25cIi5cbiAgICAgICAgICAgIC8vIChXZWJLaXQgZGVmYXVsdHMgdG8gXCJcIiBpbnN0ZWFkKVxuICAgICAgICAgICAgY2hlY2tPbjogZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF0udmFsdWUgPT09IFwib25cIixcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYSBzZWxlY3RlZC1ieS1kZWZhdWx0IG9wdGlvbiBoYXMgYSB3b3JraW5nIHNlbGVjdGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gKFdlYktpdCBkZWZhdWx0cyB0byBmYWxzZSBpbnN0ZWFkIG9mIHRydWUsIElFIHRvbywgaWYgaXQncyBpbiBhbiBvcHRncm91cClcbiAgICAgICAgICAgIG9wdFNlbGVjdGVkOiBvcHQuc2VsZWN0ZWQsXG5cbiAgICAgICAgICAgIC8vIFdpbGwgYmUgZGVmaW5lZCBsYXRlclxuICAgICAgICAgICAgb3B0RGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2hlY2tDbG9uZTogZmFsc2UsXG4gICAgICAgICAgICBzY3JpcHRFdmFsOiBmYWxzZSxcbiAgICAgICAgICAgIG5vQ2xvbmVFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGJveE1vZGVsOiBudWxsLFxuICAgICAgICAgICAgaW5saW5lQmxvY2tOZWVkc0xheW91dDogZmFsc2UsXG4gICAgICAgICAgICBzaHJpbmtXcmFwQmxvY2tzOiBmYWxzZSxcbiAgICAgICAgICAgIHJlbGlhYmxlSGlkZGVuT2Zmc2V0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBvcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZW4ndCBtYXJrZWQgYXMgZGlzYWJsZWRcbiAgICAgICAgLy8gKFdlYktpdCBtYXJrcyB0aGVtIGFzIGRpYWJsZWQpXG4gICAgICAgIHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGpRdWVyeS5zdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ3aW5kb3cuXCIgKyBpZCArIFwiPTE7XCIpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICAgICAgcm9vdC5pbnNlcnRCZWZvcmUoc2NyaXB0LCByb290LmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBleGVjdXRpb24gb2YgY29kZSB3b3JrcyBieSBpbmplY3RpbmcgYSBzY3JpcHRcbiAgICAgICAgLy8gdGFnIHdpdGggYXBwZW5kQ2hpbGQvY3JlYXRlVGV4dE5vZGVcbiAgICAgICAgLy8gKElFIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzLCBmYWlscywgYW5kIHVzZXMgLnRleHQgaW5zdGVhZClcbiAgICAgICAgaWYgKHdpbmRvd1tpZF0pIHtcbiAgICAgICAgICAgIGpRdWVyeS5zdXBwb3J0LnNjcmlwdEV2YWwgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1tpZF07XG4gICAgICAgIH1cblxuICAgICAgICByb290LnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cbiAgICAgICAgaWYgKGRpdi5hdHRhY2hFdmVudCAmJiBkaXYuZmlyZUV2ZW50KSB7XG4gICAgICAgICAgICBkaXYuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsIGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICAgICAgICAgIC8vIENsb25pbmcgYSBub2RlIHNob3VsZG4ndCBjb3B5IG92ZXIgYW55XG4gICAgICAgICAgICAgICAgLy8gYm91bmQgZXZlbnQgaGFuZGxlcnMgKElFIGRvZXMgdGhpcylcbiAgICAgICAgICAgICAgICBqUXVlcnkuc3VwcG9ydC5ub0Nsb25lRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkaXYuZGV0YWNoRXZlbnQoXCJvbmNsaWNrXCIsIGNsaWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGl2LmNsb25lTm9kZSh0cnVlKS5maXJlRXZlbnQoXCJvbmNsaWNrXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGlucHV0IHR5cGU9J3JhZGlvJyBuYW1lPSdyYWRpb3Rlc3QnIGNoZWNrZWQ9J2NoZWNrZWQnLz5cIjtcblxuICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdi5maXJzdENoaWxkKTtcblxuICAgICAgICAvLyBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcbiAgICAgICAgalF1ZXJ5LnN1cHBvcnQuY2hlY2tDbG9uZSA9IGZyYWdtZW50LmNsb25lTm9kZSh0cnVlKS5jbG9uZU5vZGUodHJ1ZSkubGFzdENoaWxkLmNoZWNrZWQ7XG5cbiAgICAgICAgLy8gRmlndXJlIG91dCBpZiB0aGUgVzNDIGJveCBtb2RlbCB3b3JrcyBhcyBleHBlY3RlZFxuICAgICAgICAvLyBkb2N1bWVudC5ib2R5IG11c3QgZXhpc3QgYmVmb3JlIHdlIGNhbiBkbyB0aGlzXG4gICAgICAgIGpRdWVyeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiMXB4XCI7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgIGpRdWVyeS5ib3hNb2RlbCA9IGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsID0gZGl2Lm9mZnNldFdpZHRoID09PSAyO1xuXG4gICAgICAgICAgICBpZiAoXCJ6b29tXCIgaW4gZGl2LnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbmF0aXZlbHkgYmxvY2stbGV2ZWwgZWxlbWVudHMgYWN0IGxpa2UgaW5saW5lLWJsb2NrXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudHMgd2hlbiBzZXR0aW5nIHRoZWlyIGRpc3BsYXkgdG8gJ2lubGluZScgYW5kIGdpdmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZW0gbGF5b3V0XG4gICAgICAgICAgICAgICAgLy8gKElFIDwgOCBkb2VzIHRoaXMpXG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZVwiO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS56b29tID0gMTtcbiAgICAgICAgICAgICAgICBqUXVlcnkuc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0ID0gZGl2Lm9mZnNldFdpZHRoID09PSAyO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudHMgd2l0aCBsYXlvdXQgc2hyaW5rLXdyYXAgdGhlaXIgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAvLyAoSUUgNiBkb2VzIHRoaXMpXG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgc3R5bGU9J3dpZHRoOjRweDsnPjwvZGl2PlwiO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3MgPSBkaXYub2Zmc2V0V2lkdGggIT09IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjx0YWJsZT48dHI+PHRkIHN0eWxlPSdwYWRkaW5nOjA7ZGlzcGxheTpub25lJz48L3RkPjx0ZD50PC90ZD48L3RyPjwvdGFibGU+XCI7XG4gICAgICAgICAgICB2YXIgdGRzID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0IHdoZW4gdGhleSBhcmUgc2V0XG4gICAgICAgICAgICAvLyB0byBkaXNwbGF5Om5vbmUgYW5kIHRoZXJlIGFyZSBzdGlsbCBvdGhlciB2aXNpYmxlIHRhYmxlIGNlbGxzIGluIGFcbiAgICAgICAgICAgIC8vIHRhYmxlIHJvdzsgaWYgc28sIG9mZnNldFdpZHRoL0hlaWdodCBhcmUgbm90IHJlbGlhYmxlIGZvciB1c2Ugd2hlblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5pbmcgaWYgYW4gZWxlbWVudCBoYXMgYmVlbiBoaWRkZW4gZGlyZWN0bHkgdXNpbmdcbiAgICAgICAgICAgIC8vIGRpc3BsYXk6bm9uZSAoaXQgaXMgc3RpbGwgc2FmZSB0byB1c2Ugb2Zmc2V0cyBpZiBhIHBhcmVudCBlbGVtZW50IGlzXG4gICAgICAgICAgICAvLyBoaWRkZW47IGRvbiBzYWZldHkgZ29nZ2xlcyBhbmQgc2VlIGJ1ZyAjNDUxMiBmb3IgbW9yZSBpbmZvcm1hdGlvbikuXG4gICAgICAgICAgICAvLyAob25seSBJRSA4IGZhaWxzIHRoaXMgdGVzdClcbiAgICAgICAgICAgIGpRdWVyeS5zdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyA9IHRkc1swXS5vZmZzZXRIZWlnaHQgPT09IDA7XG5cbiAgICAgICAgICAgIHRkc1swXS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICAgIHRkc1sxXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGVtcHR5IHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0XG4gICAgICAgICAgICAvLyAoSUUgPCA4IGZhaWwgdGhpcyB0ZXN0KVxuICAgICAgICAgICAgalF1ZXJ5LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzID0galF1ZXJ5LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzICYmIHRkc1swXS5vZmZzZXRIZWlnaHQgPT09IDA7XG4gICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIGRpdiA9IHRkcyA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRlY2huaXF1ZSBmcm9tIEp1cml5IFpheXRzZXZcbiAgICAgICAgLy8gaHR0cDovL3RoaW5rd2ViMi5jb20vcHJvamVjdHMvcHJvdG90eXBlL2RldGVjdGluZy1ldmVudC1zdXBwb3J0LXdpdGhvdXQtYnJvd3Nlci1zbmlmZmluZy9cbiAgICAgICAgdmFyIGV2ZW50U3VwcG9ydGVkID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IFwib25cIiArIGV2ZW50TmFtZTtcblxuICAgICAgICAgICAgdmFyIGlzU3VwcG9ydGVkID0gKGV2ZW50TmFtZSBpbiBlbCk7XG4gICAgICAgICAgICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgXCJyZXR1cm47XCIpO1xuICAgICAgICAgICAgICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsW2V2ZW50TmFtZV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsID0gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIGpRdWVyeS5zdXBwb3J0LnN1Ym1pdEJ1YmJsZXMgPSBldmVudFN1cHBvcnRlZChcInN1Ym1pdFwiKTtcbiAgICAgICAgalF1ZXJ5LnN1cHBvcnQuY2hhbmdlQnViYmxlcyA9IGV2ZW50U3VwcG9ydGVkKFwiY2hhbmdlXCIpO1xuXG4gICAgICAgIC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG4gICAgICAgIHJvb3QgPSBzY3JpcHQgPSBkaXYgPSBhbGwgPSBhID0gbnVsbDtcbiAgICB9KSgpO1xuXG4gICAgalF1ZXJ5LnByb3BzID0ge1xuICAgICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcbiAgICAgICAgXCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICByZWFkb25seTogXCJyZWFkT25seVwiLFxuICAgICAgICBtYXhsZW5ndGg6IFwibWF4TGVuZ3RoXCIsXG4gICAgICAgIGNlbGxzcGFjaW5nOiBcImNlbGxTcGFjaW5nXCIsXG4gICAgICAgIHJvd3NwYW46IFwicm93U3BhblwiLFxuICAgICAgICBjb2xzcGFuOiBcImNvbFNwYW5cIixcbiAgICAgICAgdGFiaW5kZXg6IFwidGFiSW5kZXhcIixcbiAgICAgICAgdXNlbWFwOiBcInVzZU1hcFwiLFxuICAgICAgICBmcmFtZWJvcmRlcjogXCJmcmFtZUJvcmRlclwiXG4gICAgfTtcblxuXG5cblxuICAgIHZhciB3aW5kb3dEYXRhID0ge30sXG4gICAgICAgIHJicmFjZSA9IC9eKD86XFx7LipcXH18XFxbLipcXF0pJC87XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgY2FjaGU6IHt9LFxuXG4gICAgICAgIC8vIFBsZWFzZSB1c2Ugd2l0aCBjYXV0aW9uXG4gICAgICAgIHV1aWQ6IDAsXG5cbiAgICAgICAgLy8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXHRcbiAgICAgICAgZXhwYW5kbzogXCJqUXVlcnlcIiArIGpRdWVyeS5ub3coKSxcblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGVsZW1lbnRzIHRocm93IHVuY2F0Y2hhYmxlIGV4Y2VwdGlvbnMgaWYgeW91XG4gICAgICAgIC8vIGF0dGVtcHQgdG8gYWRkIGV4cGFuZG8gcHJvcGVydGllcyB0byB0aGVtLlxuICAgICAgICBub0RhdGE6IHtcbiAgICAgICAgICAgIFwiZW1iZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEJhbiBhbGwgb2JqZWN0cyBleGNlcHQgZm9yIEZsYXNoICh3aGljaCBoYW5kbGUgZXhwYW5kb3MpXG4gICAgICAgICAgICBcIm9iamVjdFwiOiBcImNsc2lkOkQyN0NEQjZFLUFFNkQtMTFjZi05NkI4LTQ0NDU1MzU0MDAwMFwiLFxuICAgICAgICAgICAgXCJhcHBsZXRcIjogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWpRdWVyeS5hY2NlcHREYXRhKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtID0gZWxlbSA9PSB3aW5kb3cgP1xuICAgICAgICAgICAgICAgIHdpbmRvd0RhdGEgOlxuICAgICAgICAgICAgICAgIGVsZW07XG5cbiAgICAgICAgICAgIHZhciBpc05vZGUgPSBlbGVtLm5vZGVUeXBlLFxuICAgICAgICAgICAgICAgIGlkID0gaXNOb2RlID8gZWxlbVtqUXVlcnkuZXhwYW5kb10gOiBudWxsLFxuICAgICAgICAgICAgICAgIGNhY2hlID0galF1ZXJ5LmNhY2hlLCB0aGlzQ2FjaGU7XG5cbiAgICAgICAgICAgIGlmIChpc05vZGUgJiYgIWlkICYmIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGZyb20gdGhlIG9iamVjdCBkaXJlY3RseVxuICAgICAgICAgICAgaWYgKCFpc05vZGUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZSA9IGVsZW07XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGEgdW5pcXVlIElEIGZvciB0aGUgZWxlbWVudFxuICAgICAgICAgICAgfSBlbHNlIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtW2pRdWVyeS5leHBhbmRvXSA9IGlkID0gKytqUXVlcnkudXVpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXZvaWQgZ2VuZXJhdGluZyBhIG5ldyBjYWNoZSB1bmxlc3Mgbm9uZSBleGlzdHMgYW5kIHdlXG4gICAgICAgICAgICAvLyB3YW50IHRvIG1hbmlwdWxhdGUgaXQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlW2lkXSA9IGpRdWVyeS5leHRlbmQoY2FjaGVbaWRdLCBuYW1lKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoY2FjaGUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUgJiYgIWNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlW2lkXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzQ2FjaGUgPSBpc05vZGUgPyBjYWNoZVtpZF0gOiBjYWNoZTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBvdmVycmlkaW5nIHRoZSBuYW1lZCBjYWNoZSB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzQ2FjaGVbbmFtZV0gPSBkYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgPyB0aGlzQ2FjaGVbbmFtZV0gOiB0aGlzQ2FjaGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghalF1ZXJ5LmFjY2VwdERhdGEoZWxlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW0gPSBlbGVtID09IHdpbmRvdyA/XG4gICAgICAgICAgICAgICAgd2luZG93RGF0YSA6XG4gICAgICAgICAgICAgICAgZWxlbTtcblxuICAgICAgICAgICAgdmFyIGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG4gICAgICAgICAgICAgICAgaWQgPSBpc05vZGUgPyBlbGVtW2pRdWVyeS5leHBhbmRvXSA6IGVsZW0sXG4gICAgICAgICAgICAgICAgY2FjaGUgPSBqUXVlcnkuY2FjaGUsXG4gICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gaXNOb2RlID8gY2FjaGVbaWRdIDogaWQ7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIHdhbnQgdG8gcmVtb3ZlIGEgc3BlY2lmaWMgc2VjdGlvbiBvZiB0aGUgZWxlbWVudCdzIGRhdGFcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlY3Rpb24gb2YgY2FjaGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpc0NhY2hlW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlbW92ZWQgYWxsIHRoZSBkYXRhLCByZW1vdmUgdGhlIGVsZW1lbnQncyBjYWNoZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KHRoaXNDYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVEYXRhKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSB3YW50IHRvIHJlbW92ZSBhbGwgb2YgdGhlIGVsZW1lbnQncyBkYXRhXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc05vZGUgJiYgalF1ZXJ5LnN1cHBvcnQuZGVsZXRlRXhwYW5kbykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbVtqUXVlcnkuZXhwYW5kb107XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0ucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGpRdWVyeS5leHBhbmRvKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wbGV0ZWx5IHJlbW92ZSB0aGUgZGF0YSBjYWNoZVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtpZF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBmaWVsZHMgZnJvbSB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbVtuXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBET00gbm9kZSBjYW4gaGFuZGxlIHRoZSBkYXRhIGV4cGFuZG9cbiAgICAgICAgYWNjZXB0RGF0YTogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0galF1ZXJ5Lm5vRGF0YVtlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKG1hdGNoID09PSB0cnVlIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NpZFwiKSAhPT0gbWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBkYXRhOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPyBqUXVlcnkuZGF0YSh0aGlzWzBdKSA6IG51bGw7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSh0aGlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXSA/IFwiLlwiICsgcGFydHNbMV0gOiBcIlwiO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy50cmlnZ2VySGFuZGxlcihcImdldERhdGFcIiArIHBhcnRzWzFdICsgXCIhXCIsIFtwYXJ0c1swXV0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZldGNoIGFueSBpbnRlcm5hbGx5IHN0b3JlZCBkYXRhIGZpcnN0XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0galF1ZXJ5LmRhdGEodGhpc1swXSwga2V5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG4gICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkICYmIHRoaXNbMF0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzWzBdLmdldEF0dHJpYnV0ZShcImRhdGEtXCIgKyBrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhalF1ZXJ5LmlzTmFOKGRhdGEpID8gcGFyc2VGbG9hdChkYXRhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnJhY2UudGVzdChkYXRhKSA/IGpRdWVyeS5wYXJzZUpTT04oZGF0YSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgJiYgcGFydHNbMV0gP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEocGFydHNbMF0pIDpcbiAgICAgICAgICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0galF1ZXJ5KHRoaXMpLCBhcmdzID0gW3BhcnRzWzBdLCB2YWx1ZV07XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlckhhbmRsZXIoXCJzZXREYXRhXCIgKyBwYXJ0c1sxXSArIFwiIVwiLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXJIYW5kbGVyKFwiY2hhbmdlRGF0YVwiICsgcGFydHNbMV0gKyBcIiFcIiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZURhdGEodGhpcywga2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgcXVldWU6IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHR5cGUgPSAodHlwZSB8fCBcImZ4XCIpICsgXCJxdWV1ZVwiO1xuICAgICAgICAgICAgdmFyIHEgPSBqUXVlcnkuZGF0YShlbGVtLCB0eXBlKTtcblxuICAgICAgICAgICAgLy8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEgfHwgW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcSB8fCBqUXVlcnkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHEgPSBqUXVlcnkuZGF0YShlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KGRhdGEpKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBxO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlcXVldWU6IGZ1bmN0aW9uIChlbGVtLCB0eXBlKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZShlbGVtLCB0eXBlKSwgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG4gICAgICAgICAgICBpZiAoZm4gPT09IFwiaW5wcm9ncmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZ4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUudW5zaGlmdChcImlucHJvZ3Jlc3NcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm4uY2FsbChlbGVtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKGVsZW0sIHR5cGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgcXVldWU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdHlwZTtcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJmeFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5xdWV1ZSh0aGlzWzBdLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUodGhpcywgdHlwZSwgZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuICAgICAgICAvLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG4gICAgICAgIGRlbGF5OiBmdW5jdGlvbiAodGltZSwgdHlwZSkge1xuICAgICAgICAgICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbdGltZV0gfHwgdGltZSA6IHRpbWU7XG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKHR5cGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKGVsZW0sIHR5cGUpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKHR5cGUgfHwgXCJmeFwiLCBbXSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIHZhciByY2xhc3MgPSAvW1xcblxcdF0vZyxcbiAgICAgICAgcnNwYWNlcyA9IC9cXHMrLyxcbiAgICAgICAgcnJldHVybiA9IC9cXHIvZyxcbiAgICAgICAgcnNwZWNpYWx1cmwgPSAvXig/OmhyZWZ8c3JjfHN0eWxlKSQvLFxuICAgICAgICBydHlwZSA9IC9eKD86YnV0dG9ufGlucHV0KSQvaSxcbiAgICAgICAgcmZvY3VzYWJsZSA9IC9eKD86YnV0dG9ufGlucHV0fG9iamVjdHxzZWxlY3R8dGV4dGFyZWEpJC9pLFxuICAgICAgICByY2xpY2thYmxlID0gL15hKD86cmVhKT8kL2ksXG4gICAgICAgIHJyYWRpb2NoZWNrID0gL14oPzpyYWRpb3xjaGVja2JveCkkL2k7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFjY2Vzcyh0aGlzLCBuYW1lLCB2YWx1ZSwgdHJ1ZSwgalF1ZXJ5LmF0dHIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmF0dHIodGhpcywgbmFtZSwgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBpLCBzZWxmLmF0dHIoXCJjbGFzc1wiKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAodmFsdWUgfHwgXCJcIikuc3BsaXQocnNwYWNlcyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiwgc2V0Q2xhc3MgPSBlbGVtLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgY2wgPSBjbGFzc05hbWVzLmxlbmd0aDsgYyA8IGNsOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKFwiIFwiICsgY2xhc3NOYW1lc1tjXSArIFwiIFwiKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENsYXNzICs9IFwiIFwiICsgY2xhc3NOYW1lc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGpRdWVyeS50cmltKHNldENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBpLCBzZWxmLmF0dHIoXCJjbGFzc1wiKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gKHZhbHVlIHx8IFwiXCIpLnNwbGl0KHJzcGFjZXMpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgZWxlbS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAoXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwLCBjbCA9IGNsYXNzTmFtZXMubGVuZ3RoOyBjIDwgY2w7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZShcIiBcIiArIGNsYXNzTmFtZXNbY10gKyBcIiBcIiwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGpRdWVyeS50cmltKGNsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZVZhbCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsIGlzQm9vbCA9IHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCI7XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnRvZ2dsZUNsYXNzKHZhbHVlLmNhbGwodGhpcywgaSwgc2VsZi5hdHRyKFwiY2xhc3NcIiksIHN0YXRlVmFsKSwgc3RhdGVWYWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lLCBpID0gMCwgc2VsZiA9IGpRdWVyeSh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVWYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQocnNwYWNlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGFzc05hbWUgPSBjbGFzc05hbWVzW2krK10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwZXJhdGVkIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gaXNCb29sID8gc3RhdGUgOiAhc2VsZi5oYXNDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZltzdGF0ZSA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEodGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZ2dsZSB3aG9sZSBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogalF1ZXJ5LmRhdGEodGhpcywgXCJfX2NsYXNzTmFtZV9fXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKFwiIFwiICsgdGhpc1tpXS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZShyY2xhc3MsIFwiIFwiKS5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcIm9wdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlcy52YWx1ZSBpcyB1bmRlZmluZWQgaW4gQmxhY2tiZXJyeSA0LjcgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VzIC52YWx1ZS4gU2VlICM2OTMyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZWxlbS5hdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF2YWwgfHwgdmFsLnNwZWNpZmllZCA/IGVsZW0udmFsdWUgOiBlbGVtLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGhhbmRsZSBzZWxlY3QgYm94ZXMgc3BlY2lhbFxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwic2VsZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHdhcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gb25lID8gaW5kZXggOiAwLCBtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAmJiAoalF1ZXJ5LnN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09PSBudWxsKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUob3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIikpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeShvcHRpb24pLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgaW4gV2Via2l0IFwiXCIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBcIm9uXCIgaWYgYSB2YWx1ZSBpc24ndCBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJyYWRpb2NoZWNrLnRlc3QoZWxlbS50eXBlKSAmJiAhalF1ZXJ5LnN1cHBvcnQuY2hlY2tPbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UsIHdlIGp1c3QgZ3JhYiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLnZhbHVlIHx8IFwiXCIpLnJlcGxhY2UocnJldHVybiwgXCJcIik7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLCB2YWwgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZS5jYWxsKHRoaXMsIGksIHNlbGYudmFsKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqUXVlcnkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KHZhbCkgJiYgcnJhZGlvY2hlY2sudGVzdCh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KHNlbGYudmFsKCksIHZhbCkgPj0gMDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoalF1ZXJ5Lm5vZGVOYW1lKHRoaXMsIFwic2VsZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KHZhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KFwib3B0aW9uXCIsIHRoaXMpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KGpRdWVyeSh0aGlzKS52YWwoKSwgdmFsdWVzKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgYXR0ckZuOiB7XG4gICAgICAgICAgICB2YWw6IHRydWUsXG4gICAgICAgICAgICBjc3M6IHRydWUsXG4gICAgICAgICAgICBodG1sOiB0cnVlLFxuICAgICAgICAgICAgdGV4dDogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHRydWUsXG4gICAgICAgICAgICB3aWR0aDogdHJ1ZSxcbiAgICAgICAgICAgIGhlaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSwgcGFzcykge1xuICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXNzICYmIG5hbWUgaW4galF1ZXJ5LmF0dHJGbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkoZWxlbSlbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm90eG1sID0gZWxlbS5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pLFxuICAgICAgICAgICAgICAgIC8vIFdoZXRoZXIgd2UgYXJlIHNldHRpbmcgKG9yIGdldHRpbmcpXG4gICAgICAgICAgICAgICAgc2V0ID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLy8gVHJ5IHRvIG5vcm1hbGl6ZS9maXggdGhlIG5hbWVcbiAgICAgICAgICAgIG5hbWUgPSBub3R4bWwgJiYgalF1ZXJ5LnByb3BzW25hbWVdIHx8IG5hbWU7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgZG8gYWxsIHRoZSBmb2xsb3dpbmcgaWYgdGhpcyBpcyBhIG5vZGUgKGZhc3RlciBmb3Igc3R5bGUpXG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGF0dHJpYnV0ZXMgcmVxdWlyZSBzcGVjaWFsIHRyZWF0bWVudFxuICAgICAgICAgICAgICAgIHZhciBzcGVjaWFsID0gcnNwZWNpYWx1cmwudGVzdChuYW1lKTtcblxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBtaXMtcmVwb3J0cyB0aGUgZGVmYXVsdCBzZWxlY3RlZCBwcm9wZXJ0eSBvZiBhbiBvcHRpb25cbiAgICAgICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhlIHBhcmVudCdzIHNlbGVjdGVkSW5kZXggcHJvcGVydHkgZml4ZXMgaXRcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJzZWxlY3RlZFwiICYmICFqUXVlcnkuc3VwcG9ydC5vcHRTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgaXQgYWxzbyB3b3JrcyB3aXRoIG9wdGdyb3Vwcywgc2VlICM1NzAxXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYXBwbGljYWJsZSwgYWNjZXNzIHRoZSBhdHRyaWJ1dGUgdmlhIHRoZSBET00gMCB3YXlcbiAgICAgICAgICAgICAgICAvLyAnaW4nIGNoZWNrcyBmYWlsIGluIEJsYWNrYmVycnkgNC43ICM2OTMxXG4gICAgICAgICAgICAgICAgaWYgKChuYW1lIGluIGVsZW0gfHwgZWxlbVtuYW1lXSAhPT0gdW5kZWZpbmVkKSAmJiBub3R4bWwgJiYgIXNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgYWxsb3cgdGhlIHR5cGUgcHJvcGVydHkgdG8gYmUgY2hhbmdlZCAoc2luY2UgaXQgY2F1c2VzIHByb2JsZW1zIGluIElFKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwidHlwZVwiICYmIHJ0eXBlLnRlc3QoZWxlbS5ub2RlTmFtZSkgJiYgZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVycm9yKFwidHlwZSBwcm9wZXJ0eSBjYW4ndCBiZSBjaGFuZ2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlcnMgaW5kZXggZWxlbWVudHMgYnkgaWQvbmFtZSBvbiBmb3JtcywgZ2l2ZSBwcmlvcml0eSB0byBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwiZm9ybVwiKSAmJiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJ0YWJJbmRleFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcInRhYkluZGV4XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlTm9kZSAmJiBhdHRyaWJ1dGVOb2RlLnNwZWNpZmllZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTm9kZS52YWx1ZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmZvY3VzYWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpIHx8IHJjbGlja2FibGUudGVzdChlbGVtLm5vZGVOYW1lKSAmJiBlbGVtLmhyZWYgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1bbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkuc3VwcG9ydC5zdHlsZSAmJiBub3R4bWwgJiYgbmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuY3NzVGV4dCA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSB2YWx1ZSB0byBhIHN0cmluZyAoYWxsIGJyb3dzZXJzIGRvIHRoaXMgYnV0IElFKSBzZWUgIzEwNzBcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBtaXNzaW5nIGF0dHJpYnV0ZXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIC8vIEJsYWNrYmVycnkgNC43IHJldHVybnMgXCJcIiBmcm9tIGdldEF0dHJpYnV0ZSAjNjkzOFxuICAgICAgICAgICAgICAgIGlmICghZWxlbS5hdHRyaWJ1dGVzW25hbWVdICYmIChlbGVtLmhhc0F0dHJpYnV0ZSAmJiAhZWxlbS5oYXNBdHRyaWJ1dGUobmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSAhalF1ZXJ5LnN1cHBvcnQuaHJlZk5vcm1hbGl6ZWQgJiYgbm90eG1sICYmIHNwZWNpYWwgP1xuICAgICAgICAgICAgICAgICAgICAvLyBTb21lIGF0dHJpYnV0ZXMgcmVxdWlyZSBhIHNwZWNpYWwgY2FsbCBvbiBJRVxuICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShuYW1lLCAyKSA6XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ciA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGF0dHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIHZhciBybmFtZXNwYWNlcyA9IC9cXC4oLiopJC8sXG4gICAgICAgIHJmb3JtRWxlbXMgPSAvXig/OnRleHRhcmVhfGlucHV0fHNlbGVjdCkkL2ksXG4gICAgICAgIHJwZXJpb2QgPSAvXFwuL2csXG4gICAgICAgIHJzcGFjZSA9IC8gL2csXG4gICAgICAgIHJlc2NhcGUgPSAvW15cXHdcXHMufGBdL2csXG4gICAgICAgIGZjbGVhbnVwID0gZnVuY3Rpb24gKG5tKSB7XG4gICAgICAgICAgICByZXR1cm4gbm0ucmVwbGFjZShyZXNjYXBlLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNDb3VudHMgPSB7IGZvY3VzaW46IDAsIGZvY3Vzb3V0OiAwIH07XG5cbiAgICAvKlxuICAgICAqIEEgbnVtYmVyIG9mIGhlbHBlciBmdW5jdGlvbnMgdXNlZCBmb3IgbWFuYWdpbmcgZXZlbnRzLlxuICAgICAqIE1hbnkgb2YgdGhlIGlkZWFzIGJlaGluZCB0aGlzIGNvZGUgb3JpZ2luYXRlZCBmcm9tXG4gICAgICogRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGpRdWVyeS5ldmVudCA9IHtcblxuICAgICAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIGFuIGVsZW1lbnRcbiAgICAgICAgLy8gT3JpZ2luYWwgYnkgRGVhbiBFZHdhcmRzXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3Igd2hhdGV2ZXIgcmVhc29uLCBJRSBoYXMgdHJvdWJsZSBwYXNzaW5nIHRoZSB3aW5kb3cgb2JqZWN0XG4gICAgICAgICAgICAvLyBhcm91bmQsIGNhdXNpbmcgaXQgdG8gYmUgY2xvbmVkIGluIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzV2luZG93KGVsZW0pICYmIChlbGVtICE9PSB3aW5kb3cgJiYgIWVsZW0uZnJhbWVFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGVsZW0gPSB3aW5kb3c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSByZXR1cm5GYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhhbmRsZU9iakluLCBoYW5kbGVPYmo7XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBmdW5jdGlvbiBiZWluZyBleGVjdXRlZCBoYXMgYSB1bmlxdWUgSURcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5ndWlkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZVxuICAgICAgICAgICAgdmFyIGVsZW1EYXRhID0galF1ZXJ5LmRhdGEoZWxlbSk7XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGVsZW1EYXRhIGlzIGZvdW5kIHRoZW4gd2UgbXVzdCBiZSB0cnlpbmcgdG8gYmluZCB0byBvbmUgb2YgdGhlXG4gICAgICAgICAgICAvLyBiYW5uZWQgbm9EYXRhIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIWVsZW1EYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYSBrZXkgbGVzcyBsaWtlbHkgdG8gcmVzdWx0IGluIGNvbGxpc2lvbnMgZm9yIHBsYWluIEpTIG9iamVjdHMuXG4gICAgICAgICAgICAvLyBGaXhlcyBidWcgIzcxNTAuXG4gICAgICAgICAgICB2YXIgZXZlbnRLZXkgPSBlbGVtLm5vZGVUeXBlID8gXCJldmVudHNcIiA6IFwiX19ldmVudHNfX1wiLFxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGVsZW1EYXRhW2V2ZW50S2V5XSxcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIE9uIHBsYWluIG9iamVjdHMgZXZlbnRzIGlzIGEgZm4gdGhhdCBob2xkcyB0aGUgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBwcmV2ZW50cyB0aGlzIGRhdGEgZnJvbSBiZWluZyBKU09OIHNlcmlhbGl6ZWRcbiAgICAgICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQsIGl0IGp1c3QgY29udGFpbnMgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZSA9IGV2ZW50cy5oYW5kbGU7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmV2ZW50cztcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uIHBsYWluIG9iamVjdHMsIGNyZWF0ZSBhIGZuIHRoYXQgYWN0cyBhcyB0aGUgaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSB2YWx1ZXMgdG8gYXZvaWQgSlNPTiBzZXJpYWxpemF0aW9uIG9mIGV2ZW50IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgZWxlbURhdGFbZXZlbnRLZXldID0gZWxlbURhdGEgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbURhdGEuZXZlbnRzID0gZXZlbnRzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXZlbnRIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtRGF0YS5oYW5kbGUgPSBldmVudEhhbmRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSB0cmlnZ2VyIGFuZCB3aGVuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmICFqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5oYW5kbGUuYXBwbHkoZXZlbnRIYW5kbGUuZWxlbSwgYXJndW1lbnRzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGVsZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgaGFuZGxlIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHByZXZlbnQgYSBtZW1vcnkgbGVhayB3aXRoIG5vbi1uYXRpdmUgZXZlbnRzIGluIElFLlxuICAgICAgICAgICAgZXZlbnRIYW5kbGUuZWxlbSA9IGVsZW07XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcbiAgICAgICAgICAgIC8vIGpRdWVyeSguLi4pLmJpbmQoXCJtb3VzZW92ZXIgbW91c2VvdXRcIiwgZm4pO1xuICAgICAgICAgICAgdHlwZXMgPSB0eXBlcy5zcGxpdChcIiBcIik7XG5cbiAgICAgICAgICAgIHZhciB0eXBlLCBpID0gMCwgbmFtZXNwYWNlcztcblxuICAgICAgICAgICAgd2hpbGUgKCh0eXBlID0gdHlwZXNbaSsrXSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVPYmpJbiA/XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoe30sIGhhbmRsZU9iakluKSA6XG4gICAgICAgICAgICAgICAgICAgIHsgaGFuZGxlcjogaGFuZGxlciwgZGF0YTogZGF0YSB9O1xuXG4gICAgICAgICAgICAgICAgLy8gTmFtZXNwYWNlZCBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCIuXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmoubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5zbGljZSgwKS5zb3J0KCkuam9pbihcIi5cIik7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5uYW1lc3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhhbmRsZU9iai50eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZU9iai5ndWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5ndWlkID0gaGFuZGxlci5ndWlkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBsaXN0IG9mIGZ1bmN0aW9ucyBib3VuZCB0byB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdLFxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG5cbiAgICAgICAgICAgICAgICAvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlXG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHNwZWNpYWwgZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyL2F0dGFjaEV2ZW50IGlmIHRoZSBzcGVjaWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbChlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCaW5kIHRoZSBnbG9iYWwgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGV2ZW50SGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsLmFkZCkge1xuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLmFkZC5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVPYmouaGFuZGxlci5ndWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBmdW5jdGlvbiB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdFxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlT2JqKTtcblxuICAgICAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgYmVlbiB1c2VkLCBmb3IgZ2xvYmFsIHRyaWdnZXJpbmdcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZ2xvYmFsW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTnVsbGlmeSBlbGVtIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFXG4gICAgICAgICAgICBlbGVtID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnbG9iYWw6IHt9LFxuXG4gICAgICAgIC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlbGVtLCB0eXBlcywgaGFuZGxlciwgcG9zKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHJldHVybkZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0LCB0eXBlLCBmbiwgaiwgaSA9IDAsIGFsbCwgbmFtZXNwYWNlcywgbmFtZXNwYWNlLCBzcGVjaWFsLCBldmVudFR5cGUsIGhhbmRsZU9iaiwgb3JpZ1R5cGUsXG4gICAgICAgICAgICAgICAgZXZlbnRLZXkgPSBlbGVtLm5vZGVUeXBlID8gXCJldmVudHNcIiA6IFwiX19ldmVudHNfX1wiLFxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0galF1ZXJ5LmRhdGEoZWxlbSksXG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZWxlbURhdGEgJiYgZWxlbURhdGFbZXZlbnRLZXldO1xuXG4gICAgICAgICAgICBpZiAoIWVsZW1EYXRhIHx8ICFldmVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtRGF0YSA9IGV2ZW50cztcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuZXZlbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0eXBlcyBpcyBhY3R1YWxseSBhbiBldmVudCBvYmplY3QgaGVyZVxuICAgICAgICAgICAgaWYgKHR5cGVzICYmIHR5cGVzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gdHlwZXMuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICB0eXBlcyA9IHR5cGVzLnR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVuYmluZCBhbGwgZXZlbnRzIGZvciB0aGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCF0eXBlcyB8fCB0eXBlb2YgdHlwZXMgPT09IFwic3RyaW5nXCIgJiYgdHlwZXMuY2hhckF0KDApID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIHR5cGVzID0gdHlwZXMgfHwgXCJcIjtcblxuICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCB0eXBlICsgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuICAgICAgICAgICAgLy8galF1ZXJ5KC4uLikudW5iaW5kKFwibW91c2VvdmVyIG1vdXNlb3V0XCIsIGZuKTtcbiAgICAgICAgICAgIHR5cGVzID0gdHlwZXMuc3BsaXQoXCIgXCIpO1xuXG4gICAgICAgICAgICB3aGlsZSAoKHR5cGUgPSB0eXBlc1tpKytdKSkge1xuICAgICAgICAgICAgICAgIG9yaWdUeXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBudWxsO1xuICAgICAgICAgICAgICAgIGFsbCA9IHR5cGUuaW5kZXhPZihcIi5cIikgPCAwO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICghYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVzcGFjZWQgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWFwKG5hbWVzcGFjZXMuc2xpY2UoMCkuc29ydCgpLCBmY2xlYW51cCkuam9pbihcIlxcXFwuKD86LipcXFxcLik/XCIpICsgXCIoXFxcXC58JClcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBldmVudFR5cGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGV2ZW50VHlwZVtqXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbCB8fCBuYW1lc3BhY2UudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgb3JpZ1R5cGUsIGhhbmRsZU9iai5oYW5kbGVyLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBwb3MgfHwgMDsgaiA8IGV2ZW50VHlwZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBldmVudFR5cGVbal07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZ2l2ZW4gaGFuZGxlciBmb3IgdGhlIGdpdmVuIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGwgfHwgbmFtZXNwYWNlLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlLnNwbGljZShqLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnJlbW92ZS5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUubGVuZ3RoID09PSAwIHx8IHBvcyAhPSBudWxsICYmIGV2ZW50VHlwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbChlbGVtLCBuYW1lc3BhY2VzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRW1wdHlPYmplY3QoZXZlbnRzKSkge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGU7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuZWxlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1EYXRhLmV2ZW50cztcbiAgICAgICAgICAgICAgICBkZWxldGUgZWxlbURhdGEuaGFuZGxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtRGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVEYXRhKGVsZW0sIGV2ZW50S2V5KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoalF1ZXJ5LmlzRW1wdHlPYmplY3QoZWxlbURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVEYXRhKGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBidWJibGluZyBpcyBpbnRlcm5hbFxuICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbiAoZXZlbnQsIGRhdGEsIGVsZW0gLyosIGJ1YmJsaW5nICovKSB7XG4gICAgICAgICAgICAvLyBFdmVudCBvYmplY3Qgb3IgZXZlbnQgdHlwZVxuICAgICAgICAgICAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50LFxuICAgICAgICAgICAgICAgIGJ1YmJsaW5nID0gYXJndW1lbnRzWzNdO1xuXG4gICAgICAgICAgICBpZiAoIWJ1YmJsaW5nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgP1xuICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkuRXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50W2pRdWVyeS5leHBhbmRvXSA/IGV2ZW50IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKGpRdWVyeS5FdmVudCh0eXBlKSwgZXZlbnQpIDpcbiAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCB0aGUgZXZlbnQgdHlwZSAoc3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuRXZlbnQodHlwZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZS5pbmRleE9mKFwiIVwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSB0eXBlID0gdHlwZS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmV4Y2x1c2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGEgZ2xvYmFsIHRyaWdnZXJcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnViYmxlIGN1c3RvbSBldmVudHMgd2hlbiBnbG9iYWwgKHRvIGF2b2lkIHRvbyBtdWNoIG92ZXJoZWFkKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgaWYgd2UndmUgZXZlciBib3VuZCBhbiBldmVudCBmb3IgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5ldmVudC5nbG9iYWxbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKGpRdWVyeS5jYWNoZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cyAmJiB0aGlzLmV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihldmVudCwgZGF0YSwgdGhpcy5oYW5kbGUuZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdHJpZ2dlcmluZyBhIHNpbmdsZSBlbGVtZW50XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgIGlmICghZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBpbiBjYXNlIGl0IGlzIHJldXNlZFxuICAgICAgICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSBlbGVtO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGluY29taW5nIGRhdGEsIGlmIGFueVxuICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkubWFrZUFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIGRhdGEudW5zaGlmdChldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbGVtO1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBldmVudCwgaXQgaXMgYXNzdW1lZCB0aGF0IFwiaGFuZGxlXCIgaXMgYSBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGVsZW0ubm9kZVR5cGUgP1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKGVsZW0sIFwiaGFuZGxlXCIpIDpcbiAgICAgICAgICAgICAgICAoalF1ZXJ5LmRhdGEoZWxlbSwgXCJfX2V2ZW50c19fXCIpIHx8IHt9KS5oYW5kbGU7XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGUuYXBwbHkoZWxlbSwgZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUgfHwgZWxlbS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGFuIGlubGluZSBib3VuZCBzY3JpcHRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGpRdWVyeS5ub0RhdGFbZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1bXCJvblwiICsgdHlwZV0gJiYgZWxlbVtcIm9uXCIgKyB0eXBlXS5hcHBseShlbGVtLCBkYXRhKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBhbiBlcnJvciBmb3Igc29tZSBlbGVtZW50cyB3aXRoIHNvbWUgZXZlbnQgdHlwZXMsIHNlZSAjMzUzM1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5saW5lRXJyb3IpIHsgfVxuXG4gICAgICAgICAgICBpZiAoIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoZXZlbnQsIGRhdGEsIHBhcmVudCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCwgb2xkLCB0YXJnZXRUeXBlID0gdHlwZS5yZXBsYWNlKHJuYW1lc3BhY2VzLCBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgaXNDbGljayA9IGpRdWVyeS5ub2RlTmFtZSh0YXJnZXQsIFwiYVwiKSAmJiB0YXJnZXRUeXBlID09PSBcImNsaWNrXCIsXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0YXJnZXRUeXBlXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIGlmICgoIXNwZWNpYWwuX2RlZmF1bHQgfHwgc3BlY2lhbC5fZGVmYXVsdC5jYWxsKGVsZW0sIGV2ZW50KSA9PT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0NsaWNrICYmICEodGFyZ2V0ICYmIHRhcmdldC5ub2RlTmFtZSAmJiBqUXVlcnkubm9EYXRhW3RhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFt0YXJnZXRUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSByZS10cmlnZ2VyIHRoZSBvbkZPTyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQgPSB0YXJnZXRbXCJvblwiICsgdGFyZ2V0VHlwZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtcIm9uXCIgKyB0YXJnZXRUeXBlXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3RhcmdldFR5cGVdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBhbiBlcnJvciBmb3Igc29tZSBlbGVtZW50cyB3aXRoIHNvbWUgZXZlbnQgdHlwZXMsIHNlZSAjMzUzM1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoICh0cmlnZ2VyRXJyb3IpIHsgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtcIm9uXCIgKyB0YXJnZXRUeXBlXSA9IG9sZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBhbGwsIGhhbmRsZXJzLCBuYW1lc3BhY2VzLCBuYW1lc3BhY2Vfc29ydCA9IFtdLCBuYW1lc3BhY2VfcmUsIGV2ZW50cywgYXJncyA9IGpRdWVyeS5tYWtlQXJyYXkoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgZXZlbnQgPSBhcmdzWzBdID0galF1ZXJ5LmV2ZW50LmZpeChldmVudCB8fCB3aW5kb3cuZXZlbnQpO1xuICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIE5hbWVzcGFjZWQgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgIGFsbCA9IGV2ZW50LnR5cGUuaW5kZXhPZihcIi5cIikgPCAwICYmICFldmVudC5leGNsdXNpdmU7XG5cbiAgICAgICAgICAgIGlmICghYWxsKSB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IGV2ZW50LnR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlX3NvcnQgPSBuYW1lc3BhY2VzLnNsaWNlKDApLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VfcmUgPSBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2Vfc29ydC5qb2luKFwiXFxcXC4oPzouKlxcXFwuKT9cIikgKyBcIihcXFxcLnwkKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQubmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlIHx8IG5hbWVzcGFjZV9zb3J0LmpvaW4oXCIuXCIpO1xuXG4gICAgICAgICAgICBldmVudHMgPSBqUXVlcnkuZGF0YSh0aGlzLCB0aGlzLm5vZGVUeXBlID8gXCJldmVudHNcIiA6IFwiX19ldmVudHNfX1wiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5ldmVudHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZXJzID0gKGV2ZW50cyB8fCB7fSlbZXZlbnQudHlwZV07XG5cbiAgICAgICAgICAgIGlmIChldmVudHMgJiYgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgaGFuZGxlcnMgdG8gcHJldmVudCBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGhhbmRsZXJzLnNsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciB0aGUgZnVuY3Rpb25zIGJ5IGNsYXNzXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGwgfHwgbmFtZXNwYWNlX3JlLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgaW4gYSByZWZlcmVuY2UgdG8gdGhlIGhhbmRsZXIgZnVuY3Rpb24gaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbyB0aGF0IHdlIGNhbiBsYXRlciByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmhhbmRsZXIgPSBoYW5kbGVPYmouaGFuZGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5yZXN1bHQgPSByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHByb3BzOiBcImFsdEtleSBhdHRyQ2hhbmdlIGF0dHJOYW1lIGJ1YmJsZXMgYnV0dG9uIGNhbmNlbGFibGUgY2hhckNvZGUgY2xpZW50WCBjbGllbnRZIGN0cmxLZXkgY3VycmVudFRhcmdldCBkYXRhIGRldGFpbCBldmVudFBoYXNlIGZyb21FbGVtZW50IGhhbmRsZXIga2V5Q29kZSBsYXllclggbGF5ZXJZIG1ldGFLZXkgbmV3VmFsdWUgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHByZXZWYWx1ZSByZWxhdGVkTm9kZSByZWxhdGVkVGFyZ2V0IHNjcmVlblggc2NyZWVuWSBzaGlmdEtleSBzcmNFbGVtZW50IHRhcmdldCB0b0VsZW1lbnQgdmlldyB3aGVlbERlbHRhIHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG4gICAgICAgIGZpeDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRbalF1ZXJ5LmV4cGFuZG9dKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdG9yZSBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgLy8gYW5kIFwiY2xvbmVcIiB0byBzZXQgcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBldmVudCA9IGpRdWVyeS5FdmVudChvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucHJvcHMubGVuZ3RoLCBwcm9wOyBpOykge1xuICAgICAgICAgICAgICAgIHByb3AgPSB0aGlzLnByb3BzWy0taV07XG4gICAgICAgICAgICAgICAgZXZlbnRbcHJvcF0gPSBvcmlnaW5hbEV2ZW50W3Byb3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXggdGFyZ2V0IHByb3BlcnR5LCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDsgLy8gRml4ZXMgIzE5MjUgd2hlcmUgc3JjRWxlbWVudCBtaWdodCBub3QgYmUgZGVmaW5lZCBlaXRoZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGFyZ2V0IGlzIGEgdGV4dG5vZGUgKHNhZmFyaSlcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHJlbGF0ZWRUYXJnZXQsIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0ICYmIGV2ZW50LmZyb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKGV2ZW50LnBhZ2VYID09IG51bGwgJiYgZXZlbnQuY2xpZW50WCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucGFnZVkgPSBldmVudC5jbGllbnRZICsgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG4gICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT0gbnVsbCAmJiAoZXZlbnQuY2hhckNvZGUgIT0gbnVsbCB8fCBldmVudC5rZXlDb2RlICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQud2hpY2ggPSBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgbWV0YUtleSB0byBub24tTWFjIGJyb3dzZXJzICh1c2UgY3RybCBmb3IgUEMncyBhbmQgTWV0YSBmb3IgTWFjcylcbiAgICAgICAgICAgIGlmICghZXZlbnQubWV0YUtleSAmJiBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQubWV0YUtleSA9IGV2ZW50LmN0cmxLZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcbiAgICAgICAgICAgIC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG4gICAgICAgICAgICBpZiAoIWV2ZW50LndoaWNoICYmIGV2ZW50LmJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQud2hpY2ggPSAoZXZlbnQuYnV0dG9uICYgMSA/IDEgOiAoZXZlbnQuYnV0dG9uICYgMiA/IDMgOiAoZXZlbnQuYnV0dG9uICYgNCA/IDIgOiAwKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGVwcmVjYXRlZCwgdXNlIGpRdWVyeS5ndWlkIGluc3RlYWRcbiAgICAgICAgZ3VpZDogMUU4LFxuXG4gICAgICAgIC8vIERlcHJlY2F0ZWQsIHVzZSBqUXVlcnkucHJveHkgaW5zdGVhZFxuICAgICAgICBwcm94eTogalF1ZXJ5LnByb3h5LFxuXG4gICAgICAgIHNwZWNpYWw6IHtcbiAgICAgICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZWFkeSBldmVudCBpcyBzZXR1cFxuICAgICAgICAgICAgICAgIHNldHVwOiBqUXVlcnkuYmluZFJlYWR5LFxuICAgICAgICAgICAgICAgIHRlYXJkb3duOiBqUXVlcnkubm9vcFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbGl2ZToge1xuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKGhhbmRsZU9iaikge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXZlQ29udmVydChoYW5kbGVPYmoub3JpZ1R5cGUsIGhhbmRsZU9iai5zZWxlY3RvciksXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHt9LCBoYW5kbGVPYmosIHsgaGFuZGxlcjogbGl2ZUhhbmRsZXIsIGd1aWQ6IGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChoYW5kbGVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSh0aGlzLCBsaXZlQ29udmVydChoYW5kbGVPYmoub3JpZ1R5cGUsIGhhbmRsZU9iai5zZWxlY3RvciksIGhhbmRsZU9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmVmb3JldW5sb2FkOiB7XG4gICAgICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIChkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZG8gdGhpcyBzcGVjaWFsIGNhc2Ugb24gd2luZG93c1xuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzV2luZG93KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uYmVmb3JldW5sb2FkID0gZXZlbnRIYW5kbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uIChuYW1lc3BhY2VzLCBldmVudEhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmJlZm9yZXVubG9hZCA9PT0gZXZlbnRIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25iZWZvcmV1bmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGpRdWVyeS5yZW1vdmVFdmVudCA9IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgP1xuICAgICAgICBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgaGFuZGxlKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGhhbmRsZSkge1xuICAgICAgICAgICAgaWYgKGVsZW0uZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgIC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuICAgICAgICBpZiAoIXRoaXMucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KHNyYyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdmVudCBvYmplY3RcbiAgICAgICAgaWYgKHNyYyAmJiBzcmMudHlwZSkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG4gICAgICAgICAgICAvLyBFdmVudCB0eXBlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lU3RhbXAgaXMgYnVnZ3kgZm9yIHNvbWUgZXZlbnRzIG9uIEZpcmVmb3goIzM4NDMpXG4gICAgICAgIC8vIFNvIHdlIHdvbid0IHJlbHkgb24gdGhlIG5hdGl2ZSB2YWx1ZVxuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IGpRdWVyeS5ub3coKTtcblxuICAgICAgICAvLyBNYXJrIGl0IGFzIGZpeGVkXG4gICAgICAgIHRoaXNbalF1ZXJ5LmV4cGFuZG9dID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG4gICAgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgdGhlIHJldHVyblZhbHVlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBmYWxzZSAoSUUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICBpZiAoIWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugc2V0IHRoZSBjYW5jZWxCdWJibGUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIHRydWUgKElFKVxuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgICAgICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgICAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2VcbiAgICB9O1xuXG4gICAgLy8gQ2hlY2tzIGlmIGFuIGV2ZW50IGhhcHBlbmVkIG9uIGFuIGVsZW1lbnQgd2l0aGluIGFub3RoZXIgZWxlbWVudFxuICAgIC8vIFVzZWQgaW4galF1ZXJ5LmV2ZW50LnNwZWNpYWwubW91c2VlbnRlciBhbmQgbW91c2VsZWF2ZSBoYW5kbGVyc1xuICAgIHZhciB3aXRoaW5FbGVtZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIG1vdXNlKG92ZXJ8b3V0KSBhcmUgc3RpbGwgd2l0aGluIHRoZSBzYW1lIHBhcmVudCBlbGVtZW50XG4gICAgICAgIHZhciBwYXJlbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgICAgIC8vIEZpcmVmb3ggc29tZXRpbWVzIGFzc2lnbnMgcmVsYXRlZFRhcmdldCBhIFhVTCBlbGVtZW50XG4gICAgICAgIC8vIHdoaWNoIHdlIGNhbm5vdCBhY2Nlc3MgdGhlIHBhcmVudE5vZGUgcHJvcGVydHkgb2ZcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyYXZlcnNlIHVwIHRoZSB0cmVlXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBjb3JyZWN0IGV2ZW50IHR5cGVcbiAgICAgICAgICAgICAgICBldmVudC50eXBlID0gZXZlbnQuZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBldmVudCBpZiB3ZSBhY3R1YWxseSBqdXN0IG1vdXNlZCBvbiB0byBhIG5vbiBzdWItZWxlbWVudFxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5oYW5kbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXNzdW1pbmcgd2UndmUgbGVmdCB0aGUgZWxlbWVudCBzaW5jZSB3ZSBtb3N0IGxpa2VseSBtb3VzZWRvdmVyIGEgeHVsIGVsZW1lbnRcbiAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgfSxcblxuICAgICAgICAvLyBJbiBjYXNlIG9mIGV2ZW50IGRlbGVnYXRpb24sIHdlIG9ubHkgbmVlZCB0byByZW5hbWUgdGhlIGV2ZW50LnR5cGUsXG4gICAgICAgIC8vIGxpdmVIYW5kbGVyIHdpbGwgdGFrZSBjYXJlIG9mIHRoZSByZXN0LlxuICAgICAgICBkZWxlZ2F0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudHlwZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuaGFuZGxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAvLyBDcmVhdGUgbW91c2VlbnRlciBhbmQgbW91c2VsZWF2ZSBldmVudHNcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxuICAgIH0sIGZ1bmN0aW9uIChvcmlnLCBmaXgpIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbb3JpZ10gPSB7XG4gICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKHRoaXMsIGZpeCwgZGF0YSAmJiBkYXRhLnNlbGVjdG9yID8gZGVsZWdhdGUgOiB3aXRoaW5FbGVtZW50LCBvcmlnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKHRoaXMsIGZpeCwgZGF0YSAmJiBkYXRhLnNlbGVjdG9yID8gZGVsZWdhdGUgOiB3aXRoaW5FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIHN1Ym1pdCBkZWxlZ2F0aW9uXG4gICAgaWYgKCFqUXVlcnkuc3VwcG9ydC5zdWJtaXRCdWJibGVzKSB7XG5cbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWwuc3VibWl0ID0ge1xuICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIChkYXRhLCBuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJmb3JtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCh0aGlzLCBcImNsaWNrLnNwZWNpYWxTdWJtaXRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZS50YXJnZXQsIHR5cGUgPSBlbGVtLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHlwZSA9PT0gXCJzdWJtaXRcIiB8fCB0eXBlID09PSBcImltYWdlXCIpICYmIGpRdWVyeShlbGVtKS5jbG9zZXN0KFwiZm9ybVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmxpdmVGaXJlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJpZ2dlcihcInN1Ym1pdFwiLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKHRoaXMsIFwia2V5cHJlc3Muc3BlY2lhbFN1Ym1pdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlLnRhcmdldCwgdHlwZSA9IGVsZW0udHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlID09PSBcInRleHRcIiB8fCB0eXBlID09PSBcInBhc3N3b3JkXCIpICYmIGpRdWVyeShlbGVtKS5jbG9zZXN0KFwiZm9ybVwiKS5sZW5ndGggJiYgZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUubGl2ZUZpcmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmlnZ2VyKFwic3VibWl0XCIsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAobmFtZXNwYWNlcykge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUodGhpcywgXCIuc3BlY2lhbFN1Ym1pdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIC8vIGNoYW5nZSBkZWxlZ2F0aW9uLCBoYXBwZW5zIGhlcmUgc28gd2UgaGF2ZSBiaW5kLlxuICAgIGlmICghalF1ZXJ5LnN1cHBvcnQuY2hhbmdlQnViYmxlcykge1xuXG4gICAgICAgIHZhciBjaGFuZ2VGaWx0ZXJzLFxuXG4gICAgICAgICAgICBnZXRWYWwgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZWxlbS50eXBlLCB2YWwgPSBlbGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicmFkaW9cIiB8fCB0eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZWxlbS5jaGVja2VkO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInNlbGVjdC1tdWx0aXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGVsZW0uc2VsZWN0ZWRJbmRleCA+IC0xID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAoZWxlbS5vcHRpb25zLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIi1cIikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcIjtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGVsZW0uc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdGVzdENoYW5nZSA9IGZ1bmN0aW9uIHRlc3RDaGFuZ2UoZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZS50YXJnZXQsIGRhdGEsIHZhbDtcblxuICAgICAgICAgICAgICAgIGlmICghcmZvcm1FbGVtcy50ZXN0KGVsZW0ubm9kZU5hbWUpIHx8IGVsZW0ucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkuZGF0YShlbGVtLCBcIl9jaGFuZ2VfZGF0YVwiKTtcbiAgICAgICAgICAgICAgICB2YWwgPSBnZXRWYWwoZWxlbSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBkYXRhIHdpbGwgYmUgYWxzbyByZXRyaWV2ZWQgYnkgYmVmb3JlYWN0aXZhdGVcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlICE9PSBcImZvY3Vzb3V0XCIgfHwgZWxlbS50eXBlICE9PSBcInJhZGlvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEoZWxlbSwgXCJfY2hhbmdlX2RhdGFcIiwgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCB8fCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS50eXBlID0gXCJjaGFuZ2VcIjtcbiAgICAgICAgICAgICAgICAgICAgZS5saXZlRmlyZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlcihlLCBhcmd1bWVudHNbMV0sIGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWwuY2hhbmdlID0ge1xuICAgICAgICAgICAgZmlsdGVyczoge1xuICAgICAgICAgICAgICAgIGZvY3Vzb3V0OiB0ZXN0Q2hhbmdlLFxuXG4gICAgICAgICAgICAgICAgYmVmb3JlZGVhY3RpdmF0ZTogdGVzdENoYW5nZSxcblxuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGUudGFyZ2V0LCB0eXBlID0gZWxlbS50eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlc3RDaGFuZ2UuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgaGFzIHRvIGJlIGNhbGxlZCBiZWZvcmUgc3VibWl0XG4gICAgICAgICAgICAgICAgLy8gS2V5ZG93biB3aWxsIGJlIGNhbGxlZCBiZWZvcmUga2V5cHJlc3MsIHdoaWNoIGlzIHVzZWQgaW4gc3VibWl0LWV2ZW50IGRlbGVnYXRpb25cbiAgICAgICAgICAgICAgICBrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGUudGFyZ2V0LCB0eXBlID0gZWxlbS50eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZS5rZXlDb2RlID09PSAxMyAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwidGV4dGFyZWFcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChlLmtleUNvZGUgPT09IDMyICYmICh0eXBlID09PSBcImNoZWNrYm94XCIgfHwgdHlwZSA9PT0gXCJyYWRpb1wiKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwic2VsZWN0LW11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0Q2hhbmdlLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLy8gQmVmb3JlYWN0aXZhdGUgaGFwcGVucyBhbHNvIGJlZm9yZSB0aGUgcHJldmlvdXMgZWxlbWVudCBpcyBibHVycmVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aCB0aGlzIGV2ZW50IHlvdSBjYW4ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCBidXQgeW91IGNhbiBzdG9yZVxuICAgICAgICAgICAgICAgIC8vIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgYmVmb3JlYWN0aXZhdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKGVsZW0sIFwiX2NoYW5nZV9kYXRhXCIsIGdldFZhbChlbGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIChkYXRhLCBuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gY2hhbmdlRmlsdGVycykge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKHRoaXMsIHR5cGUgKyBcIi5zcGVjaWFsQ2hhbmdlXCIsIGNoYW5nZUZpbHRlcnNbdHlwZV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZm9ybUVsZW1zLnRlc3QodGhpcy5ub2RlTmFtZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKG5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKHRoaXMsIFwiLnNwZWNpYWxDaGFuZ2VcIik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmZvcm1FbGVtcy50ZXN0KHRoaXMubm9kZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNoYW5nZUZpbHRlcnMgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbC5jaGFuZ2UuZmlsdGVycztcblxuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgaW5wdXQgaXMgLmZvY3VzKCknZFxuICAgICAgICBjaGFuZ2VGaWx0ZXJzLmZvY3VzID0gY2hhbmdlRmlsdGVycy5iZWZvcmVhY3RpdmF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyKHR5cGUsIGVsZW0sIGFyZ3MpIHtcbiAgICAgICAgYXJnc1swXS50eXBlID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ldmVudC5oYW5kbGUuYXBwbHkoZWxlbSwgYXJncyk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbiAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uIChvcmlnLCBmaXgpIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsW2ZpeF0gPSB7XG4gICAgICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzQ291bnRzW2ZpeF0rKyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihvcmlnLCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tZm9jdXNDb3VudHNbZml4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihvcmlnLCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgICAgIGUgPSBqUXVlcnkuZXZlbnQuZml4KGUpO1xuICAgICAgICAgICAgICAgIGUudHlwZSA9IGZpeDtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoZSwgbnVsbCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZWFjaChbXCJiaW5kXCIsIFwib25lXCJdLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xuICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgZm4pIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBvYmplY3QgbGl0ZXJhbHNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0oa2V5LCBkYXRhLCB0eXBlW2tleV0sIGZuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihkYXRhKSB8fCBkYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IG5hbWUgPT09IFwib25lXCIgPyBqUXVlcnkucHJveHkoZm4sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS51bmJpbmQoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSkgOiBmbjtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwidW5sb2FkXCIgJiYgbmFtZSAhPT0gXCJvbmVcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub25lKHR5cGUsIGRhdGEsIGZuKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpc1tpXSwgdHlwZSwgaGFuZGxlciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICB1bmJpbmQ6IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG9iamVjdCBsaXRlcmFsc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmICF0eXBlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmJpbmQoa2V5LCB0eXBlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUodGhpc1tpXSwgdHlwZSwgZm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uIChzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXZlKHR5cGVzLCBkYXRhLCBmbiwgc2VsZWN0b3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIChzZWxlY3RvciwgdHlwZXMsIGZuKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuYmluZChcImxpdmVcIik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGllKHR5cGVzLCBudWxsLCBmbiwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcih0eXBlLCBkYXRhLCB0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBqUXVlcnkuRXZlbnQodHlwZSk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihldmVudCwgZGF0YSwgdGhpc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgLy8gU2F2ZSByZWZlcmVuY2UgdG8gYXJndW1lbnRzIGZvciBhY2Nlc3MgaW4gY2xvc3VyZVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGkgPSAxO1xuXG4gICAgICAgICAgICAvLyBsaW5rIGFsbCB0aGUgZnVuY3Rpb25zLCBzbyBhbnkgb2YgdGhlbSBjYW4gdW5iaW5kIHRoaXMgY2xpY2sgaGFuZGxlclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5wcm94eShmbiwgYXJnc1tpKytdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpY2soalF1ZXJ5LnByb3h5KGZuLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFRvZ2dsZSA9IChqUXVlcnkuZGF0YSh0aGlzLCBcImxhc3RUb2dnbGVcIiArIGZuLmd1aWQpIHx8IDApICUgaTtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSh0aGlzLCBcImxhc3RUb2dnbGVcIiArIGZuLmd1aWQsIGxhc3RUb2dnbGUgKyAxKTtcblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGNsaWNrcyBzdG9wXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIGFuZCBleGVjdXRlIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2xhc3RUb2dnbGVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgZmFsc2U7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaG92ZXI6IGZ1bmN0aW9uIChmbk92ZXIsIGZuT3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGZuT3ZlcikubW91c2VsZWF2ZShmbk91dCB8fCBmbk92ZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGl2ZU1hcCA9IHtcbiAgICAgICAgZm9jdXM6IFwiZm9jdXNpblwiLFxuICAgICAgICBibHVyOiBcImZvY3Vzb3V0XCIsXG4gICAgICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxuICAgIH07XG5cbiAgICBqUXVlcnkuZWFjaChbXCJsaXZlXCIsIFwiZGllXCJdLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xuICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAodHlwZXMsIGRhdGEsIGZuLCBvcmlnU2VsZWN0b3IgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8pIHtcbiAgICAgICAgICAgIHZhciB0eXBlLCBpID0gMCwgbWF0Y2gsIG5hbWVzcGFjZXMsIHByZVR5cGUsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBvcmlnU2VsZWN0b3IgfHwgdGhpcy5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gb3JpZ1NlbGVjdG9yID8gdGhpcyA6IGpRdWVyeSh0aGlzLmNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICYmICF0eXBlcy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0eXBlcykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0W25hbWVdKGtleSwgZGF0YSwgdHlwZXNba2V5XSwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikuc3BsaXQoXCIgXCIpO1xuXG4gICAgICAgICAgICB3aGlsZSAoKHR5cGUgPSB0eXBlc1tpKytdKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBybmFtZXNwYWNlcy5leGVjKHR5cGUpO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUucmVwbGFjZShybmFtZXNwYWNlcywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiaG92ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKFwibW91c2VlbnRlclwiICsgbmFtZXNwYWNlcywgXCJtb3VzZWxlYXZlXCIgKyBuYW1lc3BhY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJlVHlwZSA9IHR5cGU7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJmb2N1c1wiIHx8IHR5cGUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2gobGl2ZU1hcFt0eXBlXSArIG5hbWVzcGFjZXMpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSArIG5hbWVzcGFjZXM7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gKGxpdmVNYXBbdHlwZV0gfHwgdHlwZSkgKyBuYW1lc3BhY2VzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcImxpdmVcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaW5kIGxpdmUgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IGNvbnRleHQubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKGNvbnRleHRbal0sIFwibGl2ZS5cIiArIGxpdmVDb252ZXJ0KHR5cGUsIHNlbGVjdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGRhdGE6IGRhdGEsIHNlbGVjdG9yOiBzZWxlY3RvciwgaGFuZGxlcjogZm4sIG9yaWdUeXBlOiB0eXBlLCBvcmlnSGFuZGxlcjogZm4sIHByZVR5cGU6IHByZVR5cGUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuYmluZCBsaXZlIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC51bmJpbmQoXCJsaXZlLlwiICsgbGl2ZUNvbnZlcnQodHlwZSwgc2VsZWN0b3IpLCBmbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxpdmVIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHZhciBzdG9wLCBtYXhMZXZlbCwgZWxlbXMgPSBbXSwgc2VsZWN0b3JzID0gW10sXG4gICAgICAgICAgICByZWxhdGVkLCBtYXRjaCwgaGFuZGxlT2JqLCBlbGVtLCBqLCBpLCBsLCBkYXRhLCBjbG9zZSwgbmFtZXNwYWNlLCByZXQsXG4gICAgICAgICAgICBldmVudHMgPSBqUXVlcnkuZGF0YSh0aGlzLCB0aGlzLm5vZGVUeXBlID8gXCJldmVudHNcIiA6IFwiX19ldmVudHNfX1wiKTtcblxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuZXZlbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxuICAgICAgICBpZiAoZXZlbnQubGl2ZUZpcmVkID09PSB0aGlzIHx8ICFldmVudHMgfHwgIWV2ZW50cy5saXZlIHx8IGV2ZW50LmJ1dHRvbiAmJiBldmVudC50eXBlID09PSBcImNsaWNrXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikuam9pbihcIlxcXFwuKD86LipcXFxcLik/XCIpICsgXCIoXFxcXC58JClcIik7XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5saXZlRmlyZWQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBsaXZlID0gZXZlbnRzLmxpdmUuc2xpY2UoMCk7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpdmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGhhbmRsZU9iaiA9IGxpdmVbal07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVPYmoub3JpZ1R5cGUucmVwbGFjZShybmFtZXNwYWNlcywgXCJcIikgPT09IGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChoYW5kbGVPYmouc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpdmUuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaCA9IGpRdWVyeShldmVudC50YXJnZXQpLmNsb3Nlc3Qoc2VsZWN0b3JzLCBldmVudC5jdXJyZW50VGFyZ2V0KTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbWF0Y2gubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjbG9zZSA9IG1hdGNoW2ldO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGl2ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGxpdmVbal07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xvc2Uuc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciAmJiAoIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNsb3NlLmVsZW07XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRob3NlIHR3byBldmVudHMgcmVxdWlyZSBhZGRpdGlvbmFsIGNoZWNraW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVPYmoucHJlVHlwZSA9PT0gXCJtb3VzZWVudGVyXCIgfHwgaGFuZGxlT2JqLnByZVR5cGUgPT09IFwibW91c2VsZWF2ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLnByZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkID0galF1ZXJ5KGV2ZW50LnJlbGF0ZWRUYXJnZXQpLmNsb3Nlc3QoaGFuZGxlT2JqLnNlbGVjdG9yKVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVsYXRlZCB8fCByZWxhdGVkICE9PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtcy5wdXNoKHsgZWxlbTogZWxlbSwgaGFuZGxlT2JqOiBoYW5kbGVPYmosIGxldmVsOiBjbG9zZS5sZXZlbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlbGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG1hdGNoID0gZWxlbXNbaV07XG5cbiAgICAgICAgICAgIGlmIChtYXhMZXZlbCAmJiBtYXRjaC5sZXZlbCA+IG1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaC5lbGVtO1xuICAgICAgICAgICAgZXZlbnQuZGF0YSA9IG1hdGNoLmhhbmRsZU9iai5kYXRhO1xuICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gbWF0Y2guaGFuZGxlT2JqO1xuXG4gICAgICAgICAgICByZXQgPSBtYXRjaC5oYW5kbGVPYmoub3JpZ0hhbmRsZXIuYXBwbHkobWF0Y2guZWxlbSwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgIG1heExldmVsID0gbWF0Y2gubGV2ZWw7XG5cbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0b3A7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGl2ZUNvbnZlcnQodHlwZSwgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlICYmIHR5cGUgIT09IFwiKlwiID8gdHlwZSArIFwiLlwiIDogXCJcIikgKyBzZWxlY3Rvci5yZXBsYWNlKHJwZXJpb2QsIFwiYFwiKS5yZXBsYWNlKHJzcGFjZSwgXCImXCIpO1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcbiAgICAgICAgXCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG4gICAgICAgIFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvclwiKS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG4gICAgICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZChuYW1lLCBkYXRhLCBmbikgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIobmFtZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmF0dHJGbikge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5hdHRyRm5bbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFXG4gICAgLy8gV2luZG93IGlzbid0IGluY2x1ZGVkIHNvIGFzIG5vdCB0byB1bmJpbmQgZXhpc3RpbmcgdW5sb2FkIGV2ZW50c1xuICAgIC8vIE1vcmUgaW5mbzpcbiAgICAvLyAgLSBodHRwOi8vaXNhYWNzY2hsdWV0ZXIuY29tLzIwMDYvMTAvbXNpZS1tZW1vcnktbGVha3MvXG4gICAgaWYgKHdpbmRvdy5hdHRhY2hFdmVudCAmJiAhd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgalF1ZXJ5KHdpbmRvdykuYmluZChcInVubG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBqUXVlcnkuY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmNhY2hlW2lkXS5oYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5L0NhdGNoIGlzIHRvIGhhbmRsZSBpZnJhbWVzIGJlaW5nIHVubG9hZGVkLCBzZWUgIzQyODBcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoalF1ZXJ5LmNhY2hlW2lkXS5oYW5kbGUuZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKiFcbiAgICAgKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSAtIHYxLjBcbiAgICAgKiAgQ29weXJpZ2h0IDIwMDksIFRoZSBEb2pvIEZvdW5kYXRpb25cbiAgICAgKiAgUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCwgQlNELCBhbmQgR1BMIExpY2Vuc2VzLlxuICAgICAqICBNb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vc2l6emxlanMuY29tL1xuICAgICAqL1xuICAgIChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGNodW5rZXIgPSAvKCg/OlxcKCg/OlxcKFteKCldK1xcKXxbXigpXSspK1xcKXxcXFsoPzpcXFtbXlxcW1xcXV0qXFxdfFsnXCJdW14nXCJdKlsnXCJdfFteXFxbXFxdJ1wiXSspK1xcXXxcXFxcLnxbXiA+K34sKFxcW1xcXFxdKykrfFs+K35dKShcXHMqLFxccyopPygoPzoufFxccnxcXG4pKikvZyxcbiAgICAgICAgICAgIGRvbmUgPSAwLFxuICAgICAgICAgICAgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gZmFsc2UsXG4gICAgICAgICAgICBiYXNlSGFzRHVwbGljYXRlID0gdHJ1ZTtcblxuICAgICAgICAvLyBIZXJlIHdlIGNoZWNrIGlmIHRoZSBKYXZhU2NyaXB0IGVuZ2luZSBpcyB1c2luZyBzb21lIHNvcnQgb2ZcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIHdoZXJlIGl0IGRvZXMgbm90IGFsd2F5cyBjYWxsIG91ciBjb21wYXJpc2lvblxuICAgICAgICAvLyBmdW5jdGlvbi4gSWYgdGhhdCBpcyB0aGUgY2FzZSwgZGlzY2FyZCB0aGUgaGFzRHVwbGljYXRlIHZhbHVlLlxuICAgICAgICAvLyAgIFRodXMgZmFyIHRoYXQgaW5jbHVkZXMgR29vZ2xlIENocm9tZS5cbiAgICAgICAgWzAsIDBdLnNvcnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYmFzZUhhc0R1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBTaXp6bGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIHZhciBvcmlnQ29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0Lm5vZGVUeXBlICE9PSAxICYmIGNvbnRleHQubm9kZVR5cGUgIT09IDkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdLCBtLCBzZXQsIGNoZWNrU2V0LCBleHRyYSwgcHJ1bmUgPSB0cnVlLCBjb250ZXh0WE1MID0gU2l6emxlLmlzWE1MKGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIHNvRmFyID0gc2VsZWN0b3IsIHJldCwgY3VyLCBwb3AsIGk7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2h1bmtlciByZWdleHAgKHN0YXJ0IGZyb20gaGVhZClcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjaHVua2VyLmV4ZWMoXCJcIik7XG4gICAgICAgICAgICAgICAgbSA9IGNodW5rZXIuZXhlYyhzb0Zhcik7XG5cbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBzb0ZhciA9IG1bM107XG5cbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChtWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobVsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBtWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChtKTtcblxuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEgJiYgb3JpZ1BPUy5leGVjKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIgJiYgRXhwci5yZWxhdGl2ZVtwYXJ0c1swXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gcG9zUHJvY2VzcyhwYXJ0c1swXSArIHBhcnRzWzFdLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSBFeHByLnJlbGF0aXZlW3BhcnRzWzBdXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBbY29udGV4dF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlKHBhcnRzLnNoaWZ0KCksIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gcGFydHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEV4cHIucmVsYXRpdmVbc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgKz0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ID0gcG9zUHJvY2VzcyhzZWxlY3Rvciwgc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcbiAgICAgICAgICAgICAgICAvLyAoYnV0IG5vdCBpZiBpdCdsbCBiZSBmYXN0ZXIgaWYgdGhlIGlubmVyIHNlbGVjdG9yIGlzIGFuIElEKVxuICAgICAgICAgICAgICAgIGlmICghc2VlZCAmJiBwYXJ0cy5sZW5ndGggPiAxICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgIWNvbnRleHRYTUwgJiZcbiAgICAgICAgICAgICAgICAgICAgRXhwci5tYXRjaC5JRC50ZXN0KHBhcnRzWzBdKSAmJiAhRXhwci5tYXRjaC5JRC50ZXN0KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBTaXp6bGUuZmluZChwYXJ0cy5zaGlmdCgpLCBjb250ZXh0LCBjb250ZXh0WE1MKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHJldC5leHByID8gU2l6emxlLmZpbHRlcihyZXQuZXhwciwgcmV0LnNldClbMF0gOiByZXQuc2V0WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHNlZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBleHByOiBwYXJ0cy5wb3AoKSwgc2V0OiBtYWtlQXJyYXkoc2VlZCkgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZmluZChwYXJ0cy5wb3AoKSwgcGFydHMubGVuZ3RoID09PSAxICYmIChwYXJ0c1swXSA9PT0gXCJ+XCIgfHwgcGFydHNbMF0gPT09IFwiK1wiKSAmJiBjb250ZXh0LnBhcmVudE5vZGUgPyBjb250ZXh0LnBhcmVudE5vZGUgOiBjb250ZXh0LCBjb250ZXh0WE1MKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gcmV0LmV4cHIgPyBTaXp6bGUuZmlsdGVyKHJldC5leHByLCByZXQuc2V0KSA6IHJldC5zZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0ID0gbWFrZUFycmF5KHNldCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcnVuZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3AgPSBjdXI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghRXhwci5yZWxhdGl2ZVtjdXJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wID0gcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIEV4cHIucmVsYXRpdmVbY3VyXShjaGVja1NldCwgcG9wLCBjb250ZXh0WE1MKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0ID0gcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2hlY2tTZXQpIHtcbiAgICAgICAgICAgICAgICBjaGVja1NldCA9IHNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGVja1NldCkge1xuICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvcihjdXIgfHwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9TdHJpbmcuY2FsbChjaGVja1NldCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgICAgIGlmICghcHJ1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIGNoZWNrU2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBjaGVja1NldFtpXSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja1NldFtpXSAmJiAoY2hlY2tTZXRbaV0gPT09IHRydWUgfHwgY2hlY2tTZXRbaV0ubm9kZVR5cGUgPT09IDEgJiYgU2l6emxlLmNvbnRhaW5zKGNvbnRleHQsIGNoZWNrU2V0W2ldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc2V0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGNoZWNrU2V0W2ldICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrU2V0W2ldICYmIGNoZWNrU2V0W2ldLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNldFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ha2VBcnJheShjaGVja1NldCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgICAgIFNpenpsZShleHRyYSwgb3JpZ0NvbnRleHQsIHJlc3VsdHMsIHNlZWQpO1xuICAgICAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICBTaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoc29ydE9yZGVyKSB7XG4gICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gYmFzZUhhc0R1cGxpY2F0ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNvcnQoc29ydE9yZGVyKTtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1tpXSA9PT0gcmVzdWx0c1tpIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICBTaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChleHByLCBzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgbnVsbCwgbnVsbCwgc2V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKG5vZGUsIGV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgbnVsbCwgbnVsbCwgW25vZGVdKS5sZW5ndGggPiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpenpsZS5maW5kID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQsIGlzWE1MKSB7XG4gICAgICAgICAgICB2YXIgc2V0O1xuXG4gICAgICAgICAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gRXhwci5vcmRlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IEV4cHIub3JkZXJbaV0sIG1hdGNoO1xuXG4gICAgICAgICAgICAgICAgaWYgKChtYXRjaCA9IEV4cHIubGVmdE1hdGNoW3R5cGVdLmV4ZWMoZXhwcikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLnNwbGljZSgxLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5zdWJzdHIobGVmdC5sZW5ndGggLSAxKSAhPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdID0gKG1hdGNoWzFdIHx8IFwiXCIpLnJlcGxhY2UoL1xcXFwvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgPSBFeHByLmZpbmRbdHlwZV0obWF0Y2gsIGNvbnRleHQsIGlzWE1MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoRXhwci5tYXRjaFt0eXBlXSwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHNldDogc2V0LCBleHByOiBleHByIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgU2l6emxlLmZpbHRlciA9IGZ1bmN0aW9uIChleHByLCBzZXQsIGlucGxhY2UsIG5vdCkge1xuICAgICAgICAgICAgdmFyIG9sZCA9IGV4cHIsIHJlc3VsdCA9IFtdLCBjdXJMb29wID0gc2V0LCBtYXRjaCwgYW55Rm91bmQsXG4gICAgICAgICAgICAgICAgaXNYTUxGaWx0ZXIgPSBzZXQgJiYgc2V0WzBdICYmIFNpenpsZS5pc1hNTChzZXRbMF0pO1xuXG4gICAgICAgICAgICB3aGlsZSAoZXhwciAmJiBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBFeHByLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gRXhwci5sZWZ0TWF0Y2hbdHlwZV0uZXhlYyhleHByKSkgIT0gbnVsbCAmJiBtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IEV4cHIuZmlsdGVyW3R5cGVdLCBmb3VuZCwgaXRlbSwgbGVmdCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW55Rm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2guc3BsaWNlKDEsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5zdWJzdHIobGVmdC5sZW5ndGggLSAxKSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckxvb3AgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRXhwci5wcmVGaWx0ZXJbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IEV4cHIucHJlRmlsdGVyW3R5cGVdKG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCwgaXNYTUxGaWx0ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnlGb3VuZCA9IGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IChpdGVtID0gY3VyTG9vcFtpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZpbHRlcihpdGVtLCBtYXRjaCwgaSwgY3VyTG9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFzcyA9IG5vdCBeICEhZm91bmQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnBsYWNlICYmIGZvdW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTG9vcFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlucGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTG9vcCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gZXhwci5yZXBsYWNlKEV4cHIubWF0Y2hbdHlwZV0sIFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnlGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJbXByb3BlciBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgaWYgKGV4cHIgPT09IG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW55Rm91bmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvbGQgPSBleHByO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY3VyTG9vcDtcbiAgICAgICAgfTtcblxuICAgICAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcbiAgICAgICAgICAgIG9yZGVyOiBbXCJJRFwiLCBcIk5BTUVcIiwgXCJUQUdcIl0sXG4gICAgICAgICAgICBtYXRjaDoge1xuICAgICAgICAgICAgICAgIElEOiAvIygoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKS8sXG4gICAgICAgICAgICAgICAgQ0xBU1M6IC9cXC4oKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKykvLFxuICAgICAgICAgICAgICAgIE5BTUU6IC9cXFtuYW1lPVsnXCJdKigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKVsnXCJdKlxcXS8sXG4gICAgICAgICAgICAgICAgQVRUUjogL1xcW1xccyooKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKylcXHMqKD86KFxcUz89KVxccyooWydcIl0qKSguKj8pXFwzfClcXHMqXFxdLyxcbiAgICAgICAgICAgICAgICBUQUc6IC9eKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXCpcXC1dfFxcXFwuKSspLyxcbiAgICAgICAgICAgICAgICBDSElMRDogLzoob25seXxudGh8bGFzdHxmaXJzdCktY2hpbGQoPzpcXCgoZXZlbnxvZGR8W1xcZG4rXFwtXSopXFwpKT8vLFxuICAgICAgICAgICAgICAgIFBPUzogLzoobnRofGVxfGd0fGx0fGZpcnN0fGxhc3R8ZXZlbnxvZGQpKD86XFwoKFxcZCopXFwpKT8oPz1bXlxcLV18JCkvLFxuICAgICAgICAgICAgICAgIFBTRVVETzogLzooKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKykoPzpcXCgoWydcIl0/KSgoPzpcXChbXlxcKV0rXFwpfFteXFwoXFwpXSopKylcXDJcXCkpPy9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWZ0TWF0Y2g6IHt9LFxuICAgICAgICAgICAgYXR0ck1hcDoge1xuICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIixcbiAgICAgICAgICAgICAgICBcImZvclwiOiBcImh0bWxGb3JcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0dHJIYW5kbGU6IHtcbiAgICAgICAgICAgICAgICBocmVmOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWxhdGl2ZToge1xuICAgICAgICAgICAgICAgIFwiK1wiOiBmdW5jdGlvbiAoY2hlY2tTZXQsIHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUGFydFN0ciA9IHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUYWcgPSBpc1BhcnRTdHIgJiYgIS9cXFcvLnRlc3QocGFydCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BhcnRTdHJOb3RUYWcgPSBpc1BhcnRTdHIgJiYgIWlzVGFnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hlY2tTZXQubGVuZ3RoLCBlbGVtOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSBjaGVja1NldFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtLnByZXZpb3VzU2libGluZykgJiYgZWxlbS5ub2RlVHlwZSAhPT0gMSkgeyB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1NldFtpXSA9IGlzUGFydFN0ck5vdFRhZyB8fCBlbGVtICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gcGFydCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gfHwgZmFsc2UgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID09PSBwYXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFydFN0ck5vdFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmZpbHRlcihwYXJ0LCBjaGVja1NldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiPlwiOiBmdW5jdGlvbiAoY2hlY2tTZXQsIHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUGFydFN0ciA9IHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSwgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFydFN0ciAmJiAhL1xcVy8udGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gY2hlY2tTZXRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXRbaV0gPSBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gcGFydCA/IHBhcmVudCA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNoZWNrU2V0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0W2ldID0gaXNQYXJ0U3RyID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUgPT09IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYXJ0U3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmZpbHRlcihwYXJ0LCBjaGVja1NldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiXCI6IGZ1bmN0aW9uIChjaGVja1NldCwgcGFydCwgaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmVOYW1lID0gZG9uZSsrLCBjaGVja0ZuID0gZGlyQ2hlY2ssIG5vZGVDaGVjaztcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIgJiYgIS9cXFcvLnRlc3QocGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlQ2hlY2sgPSBwYXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGbiA9IGRpck5vZGVDaGVjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRm4oXCJwYXJlbnROb2RlXCIsIHBhcnQsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIn5cIjogZnVuY3Rpb24gKGNoZWNrU2V0LCBwYXJ0LCBpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZU5hbWUgPSBkb25lKyssIGNoZWNrRm4gPSBkaXJDaGVjaywgbm9kZUNoZWNrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAhL1xcVy8udGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVDaGVjayA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ZuID0gZGlyTm9kZUNoZWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGbihcInByZXZpb3VzU2libGluZ1wiLCBwYXJ0LCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5kOiB7XG4gICAgICAgICAgICAgICAgSUQ6IGZ1bmN0aW9uIChtYXRjaCwgY29udGV4dCwgaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbSAmJiBtLnBhcmVudE5vZGUgPyBbbV0gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgTkFNRTogZnVuY3Rpb24gKG1hdGNoLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdLCByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZShtYXRjaFsxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdWx0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1tpXS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09PSBtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChyZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQubGVuZ3RoID09PSAwID8gbnVsbCA6IHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgVEFHOiBmdW5jdGlvbiAobWF0Y2gsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVGaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICBDTEFTUzogZnVuY3Rpb24gKG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCwgaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBcIiBcIiArIG1hdGNoWzFdLnJlcGxhY2UoL1xcXFwvZywgXCJcIikgKyBcIiBcIjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGN1ckxvb3BbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90IF4gKGVsZW0uY2xhc3NOYW1lICYmIChcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoL1tcXHRcXG5dL2csIFwiIFwiKS5pbmRleE9mKG1hdGNoKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlucGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnBsYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxvb3BbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBJRDogZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgVEFHOiBmdW5jdGlvbiAobWF0Y2gsIGN1ckxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDSElMRDogZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gXCJudGhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgZXF1YXRpb25zIGxpa2UgJ2V2ZW4nLCAnb2RkJywgJzUnLCAnMm4nLCAnM24rMicsICc0bi0xJywgJy1uKzYnXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IC8oLT8pKFxcZCopbigoPzpcXCt8LSk/XFxkKikvLmV4ZWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPT09IFwiZXZlblwiICYmIFwiMm5cIiB8fCBtYXRjaFsyXSA9PT0gXCJvZGRcIiAmJiBcIjJuKzFcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEvXFxELy50ZXN0KG1hdGNoWzJdKSAmJiBcIjBuK1wiICsgbWF0Y2hbMl0gfHwgbWF0Y2hbMl0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG51bWJlcnMgKGZpcnN0KW4rKGxhc3QpIGluY2x1ZGluZyBpZiB0aGV5IGFyZSBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSAodGVzdFsxXSArICh0ZXN0WzJdIHx8IDEpKSAtIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9IHRlc3RbM10gLSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBub3JtYWwgY2FjaGluZyBzeXN0ZW1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0gPSBkb25lKys7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQVRUUjogZnVuY3Rpb24gKG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCwgaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFsxXS5yZXBsYWNlKC9cXFxcL2csIFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNYTUwgJiYgRXhwci5hdHRyTWFwW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSA9IEV4cHIuYXR0ck1hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsyXSA9PT0gXCJ+PVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFs0XSA9IFwiIFwiICsgbWF0Y2hbNF0gKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFBTRVVETzogZnVuY3Rpb24gKG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09IFwibm90XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGNvbXBsZXggZXhwcmVzc2lvbiwgb3IgYSBzaW1wbGUgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNodW5rZXIuZXhlYyhtYXRjaFszXSkgfHwgXCJcIikubGVuZ3RoID4gMSB8fCAvXlxcdy8udGVzdChtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9IFNpenpsZShtYXRjaFszXSwgbnVsbCwgbnVsbCwgY3VyTG9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBTaXp6bGUuZmlsdGVyKG1hdGNoWzNdLCBjdXJMb29wLCBpbnBsYWNlLCB0cnVlIF4gbm90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlucGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRXhwci5tYXRjaC5QT1MudGVzdChtYXRjaFswXSkgfHwgRXhwci5tYXRjaC5DSElMRC50ZXN0KG1hdGNoWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBQT1M6IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaC51bnNoaWZ0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcnM6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgZWxlbS50eXBlICE9PSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY2hlY2tlZCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFyZW50OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFlbGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFlbGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uIChlbGVtLCBpLCBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFTaXp6bGUobWF0Y2hbM10sIGVsZW0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgvaFxcZC9pKS50ZXN0KGVsZW0ubm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGV4dDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGV4dFwiID09PSBlbGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByYWRpbzogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmFkaW9cIiA9PT0gZWxlbS50eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hlY2tib3g6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNoZWNrYm94XCIgPT09IGVsZW0udHlwZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGU6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZpbGVcIiA9PT0gZWxlbS50eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInBhc3N3b3JkXCIgPT09IGVsZW0udHlwZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN1Ym1pdDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3VibWl0XCIgPT09IGVsZW0udHlwZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGltYWdlOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbWFnZVwiID09PSBlbGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmVzZXRcIiA9PT0gZWxlbS50eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYnV0dG9uOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJidXR0b25cIiA9PT0gZWxlbS50eXBlIHx8IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJidXR0b25cIjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uL2kpLnRlc3QoZWxlbS5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEZpbHRlcnM6IHtcbiAgICAgICAgICAgICAgICBmaXJzdDogZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPT09IDA7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXN0OiBmdW5jdGlvbiAoZWxlbSwgaSwgbWF0Y2gsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpID09PSBhcnJheS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXZlbjogZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgJSAyID09PSAwO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb2RkOiBmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAlIDIgPT09IDE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsdDogZnVuY3Rpb24gKGVsZW0sIGksIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpIDwgbWF0Y2hbM10gLSAwO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ3Q6IGZ1bmN0aW9uIChlbGVtLCBpLCBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA+IG1hdGNoWzNdIC0gMDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG50aDogZnVuY3Rpb24gKGVsZW0sIGksIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaFszXSAtIDAgPT09IGk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcTogZnVuY3Rpb24gKGVsZW0sIGksIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaFszXSAtIDAgPT09IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgIFBTRVVETzogZnVuY3Rpb24gKGVsZW0sIG1hdGNoLCBpLCBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG1hdGNoWzFdLCBmaWx0ZXIgPSBFeHByLmZpbHRlcnNbbmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcihlbGVtLCBpLCBtYXRjaCwgYXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiY29udGFpbnNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IFNpenpsZS5nZXRUZXh0KFtlbGVtXSkgfHwgXCJcIikuaW5kZXhPZihtYXRjaFszXSkgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcIm5vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90ID0gbWF0Y2hbM107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gbm90Lmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3Rbal0gPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDSElMRDogZnVuY3Rpb24gKGVsZW0sIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV0sIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29ubHknOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZpcnN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGFzdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ250aCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gbWF0Y2hbMl0sIGxhc3QgPSBtYXRjaFszXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb25lTmFtZSA9IG1hdGNoWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIChwYXJlbnQuc2l6Y2FjaGUgIT09IGRvbmVOYW1lIHx8ICFlbGVtLm5vZGVJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChub2RlID0gcGFyZW50LmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZUluZGV4ID0gKytjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuc2l6Y2FjaGUgPSBkb25lTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGVsZW0ubm9kZUluZGV4IC0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgSUQ6IGZ1bmN0aW9uIChlbGVtLCBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBtYXRjaDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFRBRzogZnVuY3Rpb24gKGVsZW0sIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobWF0Y2ggPT09IFwiKlwiICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHx8IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDTEFTUzogZnVuY3Rpb24gKGVsZW0sIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCIgXCIgKyAoZWxlbS5jbGFzc05hbWUgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSkgKyBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKG1hdGNoKSA+IC0xO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQVRUUjogZnVuY3Rpb24gKGVsZW0sIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBFeHByLmF0dHJIYW5kbGVbbmFtZV0gP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4cHIuYXR0ckhhbmRsZVtuYW1lXShlbGVtKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtuYW1lXSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtuYW1lXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQgKyBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSBtYXRjaFs0XTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCIhPVwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwiPVwiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gY2hlY2sgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwiKj1cIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmluZGV4T2YoY2hlY2spID49IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcIn49XCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiIFwiICsgdmFsdWUgKyBcIiBcIikuaW5kZXhPZihjaGVjaykgPj0gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY2hlY2sgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICYmIHJlc3VsdCAhPT0gZmFsc2UgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwiIT1cIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwiXj1cIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5pbmRleE9mKGNoZWNrKSA9PT0gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcIiQ9XCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cih2YWx1ZS5sZW5ndGggLSBjaGVjay5sZW5ndGgpID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCJ8PVwiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IGNoZWNrIHx8IHZhbHVlLnN1YnN0cigwLCBjaGVjay5sZW5ndGggKyAxKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgUE9TOiBmdW5jdGlvbiAoZWxlbSwgbWF0Y2gsIGksIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbWF0Y2hbMl0sIGZpbHRlciA9IEV4cHIuc2V0RmlsdGVyc1tuYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyKGVsZW0sIGksIG1hdGNoLCBhcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9yaWdQT1MgPSBFeHByLm1hdGNoLlBPUyxcbiAgICAgICAgICAgIGZlc2NhcGUgPSBmdW5jdGlvbiAoYWxsLCBudW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyAobnVtIC0gMCArIDEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciB0eXBlIGluIEV4cHIubWF0Y2gpIHtcbiAgICAgICAgICAgIEV4cHIubWF0Y2hbdHlwZV0gPSBuZXcgUmVnRXhwKEV4cHIubWF0Y2hbdHlwZV0uc291cmNlICsgKC8oPyFbXlxcW10qXFxdKSg/IVteXFwoXSpcXCkpLy5zb3VyY2UpKTtcbiAgICAgICAgICAgIEV4cHIubGVmdE1hdGNoW3R5cGVdID0gbmV3IFJlZ0V4cCgvKF4oPzoufFxccnxcXG4pKj8pLy5zb3VyY2UgKyBFeHByLm1hdGNoW3R5cGVdLnNvdXJjZS5yZXBsYWNlKC9cXFxcKFxcZCspL2csIGZlc2NhcGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYWtlQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXksIDApO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaC5hcHBseShyZXN1bHRzLCBhcnJheSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQZXJmb3JtIGEgc2ltcGxlIGNoZWNrIHRvIGRldGVybWluZSBpZiB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mXG4gICAgICAgIC8vIGNvbnZlcnRpbmcgYSBOb2RlTGlzdCB0byBhbiBhcnJheSB1c2luZyBidWlsdGluIG1ldGhvZHMuXG4gICAgICAgIC8vIEFsc28gdmVyaWZpZXMgdGhhdCB0aGUgcmV0dXJuZWQgYXJyYXkgaG9sZHMgRE9NIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBpcyBub3QgdGhlIGNhc2UgaW4gdGhlIEJsYWNrYmVycnkgYnJvd3NlcilcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzLCAwKVswXS5ub2RlVHlwZTtcblxuICAgICAgICAgICAgLy8gUHJvdmlkZSBhIGZhbGxiYWNrIG1ldGhvZCBpZiBpdCBkb2VzIG5vdCB3b3JrXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG1ha2VBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSByZXN1bHRzIHx8IFtdLCBpID0gMDtcblxuICAgICAgICAgICAgICAgIGlmICh0b1N0cmluZy5jYWxsKGFycmF5KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJldCwgYXJyYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJyYXkubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGFycmF5W2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3J0T3JkZXIsIHNpYmxpbmdDaGVjaztcblxuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBzb3J0T3JkZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiB8fCAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDQgPyAtMSA6IDE7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydE9yZGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXAgPSBbXSwgYnAgPSBbXSwgYXVwID0gYS5wYXJlbnROb2RlLCBidXAgPSBiLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGF1cCwgYWwsIGJsO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG5vZGVzIGFyZSBpZGVudGljYWwsIHdlIGNhbiBleGl0IGVhcmx5XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncyAob3IgaWRlbnRpY2FsKSB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXVwID09PSBidXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayhhLCBiKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBwYXJlbnRzIHdlcmUgZm91bmQgdGhlbiB0aGUgbm9kZXMgYXJlIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWF1cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFidXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZXkncmUgc29tZXdoZXJlIGVsc2UgaW4gdGhlIHRyZWUgc28gd2UgbmVlZFxuICAgICAgICAgICAgICAgIC8vIHRvIGJ1aWxkIHVwIGEgZnVsbCBsaXN0IG9mIHRoZSBwYXJlbnROb2RlcyBmb3IgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXAudW5zaGlmdChjdXIpO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXIgPSBidXA7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJwLnVuc2hpZnQoY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWwgPSBhcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYmwgPSBicC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGFydCB3YWxraW5nIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWwgJiYgaSA8IGJsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwW2ldICE9PSBicFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayhhcFtpXSwgYnBbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgZW5kZWQgc29tZXBsYWNlIHVwIHRoZSB0cmVlIHNvIGRvIGEgc2libGluZyBjaGVja1xuICAgICAgICAgICAgICAgIHJldHVybiBpID09PSBhbCA/XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdDaGVjayhhLCBicFtpXSwgLTEpIDpcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ0NoZWNrKGFwW2ldLCBiLCAxKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNpYmxpbmdDaGVjayA9IGZ1bmN0aW9uIChhLCBiLCByZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdXIgPSBhLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyID09PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmVpdmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAgICAgICAgU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiAoZWxlbXMpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBcIlwiLCBlbGVtO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgZWxlbXNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtc1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGV4dCBmcm9tIHRleHQgbm9kZXMgYW5kIENEQVRBIG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICByZXQgKz0gZWxlbS5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhdmVyc2UgZXZlcnl0aGluZyBlbHNlLCBleGNlcHQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS5ub2RlVHlwZSAhPT0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXQgKz0gU2l6emxlLmdldFRleHQoZWxlbS5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBicm93c2VyIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZSB3aGVuXG4gICAgICAgIC8vIHF1ZXJ5aW5nIGJ5IGdldEVsZW1lbnRCeUlkIChhbmQgcHJvdmlkZSBhIHdvcmthcm91bmQpXG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBpbmplY3QgYSBmYWtlIGlucHV0IGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBuYW1lXG4gICAgICAgICAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICAgICAgaWQgPSBcInNjcmlwdFwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGZvcm0uaW5uZXJIVE1MID0gXCI8YSBuYW1lPSdcIiArIGlkICsgXCInLz5cIjtcblxuICAgICAgICAgICAgLy8gSW5qZWN0IGl0IGludG8gdGhlIHJvb3QgZWxlbWVudCwgY2hlY2sgaXRzIHN0YXR1cywgYW5kIHJlbW92ZSBpdCBxdWlja2x5XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHJvb3QuaW5zZXJ0QmVmb3JlKGZvcm0sIHJvb3QuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGhhcyB0byBkbyBhZGRpdGlvbmFsIGNoZWNrcyBhZnRlciBhIGdldEVsZW1lbnRCeUlkXG4gICAgICAgICAgICAvLyBXaGljaCBzbG93cyB0aGluZ3MgZG93biBmb3Igb3RoZXIgYnJvd3NlcnMgKGhlbmNlIHRoZSBicmFuY2hpbmcpXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgRXhwci5maW5kLklEID0gZnVuY3Rpb24gKG1hdGNoLCBjb250ZXh0LCBpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0gPyBtLmlkID09PSBtYXRjaFsxXSB8fCB0eXBlb2YgbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIG0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLm5vZGVWYWx1ZSA9PT0gbWF0Y2hbMV0gPyBbbV0gOiB1bmRlZmluZWQgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBFeHByLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChlbGVtLCBtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxICYmIG5vZGUgJiYgbm9kZS5ub2RlVmFsdWUgPT09IG1hdGNoO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQoZm9ybSk7XG4gICAgICAgICAgICByb290ID0gZm9ybSA9IG51bGw7IC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgYnJvd3NlciByZXR1cm5zIG9ubHkgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIHdoZW4gZG9pbmcgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpXG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGZha2UgZWxlbWVudFxuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBubyBjb21tZW50cyBhcmUgZm91bmRcbiAgICAgICAgICAgIGlmIChkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBFeHByLmZpbmQuVEFHID0gZnVuY3Rpb24gKG1hdGNoLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShtYXRjaFsxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyByZXN1bHRzW2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1tpXS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAucHVzaChyZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgYW4gYXR0cmlidXRlIHJldHVybnMgbm9ybWFsaXplZCBocmVmIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcbiAgICAgICAgICAgIGlmIChkaXYuZmlyc3RDaGlsZCAmJiB0eXBlb2YgZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSAhPT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICBFeHByLmF0dHJIYW5kbGUuaHJlZiA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImhyZWZcIiwgMik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGl2ID0gbnVsbDsgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU2l6emxlID0gU2l6emxlLCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxwIGNsYXNzPSdURVNUJz48L3A+XCI7XG5cbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgY2FuJ3QgaGFuZGxlIHVwcGVyY2FzZSBvciB1bmljb2RlIGNoYXJhY3RlcnMgd2hlblxuICAgICAgICAgICAgICAgIC8vIGluIHF1aXJrcyBtb2RlLlxuICAgICAgICAgICAgICAgIGlmIChkaXYucXVlcnlTZWxlY3RvckFsbCAmJiBkaXYucXVlcnlTZWxlY3RvckFsbChcIi5URVNUXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgU2l6emxlID0gZnVuY3Rpb24gKHF1ZXJ5LCBjb250ZXh0LCBleHRyYSwgc2VlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSBxdWVyeVNlbGVjdG9yQWxsIG9uIG5vbi1YTUwgZG9jdW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIChJRCBzZWxlY3RvcnMgZG9uJ3Qgd29yayBpbiBub24tSFRNTCBkb2N1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VlZCAmJiAhU2l6emxlLmlzWE1MKGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5ub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlQXJyYXkoY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZXh0cmEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHFzYUVycm9yKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHFTQSB3b3JrcyBzdHJhbmdlbHkgb24gRWxlbWVudC1yb290ZWQgcXVlcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRSA4IGRvZXNuJ3Qgd29yayBvbiBvYmplY3QgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5ub2RlVHlwZSA9PT0gMSAmJiBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkID0gY29udGV4dC5pZCwgaWQgPSBjb250ZXh0LmlkID0gXCJfX3NpenpsZV9fXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUFycmF5KGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChcIiNcIiArIGlkICsgXCIgXCIgKyBxdWVyeSksIGV4dHJhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHBzZXVkb0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pZCA9IG9sZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRTaXp6bGUocXVlcnksIGNvbnRleHQsIGV4dHJhLCBzZWVkKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvbGRTaXp6bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgU2l6emxlW3Byb3BdID0gb2xkU2l6emxlW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpdiA9IG51bGw7IC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBodG1sLm1hdGNoZXNTZWxlY3RvciB8fCBodG1sLm1vek1hdGNoZXNTZWxlY3RvciB8fCBodG1sLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBodG1sLm1zTWF0Y2hlc1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHBzZXVkb1dvcmtzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcbiAgICAgICAgICAgICAgICBtYXRjaGVzLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBcIjpzaXp6bGVcIik7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKHBzZXVkb0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgcHNldWRvV29ya3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAobm9kZSwgZXhwcikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBzZXVkb1dvcmtzIHx8ICFFeHByLm1hdGNoLlBTRVVETy50ZXN0KGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChub2RlLCBleHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBudWxsLCBudWxsLCBbbm9kZV0pLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J3Rlc3QgZSc+PC9kaXY+PGRpdiBjbGFzcz0ndGVzdCc+PC9kaXY+XCI7XG5cbiAgICAgICAgICAgIC8vIE9wZXJhIGNhbid0IGZpbmQgYSBzZWNvbmQgY2xhc3NuYW1lIChpbiA5LjYpXG4gICAgICAgICAgICAvLyBBbHNvLCBtYWtlIHN1cmUgdGhhdCBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIGFjdHVhbGx5IGV4aXN0c1xuICAgICAgICAgICAgaWYgKCFkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSB8fCBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImVcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYWZhcmkgY2FjaGVzIGNsYXNzIGF0dHJpYnV0ZXMsIGRvZXNuJ3QgY2F0Y2ggY2hhbmdlcyAoaW4gMy4yKVxuICAgICAgICAgICAgZGl2Lmxhc3RDaGlsZC5jbGFzc05hbWUgPSBcImVcIjtcblxuICAgICAgICAgICAgaWYgKGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEV4cHIub3JkZXIuc3BsaWNlKDEsIDAsIFwiQ0xBU1NcIik7XG4gICAgICAgICAgICBFeHByLmZpbmQuQ0xBU1MgPSBmdW5jdGlvbiAobWF0Y2gsIGNvbnRleHQsIGlzWE1MKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRpdiA9IG51bGw7IC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZGlyTm9kZUNoZWNrKGRpciwgY3VyLCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hlY2tTZXQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBjaGVja1NldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uc2l6Y2FjaGUgPT09IGRvbmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBjaGVja1NldFtlbGVtLnNpenNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxICYmICFpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2l6Y2FjaGUgPSBkb25lTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNpenNldCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGN1cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW1bZGlyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0W2ldID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGlyQ2hlY2soZGlyLCBjdXIsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGNoZWNrU2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtW2Rpcl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5zaXpjYWNoZSA9PT0gZG9uZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGNoZWNrU2V0W2VsZW0uc2l6c2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2l6Y2FjaGUgPSBkb25lTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zaXpzZXQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1ciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSA9PT0gY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChTaXp6bGUuZmlsdGVyKGN1ciwgW2VsZW1dKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXRbaV0gPSBtYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBTaXp6bGUuY29udGFpbnMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGEuY29udGFpbnMgPyBhLmNvbnRhaW5zKGIpIDogdHJ1ZSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuICEhKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiAxNik7XG4gICAgICAgIH07XG5cbiAgICAgICAgU2l6emxlLmlzWE1MID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKSBcbiAgICAgICAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSAoZWxlbSA/IGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtIDogMCkuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcG9zUHJvY2VzcyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHRtcFNldCA9IFtdLCBsYXRlciA9IFwiXCIsIG1hdGNoLFxuICAgICAgICAgICAgICAgIHJvb3QgPSBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dDtcblxuICAgICAgICAgICAgLy8gUG9zaXRpb24gc2VsZWN0b3JzIG11c3QgYmUgZG9uZSBhZnRlciB0aGUgZmlsdGVyXG4gICAgICAgICAgICAvLyBBbmQgc28gbXVzdCA6bm90KHBvc2l0aW9uYWwpIHNvIHdlIG1vdmUgYWxsIFBTRVVET3MgdG8gdGhlIGVuZFxuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IEV4cHIubWF0Y2guUFNFVURPLmV4ZWMoc2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgICAgIGxhdGVyICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShFeHByLm1hdGNoLlBTRVVETywgXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdG9yID0gRXhwci5yZWxhdGl2ZVtzZWxlY3Rvcl0gPyBzZWxlY3RvciArIFwiKlwiIDogc2VsZWN0b3I7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm9vdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBTaXp6bGUoc2VsZWN0b3IsIHJvb3RbaV0sIHRtcFNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBTaXp6bGUuZmlsdGVyKGxhdGVyLCB0bXBTZXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEVYUE9TRVxuICAgICAgICBqUXVlcnkuZmluZCA9IFNpenpsZTtcbiAgICAgICAgalF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuICAgICAgICBqUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5maWx0ZXJzO1xuICAgICAgICBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG4gICAgICAgIGpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG4gICAgICAgIGpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbiAgICAgICAgalF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuXG5cbiAgICB9KSgpO1xuXG5cbiAgICB2YXIgcnVudGlsID0gL1VudGlsJC8sXG4gICAgICAgIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2VW50aWx8cHJldkFsbCkvLFxuICAgICAgICAvLyBOb3RlOiBUaGlzIFJlZ0V4cCBzaG91bGQgYmUgaW1wcm92ZWQsIG9yIGxpa2VseSBwdWxsZWQgZnJvbSBTaXp6bGVcbiAgICAgICAgcm11bHRpc2VsZWN0b3IgPSAvLC8sXG4gICAgICAgIGlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvLFxuICAgICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgICAgICAgUE9TID0galF1ZXJ5LmV4cHIubWF0Y2guUE9TO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMucHVzaFN0YWNrKFwiXCIsIFwiZmluZFwiLCBzZWxlY3RvciksIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKHNlbGVjdG9yLCB0aGlzW2ldLCByZXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSByZXN1bHRzIGFyZSB1bmlxdWVcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGxlbmd0aDsgbiA8IHJldC5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBsZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRbcl0gPT09IHJldFtuXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuc3BsaWNlKG4tLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KHRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyh0aGlzLCB0YXJnZXRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBub3Q6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciwgZmFsc2UpLCBcIm5vdFwiLCBzZWxlY3Rvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayh3aW5ub3codGhpcywgc2VsZWN0b3IsIHRydWUpLCBcImZpbHRlclwiLCBzZWxlY3Rvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXM6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuICEhc2VsZWN0b3IgJiYgalF1ZXJ5LmZpbHRlcihzZWxlY3RvciwgdGhpcykubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZXN0OiBmdW5jdGlvbiAoc2VsZWN0b3JzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gW10sIGksIGwsIGN1ciA9IHRoaXNbMF07XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNBcnJheShzZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoLCBtYXRjaGVzID0ge30sIHNlbGVjdG9yLCBsZXZlbCA9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VyICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNlbGVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXNbc2VsZWN0b3JdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc1tzZWxlY3Rvcl0gPSBqUXVlcnkuZXhwci5tYXRjaC5QT1MudGVzdChzZWxlY3RvcikgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1ciAmJiBjdXIub3duZXJEb2N1bWVudCAmJiBjdXIgIT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoc2VsZWN0b3IgaW4gbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlc1tzZWxlY3Rvcl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2guanF1ZXJ5ID8gbWF0Y2guaW5kZXgoY3VyKSA+IC0xIDogalF1ZXJ5KGN1cikuaXMobWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgc2VsZWN0b3I6IHNlbGVjdG9yLCBlbGVtOiBjdXIsIGxldmVsOiBsZXZlbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb3MgPSBQT1MudGVzdChzZWxlY3RvcnMpID9cbiAgICAgICAgICAgICAgICBqUXVlcnkoc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCkgOiBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXIgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID8gcG9zLmluZGV4KGN1cikgPiAtMSA6IGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGN1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1ciB8fCAhY3VyLm93bmVyRG9jdW1lbnQgfHwgY3VyID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldCA9IHJldC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZShyZXQpIDogcmV0O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2socmV0LCBcImNsb3Nlc3RcIiwgc2VsZWN0b3JzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluXG4gICAgICAgIC8vIHRoZSBtYXRjaGVkIHNldCBvZiBlbGVtZW50c1xuICAgICAgICBpbmRleDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIGlmICghZWxlbSB8fCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuaW5BcnJheSh0aGlzWzBdLFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBhIHN0cmluZywgdGhlIHNlbGVjdG9yIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgcmVjZWl2ZXMgbm90aGluZywgdGhlIHNpYmxpbmdzIGFyZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPyBqUXVlcnkoZWxlbSkgOiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmluQXJyYXkoXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgZWxlbS5qcXVlcnkgPyBlbGVtWzBdIDogZWxlbSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgP1xuICAgICAgICAgICAgICAgIGpRdWVyeShzZWxlY3RvciwgY29udGV4dCB8fCB0aGlzLmNvbnRleHQpIDpcbiAgICAgICAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KHNlbGVjdG9yKSxcbiAgICAgICAgICAgICAgICBhbGwgPSBqUXVlcnkubWVyZ2UodGhpcy5nZXQoKSwgc2V0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGlzRGlzY29ubmVjdGVkKHNldFswXSkgfHwgaXNEaXNjb25uZWN0ZWQoYWxsWzBdKSA/XG4gICAgICAgICAgICAgICAgYWxsIDpcbiAgICAgICAgICAgICAgICBqUXVlcnkudW5pcXVlKGFsbCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFuZFNlbGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCh0aGlzLnByZXZPYmplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBIHBhaW5mdWxseSBzaW1wbGUgY2hlY2sgdG8gc2VlIGlmIGFuIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkXG4gICAgLy8gZnJvbSBhIGRvY3VtZW50IChzaG91bGQgYmUgaW1wcm92ZWQsIHdoZXJlIGZlYXNpYmxlKS5cbiAgICBmdW5jdGlvbiBpc0Rpc2Nvbm5lY3RlZChub2RlKSB7XG4gICAgICAgIHJldHVybiAhbm9kZSB8fCAhbm9kZS5wYXJlbnROb2RlIHx8IG5vZGUucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTE7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmVhY2goe1xuICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50czogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFwicGFyZW50Tm9kZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50c1VudGlsOiBmdW5jdGlvbiAoZWxlbSwgaSwgdW50aWwpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCk7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm50aChlbGVtLCAyLCBcIm5leHRTaWJsaW5nXCIpO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5udGgoZWxlbSwgMiwgXCJwcmV2aW91c1NpYmxpbmdcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHRBbGw6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcIm5leHRTaWJsaW5nXCIpO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2QWxsOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHRVbnRpbDogZnVuY3Rpb24gKGVsZW0sIGksIHVudGlsKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJldlVudGlsOiBmdW5jdGlvbiAoZWxlbSwgaSwgdW50aWwpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2libGluZ3M6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoZWxlbS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQsIGVsZW0pO1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuc2libGluZyhlbGVtLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50czogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJpZnJhbWVcIikgP1xuICAgICAgICAgICAgICAgIGVsZW0uY29udGVudERvY3VtZW50IHx8IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudCA6XG4gICAgICAgICAgICAgICAgalF1ZXJ5Lm1ha2VBcnJheShlbGVtLmNoaWxkTm9kZXMpO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uICh1bnRpbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBqUXVlcnkubWFwKHRoaXMsIGZuLCB1bnRpbCk7XG5cbiAgICAgICAgICAgIGlmICghcnVudGlsLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVudGlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LmZpbHRlcihzZWxlY3RvciwgcmV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0gdGhpcy5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZShyZXQpIDogcmV0O1xuXG4gICAgICAgICAgICBpZiAoKHRoaXMubGVuZ3RoID4gMSB8fCBybXVsdGlzZWxlY3Rvci50ZXN0KHNlbGVjdG9yKSkgJiYgcnBhcmVudHNwcmV2LnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSByZXQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2socmV0LCBuYW1lLCBzbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIixcIikpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGV4cHIsIGVsZW1zLCBub3QpIHtcbiAgICAgICAgICAgIGlmIChub3QpIHtcbiAgICAgICAgICAgICAgICBleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZWxlbXNbMF0sIGV4cHIpID8gW2VsZW1zWzBdXSA6IFtdIDpcbiAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzKGV4cHIsIGVsZW1zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkaXI6IGZ1bmN0aW9uIChlbGVtLCBkaXIsIHVudGlsKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IFtdLCBjdXIgPSBlbGVtW2Rpcl07XG4gICAgICAgICAgICB3aGlsZSAoY3VyICYmIGN1ci5ub2RlVHlwZSAhPT0gOSAmJiAodW50aWwgPT09IHVuZGVmaW5lZCB8fCBjdXIubm9kZVR5cGUgIT09IDEgfHwgIWpRdWVyeShjdXIpLmlzKHVudGlsKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChjdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXIgPSBjdXJbZGlyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIG50aDogZnVuY3Rpb24gKGN1ciwgcmVzdWx0LCBkaXIsIGVsZW0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCAxO1xuICAgICAgICAgICAgdmFyIG51bSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyBjdXI7IGN1ciA9IGN1cltkaXJdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PT0gMSAmJiArK251bSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfSxcblxuICAgICAgICBzaWJsaW5nOiBmdW5jdGlvbiAobiwgZWxlbSkge1xuICAgICAgICAgICAgdmFyIHIgPSBbXTtcblxuICAgICAgICAgICAgZm9yICg7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByLnB1c2gobik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbiAgICBmdW5jdGlvbiB3aW5ub3coZWxlbWVudHMsIHF1YWxpZmllciwga2VlcCkge1xuICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocXVhbGlmaWVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciByZXRWYWwgPSAhIXF1YWxpZmllci5jYWxsKGVsZW0sIGksIGVsZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRWYWwgPT09IGtlZXA7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2UgaWYgKHF1YWxpZmllci5ub2RlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZWxlbSA9PT0gcXVhbGlmaWVyKSA9PT0ga2VlcDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzU2ltcGxlLnRlc3QocXVhbGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZmlsdGVyZWQsICFrZWVwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlcihxdWFsaWZpZXIsIGZpbHRlcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgICAgICAgIHJldHVybiAoalF1ZXJ5LmluQXJyYXkoZWxlbSwgcXVhbGlmaWVyKSA+PSAwKSA9PT0ga2VlcDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cblxuXG4gICAgdmFyIHJpbmxpbmVqUXVlcnkgPSAvIGpRdWVyeVxcZCs9XCIoPzpcXGQrfG51bGwpXCIvZyxcbiAgICAgICAgcmxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLyxcbiAgICAgICAgcnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2lnLFxuICAgICAgICBydGFnTmFtZSA9IC88KFtcXHc6XSspLyxcbiAgICAgICAgcnRib2R5ID0gLzx0Ym9keS9pLFxuICAgICAgICByaHRtbCA9IC88fCYjP1xcdys7LyxcbiAgICAgICAgcm5vY2FjaGUgPSAvPCg/OnNjcmlwdHxvYmplY3R8ZW1iZWR8b3B0aW9ufHN0eWxlKS9pLFxuICAgICAgICByY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksICAvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWQgKGh0bWw1KVxuICAgICAgICByYWN0aW9uID0gL1xcPShbXj1cIic+XFxzXStcXC8pPi9nLFxuICAgICAgICB3cmFwTWFwID0ge1xuICAgICAgICAgICAgb3B0aW9uOiBbMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCJdLFxuICAgICAgICAgICAgbGVnZW5kOiBbMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIl0sXG4gICAgICAgICAgICB0aGVhZDogWzEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCJdLFxuICAgICAgICAgICAgdHI6IFsyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSxcbiAgICAgICAgICAgIHRkOiBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sXG4gICAgICAgICAgICBjb2w6IFsyLCBcIjx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSxcbiAgICAgICAgICAgIGFyZWE6IFsxLCBcIjxtYXA+XCIsIFwiPC9tYXA+XCJdLFxuICAgICAgICAgICAgX2RlZmF1bHQ6IFswLCBcIlwiLCBcIlwiXVxuICAgICAgICB9O1xuXG4gICAgd3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuICAgIHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG4gICAgd3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbiAgICAvLyBJRSBjYW4ndCBzZXJpYWxpemUgPGxpbms+IGFuZCA8c2NyaXB0PiB0YWdzIG5vcm1hbGx5XG4gICAgaWYgKCFqUXVlcnkuc3VwcG9ydC5odG1sU2VyaWFsaXplKSB7XG4gICAgICAgIHdyYXBNYXAuX2RlZmF1bHQgPSBbMSwgXCJkaXY8ZGl2PlwiLCBcIjwvZGl2PlwiXTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudGV4dCh0ZXh0LmNhbGwodGhpcywgaSwgc2VsZi50ZXh0KCkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSBcIm9iamVjdFwiICYmIHRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5KCkuYXBwZW5kKCh0aGlzWzBdICYmIHRoaXNbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnRleHQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JhcEFsbDogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihodG1sKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBBbGwoaHRtbC5jYWxsKHRoaXMsIGkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuICAgICAgICAgICAgICAgIHZhciB3cmFwID0galF1ZXJ5KGh0bWwsIHRoaXNbMF0ub3duZXJEb2N1bWVudCkuZXEoMCkuY2xvbmUodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpc1swXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdyYXAubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtLmZpcnN0Q2hpbGQgJiYgZWxlbS5maXJzdENoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oaHRtbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS53cmFwSW5uZXIoaHRtbC5jYWxsKHRoaXMsIGkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyksIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cy53cmFwQWxsKGh0bWwpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQoaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd3JhcDogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS53cmFwQWxsKGh0bWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW53cmFwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpRdWVyeS5ub2RlTmFtZSh0aGlzLCBcImJvZHlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuZW5kKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXBwZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIHRydWUsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIHRydWUsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZmFsc2UsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0ID0galF1ZXJ5KGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICAgICAgc2V0LnB1c2guYXBwbHkoc2V0LCB0aGlzLnRvQXJyYXkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHNldCwgXCJiZWZvcmVcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmYWxzZSwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtLCB0aGlzLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXQgPSB0aGlzLnB1c2hTdGFjayh0aGlzLCBcImFmdGVyXCIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgc2V0LnB1c2guYXBwbHkoc2V0LCBqUXVlcnkoYXJndW1lbnRzWzBdKS50b0FycmF5KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8ga2VlcERhdGEgaXMgZm9yIGludGVybmFsIHVzZSBvbmx5LS1kbyBub3QgZG9jdW1lbnRcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoc2VsZWN0b3IsIGtlZXBEYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IGpRdWVyeS5maWx0ZXIoc2VsZWN0b3IsIFtlbGVtXSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2VlcERhdGEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKFtlbGVtXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVDaGlsZChlbGVtLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICAgICAgICAgIC8vIERvIHRoZSBjbG9uZVxuICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVFdmVudCAmJiAhalF1ZXJ5LmlzWE1MRG9jKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFIGNvcGllcyBldmVudHMgYm91bmQgdmlhIGF0dGFjaEV2ZW50IHdoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgY2xvbmVOb2RlLiBDYWxsaW5nIGRldGFjaEV2ZW50IG9uIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjbG9uZSB3aWxsIGFsc28gcmVtb3ZlIHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ25hbFxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgYXJvdW5kIHRoaXMsIHdlIHVzZSBpbm5lckhUTUwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbWVhbnMgc29tZSBtb2RpZmljYXRpb25zIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gSUUgdGhhdCBhcmUgYWN0dWFsbHkgb25seSBzdG9yZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcHJvcGVydGllcyB3aWxsIG5vdCBiZSBjb3BpZWQgKHN1Y2ggYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYW1lIGF0dHJpYnV0ZSBvbiBhbiBpbnB1dCkuXG4gICAgICAgICAgICAgICAgICAgIHZhciBodG1sID0gdGhpcy5vdXRlckhUTUwsIG93bmVyRG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gZGl2LmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY2xlYW4oW2h0bWwucmVwbGFjZShyaW5saW5lalF1ZXJ5LCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIGluIElFIDggd2hlcmUgYWN0aW9uPS90ZXN0Lz4gc2VsZi1jbG9zZXMgYSB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJhY3Rpb24sICc9XCIkMVwiPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShybGVhZGluZ1doaXRlc3BhY2UsIFwiXCIpXSwgb3duZXJEb2N1bWVudClbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG4gICAgICAgICAgICBpZiAoZXZlbnRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQodGhpcywgcmV0KTtcbiAgICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudCh0aGlzLmZpbmQoXCIqXCIpLCByZXQuZmluZChcIipcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWzBdICYmIHRoaXNbMF0ubm9kZVR5cGUgPT09IDEgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzWzBdLmlubmVySFRNTC5yZXBsYWNlKHJpbmxpbmVqUXVlcnksIFwiXCIpIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9jYWNoZS50ZXN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgICAgIChqUXVlcnkuc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSB8fCAhcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QodmFsdWUpKSAmJlxuICAgICAgICAgICAgICAgICF3cmFwTWFwWyhydGFnTmFtZS5leGVjKHZhbHVlKSB8fCBbXCJcIiwgXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocnhodG1sVGFnLCBcIjwkMT48LyQyPlwiKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKHRoaXNbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ldLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmh0bWwodmFsdWUuY2FsbCh0aGlzLCBpLCBzZWxmLmh0bWwoKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZWxlbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGJlZm9yZSB0aGV5IGFyZSBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIGhlbHAgZml4IHJlcGxhY2luZyBhIHBhcmVudCB3aXRoIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSwgb2xkID0gc2VsZi5odG1sKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlcGxhY2VXaXRoKHZhbHVlLmNhbGwodGhpcywgaSwgb2xkKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkodmFsdWUpLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dFNpYmxpbmcsIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeShuZXh0KS5iZWZvcmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHBhcmVudCkuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soalF1ZXJ5KGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlKCkgOiB2YWx1ZSksIFwicmVwbGFjZVdpdGhcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoc2VsZWN0b3IsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRvbU1hbmlwOiBmdW5jdGlvbiAoYXJncywgdGFibGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cywgZmlyc3QsIHZhbHVlID0gYXJnc1swXSwgc2NyaXB0cyA9IFtdLCBmcmFnbWVudCwgcGFyZW50O1xuXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcbiAgICAgICAgICAgIGlmICghalF1ZXJ5LnN1cHBvcnQuY2hlY2tDbG9uZSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiByY2hlY2tlZC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykuZG9tTWFuaXAoYXJncywgdGFibGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSB2YWx1ZS5jYWxsKHRoaXMsIGksIHRhYmxlID8gc2VsZi5odG1sKCkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbU1hbmlwKGFyZ3MsIHRhYmxlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzWzBdKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdmFsdWUgJiYgdmFsdWUucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIGEgZnJhZ21lbnQsIGp1c3QgdXNlIHRoYXQgaW5zdGVhZCBvZiBidWlsZGluZyBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LnN1cHBvcnQucGFyZW50Tm9kZSAmJiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxMSAmJiBwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB7IGZyYWdtZW50OiBwYXJlbnQgfTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBqUXVlcnkuYnVpbGRGcmFnbWVudChhcmdzLCB0aGlzLCBzY3JpcHRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHJlc3VsdHMuZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZSA9IHRhYmxlICYmIGpRdWVyeS5ub2RlTmFtZShmaXJzdCwgXCJ0clwiKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCh0aGlzW2ldLCBmaXJzdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPiAwIHx8IHJlc3VsdHMuY2FjaGVhYmxlIHx8IHRoaXMubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmNsb25lTm9kZSh0cnVlKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKHNjcmlwdHMsIGV2YWxTY3JpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJvb3QoZWxlbSwgY3VyKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJ0YWJsZVwiKSA/XG4gICAgICAgICAgICAoZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG4gICAgICAgICAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKSkgOlxuICAgICAgICAgICAgZWxlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUNvcHlFdmVudChvcmlnLCByZXQpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHJldC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVOYW1lICE9PSAob3JpZ1tpXSAmJiBvcmlnW2ldLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZERhdGEgPSBqUXVlcnkuZGF0YShvcmlnW2krK10pLCBjdXJEYXRhID0galF1ZXJ5LmRhdGEodGhpcywgb2xkRGF0YSksIGV2ZW50cyA9IG9sZERhdGEgJiYgb2xkRGF0YS5ldmVudHM7XG5cbiAgICAgICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VyRGF0YS5oYW5kbGU7XG4gICAgICAgICAgICAgICAgY3VyRGF0YS5ldmVudHMgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhhbmRsZXIgaW4gZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKHRoaXMsIHR5cGUsIGV2ZW50c1t0eXBlXVtoYW5kbGVyXSwgZXZlbnRzW3R5cGVdW2hhbmRsZXJdLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBqUXVlcnkuYnVpbGRGcmFnbWVudCA9IGZ1bmN0aW9uIChhcmdzLCBub2Rlcywgc2NyaXB0cykge1xuICAgICAgICB2YXIgZnJhZ21lbnQsIGNhY2hlYWJsZSwgY2FjaGVyZXN1bHRzLFxuICAgICAgICAgICAgZG9jID0gKG5vZGVzICYmIG5vZGVzWzBdID8gbm9kZXNbMF0ub3duZXJEb2N1bWVudCB8fCBub2Rlc1swXSA6IGRvY3VtZW50KTtcblxuICAgICAgICAvLyBPbmx5IGNhY2hlIFwic21hbGxcIiAoMS8yIEtCKSBzdHJpbmdzIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFpbiBkb2N1bWVudFxuICAgICAgICAvLyBDbG9uaW5nIG9wdGlvbnMgbG9zZXMgdGhlIHNlbGVjdGVkIHN0YXRlLCBzbyBkb24ndCBjYWNoZSB0aGVtXG4gICAgICAgIC8vIElFIDYgZG9lc24ndCBsaWtlIGl0IHdoZW4geW91IHB1dCA8b2JqZWN0PiBvciA8ZW1iZWQ+IGVsZW1lbnRzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgLy8gQWxzbywgV2ViS2l0IGRvZXMgbm90IGNsb25lICdjaGVja2VkJyBhdHRyaWJ1dGVzIG9uIGNsb25lTm9kZSwgc28gZG9uJ3QgY2FjaGVcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiICYmIGFyZ3NbMF0ubGVuZ3RoIDwgNTEyICYmIGRvYyA9PT0gZG9jdW1lbnQgJiZcbiAgICAgICAgICAgICFybm9jYWNoZS50ZXN0KGFyZ3NbMF0pICYmIChqUXVlcnkuc3VwcG9ydC5jaGVja0Nsb25lIHx8ICFyY2hlY2tlZC50ZXN0KGFyZ3NbMF0pKSkge1xuXG4gICAgICAgICAgICBjYWNoZWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgY2FjaGVyZXN1bHRzID0galF1ZXJ5LmZyYWdtZW50c1thcmdzWzBdXTtcbiAgICAgICAgICAgIGlmIChjYWNoZXJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVyZXN1bHRzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gY2FjaGVyZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGpRdWVyeS5jbGVhbihhcmdzLCBkb2MsIGZyYWdtZW50LCBzY3JpcHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWNoZWFibGUpIHtcbiAgICAgICAgICAgIGpRdWVyeS5mcmFnbWVudHNbYXJnc1swXV0gPSBjYWNoZXJlc3VsdHMgPyBmcmFnbWVudCA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBmcmFnbWVudDogZnJhZ21lbnQsIGNhY2hlYWJsZTogY2FjaGVhYmxlIH07XG4gICAgfTtcblxuICAgIGpRdWVyeS5mcmFnbWVudHMgPSB7fTtcblxuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgYXBwZW5kVG86IFwiYXBwZW5kXCIsXG4gICAgICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG4gICAgICAgIGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcbiAgICAgICAgaW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcbiAgICAgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG4gICAgfSwgZnVuY3Rpb24gKG5hbWUsIG9yaWdpbmFsKSB7XG4gICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdLCBpbnNlcnQgPSBqUXVlcnkoc2VsZWN0b3IpLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXNbMF0ucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDExICYmIHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpbnNlcnQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0W29yaWdpbmFsXSh0aGlzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluc2VydC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1zID0gKGkgPiAwID8gdGhpcy5jbG9uZSh0cnVlKSA6IHRoaXMpLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoaW5zZXJ0W2ldKVtvcmlnaW5hbF0oZWxlbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGVsZW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2socmV0LCBuYW1lLCBpbnNlcnQuc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIGNsZWFuOiBmdW5jdGlvbiAoZWxlbXMsIGNvbnRleHQsIGZyYWdtZW50LCBzY3JpcHRzKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICAgICAgLy8gIWNvbnRleHQuY3JlYXRlRWxlbWVudCBmYWlscyBpbiBJRSB3aXRoIGFuIGVycm9yIGJ1dCByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmNyZWF0ZUVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHRbMF0gJiYgY29udGV4dFswXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSArPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGh0bWwgc3RyaW5nIGludG8gRE9NIG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICYmICFyaHRtbC50ZXN0KGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjb250ZXh0LmNyZWF0ZVRleHROb2RlKGVsZW0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggXCJYSFRNTFwiLXN0eWxlIHRhZ3MgaW4gYWxsIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLnJlcGxhY2UocnhodG1sVGFnLCBcIjwkMT48LyQyPlwiKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmltIHdoaXRlc3BhY2UsIG90aGVyd2lzZSBpbmRleE9mIHdvbid0IHdvcmsgYXMgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IChydGFnTmFtZS5leGVjKGVsZW0pIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXAgPSB3cmFwTWFwW3RhZ10gfHwgd3JhcE1hcC5fZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gd3JhcFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdiA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHbyB0byBodG1sIGFuZCBiYWNrLCB0aGVuIHBlZWwgb2ZmIGV4dHJhIHdyYXBwZXJzXG4gICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSB3cmFwWzFdICsgZWxlbSArIHdyYXBbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgcmlnaHQgZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdiA9IGRpdi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSUUncyBhdXRvaW5zZXJ0ZWQgPHRib2R5PiBmcm9tIHRhYmxlIGZyYWdtZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWpRdWVyeS5zdXBwb3J0LnRib2R5KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyB3YXMgYSA8dGFibGU+LCAqbWF5KiBoYXZlIHNwdXJpb3VzIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNCb2R5ID0gcnRib2R5LnRlc3QoZWxlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJvZHkgPSB0YWcgPT09IFwidGFibGVcIiAmJiAhaGFzQm9keSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5maXJzdENoaWxkICYmIGRpdi5maXJzdENoaWxkLmNoaWxkTm9kZXMgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyB3YXMgYSBiYXJlIDx0aGVhZD4gb3IgPHRmb290PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwWzFdID09PSBcIjx0YWJsZT5cIiAmJiAhaGFzQm9keSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXYuY2hpbGROb2RlcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHRib2R5Lmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5ub2RlTmFtZSh0Ym9keVtqXSwgXCJ0Ym9keVwiKSAmJiAhdGJvZHlbal0uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJvZHlbal0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0Ym9keVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJRSBjb21wbGV0ZWx5IGtpbGxzIGxlYWRpbmcgd2hpdGVzcGFjZSB3aGVuIGlubmVySFRNTCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LnN1cHBvcnQubGVhZGluZ1doaXRlc3BhY2UgJiYgcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoZWxlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5pbnNlcnRCZWZvcmUoY29udGV4dC5jcmVhdGVUZXh0Tm9kZShybGVhZGluZ1doaXRlc3BhY2UuZXhlYyhlbGVtKVswXSksIGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBkaXYuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBqUXVlcnkubWVyZ2UocmV0LCBlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IHJldFtpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JpcHRzICYmIGpRdWVyeS5ub2RlTmFtZShyZXRbaV0sIFwic2NyaXB0XCIpICYmICghcmV0W2ldLnR5cGUgfHwgcmV0W2ldLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0L2phdmFzY3JpcHRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdHMucHVzaChyZXRbaV0ucGFyZW50Tm9kZSA/IHJldFtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJldFtpXSkgOiByZXRbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0W2ldLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnNwbGljZS5hcHBseShyZXQsIFtpICsgMSwgMF0uY29uY2F0KGpRdWVyeS5tYWtlQXJyYXkocmV0W2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQocmV0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uIChlbGVtcykge1xuICAgICAgICAgICAgdmFyIGRhdGEsIGlkLCBjYWNoZSA9IGpRdWVyeS5jYWNoZSxcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG4gICAgICAgICAgICAgICAgZGVsZXRlRXhwYW5kbyA9IGpRdWVyeS5zdXBwb3J0LmRlbGV0ZUV4cGFuZG87XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlTmFtZSAmJiBqUXVlcnkubm9EYXRhW2VsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWQgPSBlbGVtW2pRdWVyeS5leHBhbmRvXTtcblxuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gY2FjaGVbaWRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIGRhdGEuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCB0eXBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUV4cGFuZG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtW2pRdWVyeS5leHBhbmRvXTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0ucmVtb3ZlQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShqUXVlcnkuZXhwYW5kbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZXZhbFNjcmlwdChpLCBlbGVtKSB7XG4gICAgICAgIGlmIChlbGVtLnNyYykge1xuICAgICAgICAgICAgalF1ZXJ5LmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogZWxlbS5zcmMsXG4gICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKGVsZW0udGV4dCB8fCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJIVE1MIHx8IFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxuXG4gICAgdmFyIHJhbHBoYSA9IC9hbHBoYVxcKFteKV0qXFwpL2ksXG4gICAgICAgIHJvcGFjaXR5ID0gL29wYWNpdHk9KFteKV0qKS8sXG4gICAgICAgIHJkYXNoQWxwaGEgPSAvLShbYS16XSkvaWcsXG4gICAgICAgIHJ1cHBlciA9IC8oW0EtWl0pL2csXG4gICAgICAgIHJudW1weCA9IC9eLT9cXGQrKD86cHgpPyQvaSxcbiAgICAgICAgcm51bSA9IC9eLT9cXGQvLFxuXG4gICAgICAgIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuICAgICAgICBjc3NXaWR0aCA9IFtcIkxlZnRcIiwgXCJSaWdodFwiXSxcbiAgICAgICAgY3NzSGVpZ2h0ID0gW1wiVG9wXCIsIFwiQm90dG9tXCJdLFxuICAgICAgICBjdXJDU1MsXG5cbiAgICAgICAgLy8gY2FjaGUgY2hlY2sgZm9yIGRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUsXG5cbiAgICAgICAgZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uIChhbGwsIGxldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9O1xuXG4gICAgalF1ZXJ5LmZuLmNzcyA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAvLyBTZXR0aW5nICd1bmRlZmluZWQnIGlzIGEgbm8tb3BcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5LmFjY2Vzcyh0aGlzLCBuYW1lLCB2YWx1ZSwgdHJ1ZSwgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUsIHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICAvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG4gICAgICAgIGNzc0hvb2tzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGN1ckNTUyhlbGVtLCBcIm9wYWNpdHlcIiwgXCJvcGFjaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5zdHlsZS5vcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEV4Y2x1ZGUgdGhlIGZvbGxvd2luZyBjc3MgcHJvcGVydGllcyB0byBhZGQgcHhcbiAgICAgICAgY3NzTnVtYmVyOiB7XG4gICAgICAgICAgICBcInpJbmRleFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJmb250V2VpZ2h0XCI6IHRydWUsXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiem9vbVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJsaW5lSGVpZ2h0XCI6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG4gICAgICAgIC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcbiAgICAgICAgY3NzUHJvcHM6IHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBmbG9hdCBjc3MgcHJvcGVydHlcbiAgICAgICAgICAgIFwiZmxvYXRcIjogalF1ZXJ5LnN1cHBvcnQuY3NzRmxvYXQgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIlxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG4gICAgICAgIHN0eWxlOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgIGlmICghZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuICAgICAgICAgICAgdmFyIHJldCwgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKG5hbWUpLFxuICAgICAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZSwgaG9va3MgPSBqUXVlcnkuY3NzSG9va3Nbb3JpZ05hbWVdO1xuXG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSB8fCBvcmlnTmFtZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IE5hTiBhbmQgbnVsbCB2YWx1ZXMgYXJlbid0IHNldC4gU2VlOiAjNzExNlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4odmFsdWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbb3JpZ05hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFwicHhcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXcmFwcGVkIHRvIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBlcnJvcnMgd2hlbiAnaW52YWxpZCcgdmFsdWVzIGFyZSBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlcyBidWcgIzU1MDlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIGZhbHNlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZVtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjc3M6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBleHRyYSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG4gICAgICAgICAgICB2YXIgcmV0LCBvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UobmFtZSksXG4gICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3Nbb3JpZ05hbWVdO1xuXG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSB8fCBvcmlnTmFtZTtcblxuICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcbiAgICAgICAgICAgIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgdHJ1ZSwgZXh0cmEpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckNTUykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJDU1MoZWxlbSwgbmFtZSwgb3JpZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEEgbWV0aG9kIGZvciBxdWlja2x5IHN3YXBwaW5nIGluL291dCBDU1MgcHJvcGVydGllcyB0byBnZXQgY29ycmVjdCBjYWxjdWxhdGlvbnNcbiAgICAgICAgc3dhcDogZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgb2xkID0ge307XG5cbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb2xkW25hbWVdID0gZWxlbS5zdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChlbGVtKTtcblxuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FtZWxDYXNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERFUFJFQ0FURUQsIFVzZSBqUXVlcnkuY3NzKCkgaW5zdGVhZFxuICAgIGpRdWVyeS5jdXJDU1MgPSBqUXVlcnkuY3NzO1xuXG4gICAgalF1ZXJ5LmVhY2goW1wiaGVpZ2h0XCIsIFwid2lkdGhcIl0sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG4gICAgICAgIGpRdWVyeS5jc3NIb29rc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkLCBleHRyYSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ub2Zmc2V0V2lkdGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGdldFdIKGVsZW0sIG5hbWUsIGV4dHJhKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGdldFdIKGVsZW0sIG5hbWUsIGV4dHJhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChybnVtcHgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG5lZ2F0aXZlIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzICMxNTk5XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGlmICghalF1ZXJ5LnN1cHBvcnQub3BhY2l0eSkge1xuICAgICAgICBqUXVlcnkuY3NzSG9va3Mub3BhY2l0eSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgdXNlcyBmaWx0ZXJzIGZvciBvcGFjaXR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvcGFjaXR5LnRlc3QoKGNvbXB1dGVkICYmIGVsZW0uY3VycmVudFN0eWxlID8gZWxlbS5jdXJyZW50U3R5bGUuZmlsdGVyIDogZWxlbS5zdHlsZS5maWx0ZXIpIHx8IFwiXCIpID9cbiAgICAgICAgICAgICAgICAgICAgKHBhcnNlRmxvYXQoUmVnRXhwLiQxKSAvIDEwMCkgKyBcIlwiIDpcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQgPyBcIjFcIiA6IFwiXCI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW0uc3R5bGU7XG5cbiAgICAgICAgICAgICAgICAvLyBJRSBoYXMgdHJvdWJsZSB3aXRoIG9wYWNpdHkgaWYgaXQgZG9lcyBub3QgaGF2ZSBsYXlvdXRcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBpdCBieSBzZXR0aW5nIHRoZSB6b29tIGxldmVsXG4gICAgICAgICAgICAgICAgc3R5bGUuem9vbSA9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGFscGhhIGZpbHRlciB0byBzZXQgdGhlIG9wYWNpdHlcbiAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eSA9IGpRdWVyeS5pc05hTih2YWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICBcIlwiIDpcbiAgICAgICAgICAgICAgICAgICAgXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKiAxMDAgKyBcIilcIixcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gc3R5bGUuZmlsdGVyIHx8IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBzdHlsZS5maWx0ZXIgPSByYWxwaGEudGVzdChmaWx0ZXIpID9cbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnJlcGxhY2UocmFscGhhLCBvcGFjaXR5KSA6XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmZpbHRlciArICcgJyArIG9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgY3VyQ1NTID0gZnVuY3Rpb24gKGVsZW0sIG5ld05hbWUsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciByZXQsIGRlZmF1bHRWaWV3LCBjb21wdXRlZFN0eWxlO1xuXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHJ1cHBlciwgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKCEoZGVmYXVsdFZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChjb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKSkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGpRdWVyeS5zdHlsZShlbGVtLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgY3VyQ1NTID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0LCByc0xlZnQsIHJldCA9IGVsZW0uY3VycmVudFN0eWxlICYmIGVsZW0uY3VycmVudFN0eWxlW25hbWVdLCBzdHlsZSA9IGVsZW0uc3R5bGU7XG5cbiAgICAgICAgICAgIC8vIEZyb20gdGhlIGF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9lcmlrLmVhZS5uZXQvYXJjaGl2ZXMvMjAwNy8wNy8yNy8xOC41NC4xNS8jY29tbWVudC0xMDIyOTFcblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG4gICAgICAgICAgICAvLyBidXQgYSBudW1iZXIgdGhhdCBoYXMgYSB3ZWlyZCBlbmRpbmcsIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBwaXhlbHNcbiAgICAgICAgICAgIGlmICghcm51bXB4LnRlc3QocmV0KSAmJiBybnVtLnRlc3QocmV0KSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBsZWZ0ID0gc3R5bGUubGVmdDtcbiAgICAgICAgICAgICAgICByc0xlZnQgPSBlbGVtLnJ1bnRpbWVTdHlsZS5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuICAgICAgICAgICAgICAgIGVsZW0ucnVudGltZVN0eWxlLmxlZnQgPSBlbGVtLmN1cnJlbnRTdHlsZS5sZWZ0O1xuICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSBuYW1lID09PSBcImZvbnRTaXplXCIgPyBcIjFlbVwiIDogKHJldCB8fCAwKTtcbiAgICAgICAgICAgICAgICByZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCI7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgZWxlbS5ydW50aW1lU3R5bGUubGVmdCA9IHJzTGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXSChlbGVtLCBuYW1lLCBleHRyYSkge1xuICAgICAgICB2YXIgd2hpY2ggPSBuYW1lID09PSBcIndpZHRoXCIgPyBjc3NXaWR0aCA6IGNzc0hlaWdodCxcbiAgICAgICAgICAgIHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodDtcblxuICAgICAgICBpZiAoZXh0cmEgPT09IFwiYm9yZGVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBqUXVlcnkuZWFjaCh3aGljaCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFleHRyYSkge1xuICAgICAgICAgICAgICAgIHZhbCAtPSBwYXJzZUZsb2F0KGpRdWVyeS5jc3MoZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzKSkgfHwgMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhID09PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsICs9IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpblwiICsgdGhpcykpIHx8IDA7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsIC09IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIikpIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgaWYgKGpRdWVyeS5leHByICYmIGpRdWVyeS5leHByLmZpbHRlcnMpIHtcbiAgICAgICAgalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZWxlbS5vZmZzZXRXaWR0aCwgaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB8fCAoIWpRdWVyeS5zdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyAmJiAoZWxlbS5zdHlsZS5kaXNwbGF5IHx8IGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpKSA9PT0gXCJub25lXCIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKGVsZW0pO1xuICAgICAgICB9O1xuICAgIH1cblxuXG5cblxuICAgIHZhciBqc2MgPSBqUXVlcnkubm93KCksXG4gICAgICAgIHJzY3JpcHQgPSAvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naSxcbiAgICAgICAgcnNlbGVjdFRleHRhcmVhID0gL14oPzpzZWxlY3R8dGV4dGFyZWEpL2ksXG4gICAgICAgIHJpbnB1dCA9IC9eKD86Y29sb3J8ZGF0ZXxkYXRldGltZXxlbWFpbHxoaWRkZW58bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhbmdlfHNlYXJjaHx0ZWx8dGV4dHx0aW1lfHVybHx3ZWVrKSQvaSxcbiAgICAgICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUR8REVMRVRFKSQvLFxuICAgICAgICByYnJhY2tldCA9IC9cXFtcXF0kLyxcbiAgICAgICAganNyZSA9IC9cXD1cXD8oJnwkKS8sXG4gICAgICAgIHJxdWVyeSA9IC9cXD8vLFxuICAgICAgICBydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG4gICAgICAgIHJ1cmwgPSAvXihcXHcrOik/XFwvXFwvKFteXFwvPyNdKykvLFxuICAgICAgICByMjAgPSAvJTIwL2csXG4gICAgICAgIHJoYXNoID0gLyMuKiQvLFxuXG4gICAgICAgIC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbiAgICAgICAgX2xvYWQgPSBqUXVlcnkuZm4ubG9hZDtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBsb2FkOiBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYSByZXF1ZXN0IGlmIG5vIGVsZW1lbnRzIGFyZSBiZWluZyByZXF1ZXN0ZWRcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XG4gICAgICAgICAgICBpZiAob2ZmID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB1cmwuc2xpY2Uob2ZmLCB1cmwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgb2ZmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBhIEdFVCByZXF1ZXN0XG4gICAgICAgICAgICB2YXIgdHlwZSA9IFwiR0VUXCI7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdhcyBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0galF1ZXJ5LnBhcmFtKHBhcmFtcywgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbCk7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIlBPU1RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgLy8gUmVxdWVzdCB0aGUgcmVtb3RlIGRvY3VtZW50XG4gICAgICAgICAgICBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAocmVzLCBzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3VjY2Vzc2Z1bCwgaW5qZWN0IHRoZSBIVE1MIGludG8gYWxsIHRoZSBtYXRjaGVkIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwic3VjY2Vzc1wiIHx8IHN0YXR1cyA9PT0gXCJub3Rtb2RpZmllZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmh0bWwoc2VsZWN0b3IgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGR1bW15IGRpdiB0byBob2xkIHRoZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KFwiPGRpdj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5qZWN0IHRoZSBjb250ZW50cyBvZiB0aGUgZG9jdW1lbnQgaW4sIHJlbW92aW5nIHRoZSBzY3JpcHRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGFueSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9ycyBpbiBJRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKHJlcy5yZXNwb25zZVRleHQucmVwbGFjZShyc2NyaXB0LCBcIlwiKSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2NhdGUgdGhlIHNwZWNpZmllZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZChzZWxlY3RvcikgOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90LCBqdXN0IGluamVjdCB0aGUgZnVsbCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lYWNoKGNhbGxiYWNrLCBbcmVzLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCByZXNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXJpYWxpemVBcnJheTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkodGhpcy5lbGVtZW50cykgOiB0aGlzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSAmJiAhdGhpcy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuY2hlY2tlZCB8fCByc2VsZWN0VGV4dGFyZWEudGVzdCh0aGlzLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpbnB1dC50ZXN0KHRoaXMudHlwZSkpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaSwgZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5KHRoaXMpLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0FycmF5KHZhbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAodmFsLCBmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbCB9O1xuICAgICAgICAgICAgICAgIH0pLmdldCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xuICAgIGpRdWVyeS5lYWNoKFwiYWpheFN0YXJ0IGFqYXhTdG9wIGFqYXhDb21wbGV0ZSBhamF4RXJyb3IgYWpheFN1Y2Nlc3MgYWpheFNlbmRcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uIChpLCBvKSB7XG4gICAgICAgIGpRdWVyeS5mbltvXSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5kKG8sIGYpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICAgICAgICAgIC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0ZWRcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihkYXRhKSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNjcmlwdDogZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KHVybCwgbnVsbCwgY2FsbGJhY2ssIFwic2NyaXB0XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEpTT046IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zdDogZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICAgICAgICAgIC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0ZWRcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihkYXRhKSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWpheFNldHVwOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoalF1ZXJ5LmFqYXhTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgICAgICAgdXJsOiBsb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IHRydWUsXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBudWxsLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IG51bGwsXG4gICAgICAgICAgICB0cmFkaXRpb25hbDogZmFsc2UsXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcnJpZGVuIGJ5IGNhbGxpbmcgalF1ZXJ5LmFqYXhTZXR1cFxuICAgICAgICAgICAgeGhyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY2NlcHRzOiB7XG4gICAgICAgICAgICAgICAgeG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcbiAgICAgICAgICAgICAgICBodG1sOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgICAgIHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIixcbiAgICAgICAgICAgICAgICBqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgICAgIF9kZWZhdWx0OiBcIiovKlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWpheDogZnVuY3Rpb24gKG9yaWdTZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIHMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBqUXVlcnkuYWpheFNldHRpbmdzLCBvcmlnU2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgIGpzb25wLCBzdGF0dXMsIGRhdGEsIHR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKSwgbm9Db250ZW50ID0gcm5vQ29udGVudC50ZXN0KHR5cGUpO1xuXG4gICAgICAgICAgICBzLnVybCA9IHMudXJsLnJlcGxhY2Uocmhhc2gsIFwiXCIpO1xuXG4gICAgICAgICAgICAvLyBVc2Ugb3JpZ2luYWwgKG5vdCBleHRlbmRlZCkgY29udGV4dCBvYmplY3QgaWYgaXQgd2FzIHByb3ZpZGVkXG4gICAgICAgICAgICBzLmNvbnRleHQgPSBvcmlnU2V0dGluZ3MgJiYgb3JpZ1NldHRpbmdzLmNvbnRleHQgIT0gbnVsbCA/IG9yaWdTZXR0aW5ncy5jb250ZXh0IDogcztcblxuICAgICAgICAgICAgLy8gY29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG4gICAgICAgICAgICBpZiAocy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHMuZGF0YSA9IGpRdWVyeS5wYXJhbShzLmRhdGEsIHMudHJhZGl0aW9uYWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgSlNPTlAgUGFyYW1ldGVyIENhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKHMuZGF0YVR5cGUgPT09IFwianNvbnBcIikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghanNyZS50ZXN0KHMudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy51cmwgKz0gKHJxdWVyeS50ZXN0KHMudXJsKSA/IFwiJlwiIDogXCI/XCIpICsgKHMuanNvbnAgfHwgXCJjYWxsYmFja1wiKSArIFwiPT9cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXMuZGF0YSB8fCAhanNyZS50ZXN0KHMuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5kYXRhID0gKHMuZGF0YSA/IHMuZGF0YSArIFwiJlwiIDogXCJcIikgKyAocy5qc29ucCB8fCBcImNhbGxiYWNrXCIpICsgXCI9P1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzLmRhdGFUeXBlID0gXCJqc29uXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIHRlbXBvcmFyeSBKU09OUCBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKHMuZGF0YVR5cGUgPT09IFwianNvblwiICYmIChzLmRhdGEgJiYganNyZS50ZXN0KHMuZGF0YSkgfHwganNyZS50ZXN0KHMudXJsKSkpIHtcbiAgICAgICAgICAgICAgICBqc29ucCA9IHMuanNvbnBDYWxsYmFjayB8fCAoXCJqc29ucFwiICsganNjKyspO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgPT8gc2VxdWVuY2UgYm90aCBpbiB0aGUgcXVlcnkgc3RyaW5nIGFuZCB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5kYXRhID0gKHMuZGF0YSArIFwiXCIpLnJlcGxhY2UoanNyZSwgXCI9XCIgKyBqc29ucCArIFwiJDFcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcy51cmwgPSBzLnVybC5yZXBsYWNlKGpzcmUsIFwiPVwiICsganNvbnAgKyBcIiQxXCIpO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGEgSlNPTlAgc3R5bGUgcmVzcG9uc2UgaXMgZXhlY3V0ZWQgcHJvcGVybHlcbiAgICAgICAgICAgICAgICBzLmRhdGFUeXBlID0gXCJzY3JpcHRcIjtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBKU09OUC1zdHlsZSBsb2FkaW5nXG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbUpzb25wID0gd2luZG93W2pzb25wXTtcblxuICAgICAgICAgICAgICAgIHdpbmRvd1tqc29ucF0gPSBmdW5jdGlvbiAodG1wKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5oYW5kbGVTdWNjZXNzKHMsIHhociwgc3RhdHVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmhhbmRsZUNvbXBsZXRlKHMsIHhociwgc3RhdHVzLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oY3VzdG9tSnNvbnApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21Kc29ucCh0bXApO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHYXJiYWdlIGNvbGxlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1tqc29ucF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1tqc29ucF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChqc29ucEVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocy5kYXRhVHlwZSA9PT0gXCJzY3JpcHRcIiAmJiBzLmNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcy5jYWNoZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocy5jYWNoZSA9PT0gZmFsc2UgJiYgdHlwZSA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgICAgIHZhciB0cyA9IGpRdWVyeS5ub3coKTtcblxuICAgICAgICAgICAgICAgIC8vIHRyeSByZXBsYWNpbmcgXz0gaWYgaXQgaXMgdGhlcmVcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gcy51cmwucmVwbGFjZShydHMsIFwiJDFfPVwiICsgdHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgbm90aGluZyB3YXMgcmVwbGFjZWQsIGFkZCB0aW1lc3RhbXAgdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgIHMudXJsID0gcmV0ICsgKChyZXQgPT09IHMudXJsKSA/IChycXVlcnkudGVzdChzLnVybCkgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIHRzIDogXCJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmwgZm9yIGdldCByZXF1ZXN0c1xuICAgICAgICAgICAgaWYgKHMuZGF0YSAmJiB0eXBlID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICAgICAgcy51cmwgKz0gKHJxdWVyeS50ZXN0KHMudXJsKSA/IFwiJlwiIDogXCI/XCIpICsgcy5kYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG4gICAgICAgICAgICBpZiAocy5nbG9iYWwgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RhcnRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGNoZXMgYW4gYWJzb2x1dGUgVVJMLCBhbmQgc2F2ZXMgdGhlIGRvbWFpblxuICAgICAgICAgICAgdmFyIHBhcnRzID0gcnVybC5leGVjKHMudXJsKSxcbiAgICAgICAgICAgICAgICByZW1vdGUgPSBwYXJ0cyAmJiAocGFydHNbMV0gJiYgcGFydHNbMV0gIT09IGxvY2F0aW9uLnByb3RvY29sIHx8IHBhcnRzWzJdICE9PSBsb2NhdGlvbi5ob3N0KTtcblxuICAgICAgICAgICAgLy8gSWYgd2UncmUgcmVxdWVzdGluZyBhIHJlbW90ZSBkb2N1bWVudFxuICAgICAgICAgICAgLy8gYW5kIHRyeWluZyB0byBsb2FkIEpTT04gb3IgU2NyaXB0IHdpdGggYSBHRVRcbiAgICAgICAgICAgIGlmIChzLmRhdGFUeXBlID09PSBcInNjcmlwdFwiICYmIHR5cGUgPT09IFwiR0VUXCIgJiYgcmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChzLnNjcmlwdENoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LmNoYXJzZXQgPSBzLnNjcmlwdENoYXJzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjcmlwdC5zcmMgPSBzLnVybDtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBTY3JpcHQgbG9hZGluZ1xuICAgICAgICAgICAgICAgIGlmICghanNvbnApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggaGFuZGxlcnMgZm9yIGFsbCBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSAmJiAoIXRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJsb2FkZWRcIiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaGFuZGxlU3VjY2VzcyhzLCB4aHIsIHN0YXR1cywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmhhbmRsZUNvbXBsZXRlKHMsIHhociwgc3RhdHVzLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtZW1vcnkgbGVhayBpbiBJRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZCAmJiBzY3JpcHQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiBhcHBlbmRDaGlsZCAgdG8gY2lyY3VtdmVudCBhbiBJRTYgYnVnLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXJpc2VzIHdoZW4gYSBiYXNlIG5vZGUgaXMgdXNlZCAoIzI3MDkgYW5kICM0Mzc4KS5cbiAgICAgICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBoYW5kbGUgZXZlcnl0aGluZyB1c2luZyB0aGUgc2NyaXB0IGVsZW1lbnQgaW5qZWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlcXVlc3REb25lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICAgIHZhciB4aHIgPSBzLnhocigpO1xuXG4gICAgICAgICAgICBpZiAoIXhocikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3BlbiB0aGUgc29ja2V0XG4gICAgICAgICAgICAvLyBQYXNzaW5nIG51bGwgdXNlcm5hbWUsIGdlbmVyYXRlcyBhIGxvZ2luIHBvcHVwIG9uIE9wZXJhICgjMjg2NSlcbiAgICAgICAgICAgIGlmIChzLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgeGhyLm9wZW4odHlwZSwgcy51cmwsIHMuYXN5bmMsIHMudXNlcm5hbWUsIHMucGFzc3dvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4aHIub3Blbih0eXBlLCBzLnVybCwgcy5hc3luYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5lZWQgYW4gZXh0cmEgdHJ5L2NhdGNoIGZvciBjcm9zcyBkb21haW4gcmVxdWVzdHMgaW4gRmlyZWZveCAzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBjb250ZW50LXR5cGUgaWYgZGF0YSBzcGVjaWZpZWQgYW5kIGNvbnRlbnQtYm9keSBpcyB2YWxpZCBmb3IgdGhpcyB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKChzLmRhdGEgIT0gbnVsbCAmJiAhbm9Db250ZW50KSB8fCAob3JpZ1NldHRpbmdzICYmIG9yaWdTZXR0aW5ncy5jb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cbiAgICAgICAgICAgICAgICBpZiAocy5pZk1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkubGFzdE1vZGlmaWVkW3MudXJsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkW3MudXJsXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmV0YWdbcy51cmxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbcy51cmxdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNldCBoZWFkZXIgc28gdGhlIGNhbGxlZCBzY3JpcHQga25vd3MgdGhhdCBpdCdzIGFuIFhNTEh0dHBSZXF1ZXN0XG4gICAgICAgICAgICAgICAgLy8gT25seSBzZW5kIHRoZSBoZWFkZXIgaWYgaXQncyBub3QgYSByZW1vdGUgWEhSXG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIHMuZGF0YVR5cGUgJiYgcy5hY2NlcHRzW3MuZGF0YVR5cGVdID9cbiAgICAgICAgICAgICAgICAgICAgcy5hY2NlcHRzW3MuZGF0YVR5cGVdICsgXCIsICovKjsgcT0wLjAxXCIgOlxuICAgICAgICAgICAgICAgICAgICBzLmFjY2VwdHMuX2RlZmF1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoaGVhZGVyRXJyb3IpIHsgfVxuXG4gICAgICAgICAgICAvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG4gICAgICAgICAgICBpZiAocy5iZWZvcmVTZW5kICYmIHMuYmVmb3JlU2VuZC5jYWxsKHMuY29udGV4dCwgeGhyLCBzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcbiAgICAgICAgICAgICAgICBpZiAocy5nbG9iYWwgJiYgalF1ZXJ5LmFjdGl2ZS0tID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2xvc2Ugb3BlbmRlZCBzb2NrZXRcbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS50cmlnZ2VyR2xvYmFsKHMsIFwiYWpheFNlbmRcIiwgW3hociwgc10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYWl0IGZvciBhIHJlc3BvbnNlIHRvIGNvbWUgYmFja1xuICAgICAgICAgICAgdmFyIG9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWRcbiAgICAgICAgICAgICAgICBpZiAoIXhociB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gMCB8fCBpc1RpbWVvdXQgPT09IFwiYWJvcnRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSBkb2Vzbid0IGNhbGwgb25yZWFkeXN0YXRlY2hhbmdlIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIHNpbXVsYXRlIHRoZSBjYWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdERvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5oYW5kbGVDb21wbGV0ZShzLCB4aHIsIHN0YXR1cywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBqUXVlcnkubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0cmFuc2ZlciBpcyBjb21wbGV0ZSBhbmQgdGhlIGRhdGEgaXMgYXZhaWxhYmxlLCBvciB0aGUgcmVxdWVzdCB0aW1lZCBvdXRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyZXF1ZXN0RG9uZSAmJiB4aHIgJiYgKHhoci5yZWFkeVN0YXRlID09PSA0IHx8IGlzVGltZW91dCA9PT0gXCJ0aW1lb3V0XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3REb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGpRdWVyeS5ub29wO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IGlzVGltZW91dCA9PT0gXCJ0aW1lb3V0XCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aW1lb3V0XCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIWpRdWVyeS5odHRwU3VjY2Vzcyh4aHIpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVycm9yXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuaWZNb2RpZmllZCAmJiBqUXVlcnkuaHR0cE5vdE1vZGlmaWVkKHhociwgcy51cmwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJub3Rtb2RpZmllZFwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdWNjZXNzXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyck1zZztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2F0Y2ggZm9yLCBhbmQgY2F0Y2gsIFhNTCBkb2N1bWVudCBwYXJzZSBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgZGF0YSAocnVucyB0aGUgeG1sIHRocm91Z2ggaHR0cERhdGEgcmVnYXJkbGVzcyBvZiBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0galF1ZXJ5Lmh0dHBEYXRhKHhociwgcy5kYXRhVHlwZSwgcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChwYXJzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwicGFyc2VyZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJNc2cgPSBwYXJzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsIG9yIG5vdG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwic3VjY2Vzc1wiIHx8IHN0YXR1cyA9PT0gXCJub3Rtb2RpZmllZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKU09OUCBoYW5kbGVzIGl0cyBvd24gc3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFqc29ucCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5oYW5kbGVTdWNjZXNzKHMsIHhociwgc3RhdHVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5oYW5kbGVFcnJvcihzLCB4aHIsIHN0YXR1cywgZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIGNvbXBsZXRlIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmICghanNvbnApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5oYW5kbGVDb21wbGV0ZShzLCB4aHIsIHN0YXR1cywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lb3V0ID09PSBcInRpbWVvdXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBhYm9ydCBoYW5kbGVyLCBpZiB3ZSBjYW4gKElFIDYgZG9lc24ndCBhbGxvdyBpdCwgYnV0IHRoYXQncyBPSylcbiAgICAgICAgICAgIC8vIE9wZXJhIGRvZXNuJ3QgZmlyZSBvbnJlYWR5c3RhdGVjaGFuZ2UgYXQgYWxsIG9uIGFib3J0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRBYm9ydCA9IHhoci5hYm9ydDtcbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHhoci5hYm9ydCBpbiBJRTcgaXMgbm90IGEgbmF0aXZlIEpTIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkb2VzIG5vdCBoYXZlIGEgY2FsbCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyICYmIG9sZEFib3J0LmNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEFib3J0LmNhbGwoeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9ucmVhZHlzdGF0ZWNoYW5nZShcImFib3J0XCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGNhdGNoIChhYm9ydEVycm9yKSB7IH1cblxuICAgICAgICAgICAgLy8gVGltZW91dCBjaGVja2VyXG4gICAgICAgICAgICBpZiAocy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcmVxdWVzdCBpcyBzdGlsbCBoYXBwZW5pbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhociAmJiAhcmVxdWVzdERvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ucmVhZHlzdGF0ZWNoYW5nZShcInRpbWVvdXRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBzLnRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBkYXRhXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHhoci5zZW5kKG5vQ29udGVudCB8fCBzLmRhdGEgPT0gbnVsbCA/IG51bGwgOiBzLmRhdGEpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChzZW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuaGFuZGxlRXJyb3IocywgeGhyLCBudWxsLCBzZW5kRXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmlyZSB0aGUgY29tcGxldGUgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBqUXVlcnkuaGFuZGxlQ29tcGxldGUocywgeGhyLCBzdGF0dXMsIGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaXJlZm94IDEuNSBkb2Vzbid0IGZpcmUgc3RhdGVjaGFuZ2UgZm9yIHN5bmMgcmVxdWVzdHNcbiAgICAgICAgICAgIGlmICghcy5hc3luYykge1xuICAgICAgICAgICAgICAgIG9ucmVhZHlzdGF0ZWNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXR1cm4gWE1MSHR0cFJlcXVlc3QgdG8gYWxsb3cgYWJvcnRpbmcgdGhlIHJlcXVlc3QgZXRjLlxuICAgICAgICAgICAgcmV0dXJuIHhocjtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuICAgICAgICAvLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbiAgICAgICAgcGFyYW06IGZ1bmN0aW9uIChhLCB0cmFkaXRpb25hbCkge1xuICAgICAgICAgICAgdmFyIHMgPSBbXSwgYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlKCkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzW3MubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cbiAgICAgICAgICAgIGlmICh0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KGEpIHx8IGEuanF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goYSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBhZGQodGhpcy5uYW1lLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuICAgICAgICAgICAgICAgIC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByZWZpeCBpbiBhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCwgYVtwcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgIHJldHVybiBzLmpvaW4oXCImXCIpLnJlcGxhY2UocjIwLCBcIitcIik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkUGFyYW1zKHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkKSB7XG4gICAgICAgIGlmIChqUXVlcnkuaXNBcnJheShvYmopICYmIG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuICAgICAgICAgICAgalF1ZXJ5LmVhY2gob2JqLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAgICAgICAgIGlmICh0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgICAgICAgICAgICBhZGQocHJlZml4LCB2KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFycmF5IGl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0c1xuICAgICAgICAgICAgICAgICAgICAvLyBudW1lcmljIGluZGV4IHRvIHJlc29sdmUgZGVzZXJpYWxpemF0aW9uIGFtYmlndWl0eSBpc3N1ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCByYWNrIChhcyBvZiAxLjAuMCkgY2FuJ3QgY3VycmVudGx5IGRlc2VyaWFsaXplXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lc3RlZCBhcnJheXMgcHJvcGVybHksIGFuZCBhdHRlbXB0aW5nIHRvIGRvIHNvIG1heSBjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBhIHNlcnZlciBlcnJvci4gUG9zc2libGUgZml4ZXMgYXJlIHRvIG1vZGlmeSByYWNrJ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzZXJpYWxpemF0aW9uIGFsZ29yaXRobSBvciB0byBwcm92aWRlIGFuIG9wdGlvbiBvciBmbGFnXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGZvcmNlIGFycmF5IHNlcmlhbGl6YXRpb24gdG8gYmUgc2hhbGxvdy5cbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgXCJbXCIgKyAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgfHwgalF1ZXJ5LmlzQXJyYXkodikgPyBpIDogXCJcIikgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICghdHJhZGl0aW9uYWwgJiYgb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0VtcHR5T2JqZWN0KG9iaikpIHtcbiAgICAgICAgICAgICAgICBhZGQocHJlZml4LCBcIlwiKTtcblxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2gob2JqLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyBcIltcIiArIGsgKyBcIl1cIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cbiAgICAgICAgICAgIGFkZChwcmVmaXgsIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHN0aWxsIG9uIHRoZSBqUXVlcnkgb2JqZWN0Li4uIGZvciBub3dcbiAgICAvLyBXYW50IHRvIG1vdmUgdGhpcyB0byBqUXVlcnkuYWpheCBzb21lIGRheVxuICAgIGpRdWVyeS5leHRlbmQoe1xuXG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuICAgICAgICBhY3RpdmU6IDAsXG5cbiAgICAgICAgLy8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IHt9LFxuICAgICAgICBldGFnOiB7fSxcblxuICAgICAgICBoYW5kbGVFcnJvcjogZnVuY3Rpb24gKHMsIHhociwgc3RhdHVzLCBlKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGxvY2FsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIGZpcmUgaXRcbiAgICAgICAgICAgIGlmIChzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcy5lcnJvci5jYWxsKHMuY29udGV4dCwgeGhyLCBzdGF0dXMsIGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIHRoZSBnbG9iYWwgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChzLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS50cmlnZ2VyR2xvYmFsKHMsIFwiYWpheEVycm9yXCIsIFt4aHIsIHMsIGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVTdWNjZXNzOiBmdW5jdGlvbiAocywgeGhyLCBzdGF0dXMsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIElmIGEgbG9jYWwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgZmlyZSBpdCBhbmQgcGFzcyBpdCB0aGUgZGF0YVxuICAgICAgICAgICAgaWYgKHMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHMuc3VjY2Vzcy5jYWxsKHMuY29udGV4dCwgZGF0YSwgc3RhdHVzLCB4aHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIHRoZSBnbG9iYWwgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChzLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS50cmlnZ2VyR2xvYmFsKHMsIFwiYWpheFN1Y2Nlc3NcIiwgW3hociwgc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUNvbXBsZXRlOiBmdW5jdGlvbiAocywgeGhyLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgcmVzdWx0XG4gICAgICAgICAgICBpZiAocy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHMuY29tcGxldGUuY2FsbChzLmNvbnRleHQsIHhociwgc3RhdHVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZFxuICAgICAgICAgICAgaWYgKHMuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnRyaWdnZXJHbG9iYWwocywgXCJhamF4Q29tcGxldGVcIiwgW3hociwgc10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcbiAgICAgICAgICAgIGlmIChzLmdsb2JhbCAmJiBqUXVlcnkuYWN0aXZlLS0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXJHbG9iYWw6IGZ1bmN0aW9uIChzLCB0eXBlLCBhcmdzKSB7XG4gICAgICAgICAgICAocy5jb250ZXh0ICYmIHMuY29udGV4dC51cmwgPT0gbnVsbCA/IGpRdWVyeShzLmNvbnRleHQpIDogalF1ZXJ5LmV2ZW50KS50cmlnZ2VyKHR5cGUsIGFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgYW4gWE1MSHR0cFJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWwgb3Igbm90XG4gICAgICAgIGh0dHBTdWNjZXNzOiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIElFIGVycm9yIHNvbWV0aW1lcyByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0IHNvIHRyZWF0IGl0IGFzIHN1Y2Nlc3MsIHNlZSAjMTQ1MFxuICAgICAgICAgICAgICAgIHJldHVybiAheGhyLnN0YXR1cyAmJiBsb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJmaWxlOlwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHxcbiAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyA9PT0gMzA0IHx8IHhoci5zdGF0dXMgPT09IDEyMjM7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgYW4gWE1MSHR0cFJlcXVlc3QgcmV0dXJucyBOb3RNb2RpZmllZFxuICAgICAgICBodHRwTm90TW9kaWZpZWQ6IGZ1bmN0aW9uICh4aHIsIHVybCkge1xuICAgICAgICAgICAgdmFyIGxhc3RNb2RpZmllZCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksXG4gICAgICAgICAgICAgICAgZXRhZyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkV0YWdcIik7XG5cbiAgICAgICAgICAgIGlmIChsYXN0TW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkubGFzdE1vZGlmaWVkW3VybF0gPSBsYXN0TW9kaWZpZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldGFnKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV0YWdbdXJsXSA9IGV0YWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB4aHIuc3RhdHVzID09PSAzMDQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHR0cERhdGE6IGZ1bmN0aW9uICh4aHIsIHR5cGUsIHMpIHtcbiAgICAgICAgICAgIHZhciBjdCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHhtbCA9IHR5cGUgPT09IFwieG1sXCIgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZihcInhtbFwiKSA+PSAwLFxuICAgICAgICAgICAgICAgIGRhdGEgPSB4bWwgPyB4aHIucmVzcG9uc2VYTUwgOiB4aHIucmVzcG9uc2VUZXh0O1xuXG4gICAgICAgICAgICBpZiAoeG1sICYmIGRhdGEuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSBcInBhcnNlcmVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoXCJwYXJzZXJlcnJvclwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWxsb3cgYSBwcmUtZmlsdGVyaW5nIGZ1bmN0aW9uIHRvIHNhbml0aXplIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgLy8gcyBpcyBjaGVja2VkIHRvIGtlZXAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChzICYmIHMuZGF0YUZpbHRlcikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBzLmRhdGFGaWx0ZXIoZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBmaWx0ZXIgY2FuIGFjdHVhbGx5IHBhcnNlIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBKYXZhU2NyaXB0IG9iamVjdCwgaWYgSlNPTiBpcyB1c2VkLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImpzb25cIiB8fCAhdHlwZSAmJiBjdC5pbmRleE9mKFwianNvblwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkucGFyc2VKU09OKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0eXBlIGlzIFwic2NyaXB0XCIsIGV2YWwgaXQgaW4gZ2xvYmFsIGNvbnRleHRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic2NyaXB0XCIgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZihcImphdmFzY3JpcHRcIikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdDsgTWljcm9zb2Z0IGZhaWxlZCB0byBwcm9wZXJseVxuICAgICAqIGltcGxlbWVudCB0aGUgWE1MSHR0cFJlcXVlc3QgaW4gSUU3IChjYW4ndCByZXF1ZXN0IGxvY2FsIGZpbGVzKSxcbiAgICAgKiBzbyB3ZSB1c2UgdGhlIEFjdGl2ZVhPYmplY3Qgd2hlbiBpdCBpcyBhdmFpbGFibGVcbiAgICAgKiBBZGRpdGlvbmFsbHkgWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIGluIElFNy9JRTggc29cbiAgICAgKiB3ZSBuZWVkIGEgZmFsbGJhY2suXG4gICAgICovXG4gICAgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgIGpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gXCJmaWxlOlwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4aHJFcnJvcikgeyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoYWN0aXZlRXJyb3IpIHsgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIERvZXMgdGhpcyBicm93c2VyIHN1cHBvcnQgWEhSIHJlcXVlc3RzP1xuICAgIGpRdWVyeS5zdXBwb3J0LmFqYXggPSAhIWpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cblxuXG5cbiAgICB2YXIgZWxlbWRpc3BsYXkgPSB7fSxcbiAgICAgICAgcmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG4gICAgICAgIHJmeG51bSA9IC9eKFsrXFwtXT0pPyhbXFxkKy5cXC1dKykoLiopJC8sXG4gICAgICAgIHRpbWVySWQsXG4gICAgICAgIGZ4QXR0cnMgPSBbXG4gICAgICAgICAgICAvLyBoZWlnaHQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgW1wiaGVpZ2h0XCIsIFwibWFyZ2luVG9wXCIsIFwibWFyZ2luQm90dG9tXCIsIFwicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdCb3R0b21cIl0sXG4gICAgICAgICAgICAvLyB3aWR0aCBhbmltYXRpb25zXG4gICAgICAgICAgICBbXCJ3aWR0aFwiLCBcIm1hcmdpbkxlZnRcIiwgXCJtYXJnaW5SaWdodFwiLCBcInBhZGRpbmdMZWZ0XCIsIFwicGFkZGluZ1JpZ2h0XCJdLFxuICAgICAgICAgICAgLy8gb3BhY2l0eSBhbmltYXRpb25zXG4gICAgICAgICAgICBbXCJvcGFjaXR5XCJdXG4gICAgICAgIF07XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoc3BlZWQgfHwgc3BlZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKGdlbkZ4KFwic2hvd1wiLCAzKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpRdWVyeS5kYXRhKHRoaXNbaV0sIFwib2xkZGlzcGxheVwiKSAmJiB0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgalF1ZXJ5LmNzcyh0aGlzW2ldLCBcImRpc3BsYXlcIikgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSh0aGlzW2ldLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkodGhpc1tpXS5ub2RlTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3BcbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSBqUXVlcnkuZGF0YSh0aGlzW2ldLCBcIm9sZGRpc3BsYXlcIikgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChzcGVlZCB8fCBzcGVlZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoZ2VuRngoXCJoaWRlXCIsIDMpLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcGxheSA9IGpRdWVyeS5jc3ModGhpc1tpXSwgXCJkaXNwbGF5XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5ICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEodGhpc1tpXSwgXCJvbGRkaXNwbGF5XCIsIGRpc3BsYXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG4gICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgb2xkIHRvZ2dsZSBmdW5jdGlvblxuICAgICAgICBfdG9nZ2xlOiBqUXVlcnkuZm4udG9nZ2xlLFxuXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gKGZuLCBmbjIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgYm9vbCA9IHR5cGVvZiBmbiA9PT0gXCJib29sZWFuXCI7XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihmbikgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oZm4yKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZuID09IG51bGwgfHwgYm9vbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGJvb2wgPyBmbiA6IGpRdWVyeSh0aGlzKS5pcyhcIjpoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKVtzdGF0ZSA/IFwic2hvd1wiIDogXCJoaWRlXCJdKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKGdlbkZ4KFwidG9nZ2xlXCIsIDMpLCBmbiwgZm4yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZhZGVUbzogZnVuY3Rpb24gKHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKFwiOmhpZGRlblwiKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKS5lbmQoKVxuICAgICAgICAgICAgICAgIC5hbmltYXRlKHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIG9wdGFsbCA9IGpRdWVyeS5zcGVlZChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNFbXB0eU9iamVjdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2gob3B0YWxsLmNvbXBsZXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/IFwiZWFjaFwiIDogXCJxdWV1ZVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gWFhYIOKAmHRoaXPigJkgZG9lcyBub3QgYWx3YXlzIGhhdmUgYSBub2RlTmFtZSB3aGVuIHJ1bm5pbmcgdGhlXG4gICAgICAgICAgICAgICAgLy8gdGVzdCBzdWl0ZVxuXG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IGpRdWVyeS5leHRlbmQoe30sIG9wdGFsbCksIHAsXG4gICAgICAgICAgICAgICAgICAgIGlzRWxlbWVudCA9IHRoaXMubm9kZVR5cGUgPT09IDEsXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IGlzRWxlbWVudCAmJiBqUXVlcnkodGhpcykuaXMoXCI6aGlkZGVuXCIpLFxuICAgICAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGZvciAocCBpbiBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFtuYW1lXSA9IHByb3BbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcFtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BbcF0gPT09IFwiaGlkZVwiICYmIGhpZGRlbiB8fCBwcm9wW3BdID09PSBcInNob3dcIiAmJiAhaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0LmNvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50ICYmIChwID09PSBcImhlaWdodFwiIHx8IHAgPT09IFwid2lkdGhcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Lm92ZXJmbG93ID0gW3RoaXMuc3R5bGUub3ZlcmZsb3csIHRoaXMuc3R5bGUub3ZlcmZsb3dYLCB0aGlzLnN0eWxlLm92ZXJmbG93WV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmltYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5jc3ModGhpcywgXCJkaXNwbGF5XCIpID09PSBcImlubGluZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyh0aGlzLCBcImZsb2F0XCIpID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LnN1cHBvcnQuaW5saW5lQmxvY2tOZWVkc0xheW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheSh0aGlzLm5vZGVOYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmxpbmUtbGV2ZWwgZWxlbWVudHMgYWNjZXB0IGlubGluZS1ibG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2stbGV2ZWwgZWxlbWVudHMgbmVlZCB0byBiZSBpbmxpbmUgd2l0aCBsYXlvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLnpvb20gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KHByb3BbcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgKGlmIG5lZWRlZCkgYW5kIGFkZCB0byBzcGVjaWFsRWFzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAob3B0LnNwZWNpYWxFYXNpbmcgPSBvcHQuc3BlY2lhbEVhc2luZyB8fCB7fSlbcF0gPSBwcm9wW3BdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFtwXSA9IHByb3BbcF1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0Lm92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3B0LmN1ckFuaW0gPSBqUXVlcnkuZXh0ZW5kKHt9LCBwcm9wKTtcblxuICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKHByb3AsIGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBuZXcgalF1ZXJ5LmZ4KHNlbGYsIG9wdCwgbmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJmeHR5cGVzLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZVt2YWwgPT09IFwidG9nZ2xlXCIgPyBoaWRkZW4gPyBcInNob3dcIiA6IFwiaGlkZVwiIDogdmFsXShwcm9wKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gcmZ4bnVtLmV4ZWModmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGUuY3VyKHRydWUpIHx8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwYXJzZUZsb2F0KHBhcnRzWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHBhcnRzWzNdIHx8IFwicHhcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSBzdGFydGluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bml0ICE9PSBcInB4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKHNlbGYsIG5hbWUsIChlbmQgfHwgMSkgKyB1bml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAoKGVuZCB8fCAxKSAvIGUuY3VyKHRydWUpKSAqIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoc2VsZiwgbmFtZSwgc3RhcnQgKyB1bml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gKChwYXJ0c1sxXSA9PT0gXCItPVwiID8gLTEgOiAxKSAqIGVuZCkgKyBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmN1c3RvbShzdGFydCwgZW5kLCB1bml0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmN1c3RvbShzdGFydCwgdmFsLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIEpTIHN0cmljdCBjb21wbGlhbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoY2xlYXJRdWV1ZSwgZ290b0VuZCkge1xuICAgICAgICAgICAgdmFyIHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cbiAgICAgICAgICAgIGlmIChjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZShbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZ28gaW4gcmV2ZXJzZSBvcmRlciBzbyBhbnl0aGluZyBhZGRlZCB0byB0aGUgcXVldWUgZHVyaW5nIHRoZSBsb29wIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGltZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcnNbaV0uZWxlbSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdvdG9FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSB0aGUgbmV4dCBzdGVwIHRvIGJlIHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzW2ldKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWRcbiAgICAgICAgICAgIGlmICghZ290b0VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnZW5GeCh0eXBlLCBudW0pIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgICAgIGpRdWVyeS5lYWNoKGZ4QXR0cnMuY29uY2F0LmFwcGx5KFtdLCBmeEF0dHJzLnNsaWNlKDAsIG51bSkpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvYmpbdGhpc10gPSB0eXBlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIsIDEpLFxuICAgICAgICBzbGlkZVVwOiBnZW5GeChcImhpZGVcIiwgMSksXG4gICAgICAgIHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiLCAxKSxcbiAgICAgICAgZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG4gICAgICAgIGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfVxuICAgIH0sIGZ1bmN0aW9uIChuYW1lLCBwcm9wcykge1xuICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUocHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBzcGVlZDogZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGZuKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCh7fSwgc3BlZWQpIDoge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pc0Z1bmN0aW9uKHNwZWVkKSAmJiBzcGVlZCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogc3BlZWQsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbihlYXNpbmcpICYmIGVhc2luZ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcbiAgICAgICAgICAgICAgICBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbb3B0LmR1cmF0aW9uXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cbiAgICAgICAgICAgIC8vIFF1ZXVlaW5nXG4gICAgICAgICAgICBvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuICAgICAgICAgICAgb3B0LmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHQucXVldWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihvcHQub2xkKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQub2xkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG9wdDtcbiAgICAgICAgfSxcblxuICAgICAgICBlYXNpbmc6IHtcbiAgICAgICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKHAsIG4sIGZpcnN0TnVtLCBkaWZmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0TnVtICsgZGlmZiAqIHA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3dpbmc6IGZ1bmN0aW9uIChwLCBuLCBmaXJzdE51bSwgZGlmZikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKC1NYXRoLmNvcyhwICogTWF0aC5QSSkgLyAyKSArIDAuNSkgKiBkaWZmICsgZmlyc3ROdW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGltZXJzOiBbXSxcblxuICAgICAgICBmeDogZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIHByb3ApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICAgICAgdGhpcy5wcm9wID0gcHJvcDtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLm9yaWcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9yaWcgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZngucHJvdG90eXBlID0ge1xuICAgICAgICAvLyBTaW1wbGUgZnVuY3Rpb24gZm9yIHNldHRpbmcgYSBzdHlsZSB2YWx1ZVxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIChqUXVlcnkuZnguc3RlcFt0aGlzLnByb3BdIHx8IGpRdWVyeS5meC5zdGVwLl9kZWZhdWx0KSh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc2l6ZVxuICAgICAgICBjdXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1bdGhpcy5wcm9wXSAhPSBudWxsICYmICghdGhpcy5lbGVtLnN0eWxlIHx8IHRoaXMuZWxlbS5zdHlsZVt0aGlzLnByb3BdID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbVt0aGlzLnByb3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgciA9IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyh0aGlzLmVsZW0sIHRoaXMucHJvcCkpO1xuICAgICAgICAgICAgcmV0dXJuIHIgJiYgciA+IC0xMDAwMCA/IHIgOiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFN0YXJ0IGFuIGFuaW1hdGlvbiBmcm9tIG9uZSBudW1iZXIgdG8gYW5vdGhlclxuICAgICAgICBjdXN0b206IGZ1bmN0aW9uIChmcm9tLCB0bywgdW5pdCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBqUXVlcnkubm93KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gdG87XG4gICAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0IHx8IHRoaXMudW5pdCB8fCBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLm5vdyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhdGUgPSAwO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGZ4ID0galF1ZXJ5LmZ4O1xuICAgICAgICAgICAgZnVuY3Rpb24gdChnb3RvRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3RlcChnb3RvRW5kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdC5lbGVtID0gdGhpcy5lbGVtO1xuXG4gICAgICAgICAgICBpZiAodCgpICYmIGpRdWVyeS50aW1lcnMucHVzaCh0KSAmJiAhdGltZXJJZCkge1xuICAgICAgICAgICAgICAgIHRpbWVySWQgPSBzZXRJbnRlcnZhbChmeC50aWNrLCBmeC5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU2ltcGxlICdzaG93JyBmdW5jdGlvblxuICAgICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBSZW1lbWJlciB3aGVyZSB3ZSBzdGFydGVkLCBzbyB0aGF0IHdlIGNhbiBnbyBiYWNrIHRvIGl0IGxhdGVyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZ1t0aGlzLnByb3BdID0galF1ZXJ5LnN0eWxlKHRoaXMuZWxlbSwgdGhpcy5wcm9wKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQmVnaW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2Ugc3RhcnQgYXQgYSBzbWFsbCB3aWR0aC9oZWlnaHQgdG8gYXZvaWQgYW55XG4gICAgICAgICAgICAvLyBmbGFzaCBvZiBjb250ZW50XG4gICAgICAgICAgICB0aGlzLmN1c3RvbSh0aGlzLnByb3AgPT09IFwid2lkdGhcIiB8fCB0aGlzLnByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMCwgdGhpcy5jdXIoKSk7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGJ5IHNob3dpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzLmVsZW0pLnNob3coKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTaW1wbGUgJ2hpZGUnIGZ1bmN0aW9uXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoZXJlIHdlIHN0YXJ0ZWQsIHNvIHRoYXQgd2UgY2FuIGdvIGJhY2sgdG8gaXQgbGF0ZXJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmlnW3RoaXMucHJvcF0gPSBqUXVlcnkuc3R5bGUodGhpcy5lbGVtLCB0aGlzLnByb3ApO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpZGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBCZWdpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICB0aGlzLmN1c3RvbSh0aGlzLmN1cigpLCAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBFYWNoIHN0ZXAgb2YgYW4gYW5pbWF0aW9uXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChnb3RvRW5kKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGpRdWVyeS5ub3coKSwgZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChnb3RvRW5kIHx8IHQgPj0gdGhpcy5vcHRpb25zLmR1cmF0aW9uICsgdGhpcy5zdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdyA9IHRoaXMuZW5kO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5zdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jdXJBbmltW3RoaXMucHJvcF0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLm9wdGlvbnMuY3VyQW5pbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmN1ckFuaW1baV0gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJmbG93ICE9IG51bGwgJiYgIWpRdWVyeS5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5lbGVtLCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goW1wiXCIsIFwiWFwiLCBcIllcIl0sIGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnN0eWxlW1wib3ZlcmZsb3dcIiArIHZhbHVlXSA9IG9wdGlvbnMub3ZlcmZsb3dbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIHRoZSBlbGVtZW50IGlmIHRoZSBcImhpZGVcIiBvcGVyYXRpb24gd2FzIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcy5lbGVtKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgcHJvcGVydGllcywgaWYgdGhlIGl0ZW0gaGFzIGJlZW4gaGlkZGVuIG9yIHNob3duXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZSB8fCB0aGlzLm9wdGlvbnMuc2hvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiB0aGlzLm9wdGlvbnMuY3VyQW5pbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSh0aGlzLmVsZW0sIHAsIHRoaXMub3B0aW9ucy5vcmlnW3BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNvbXBsZXRlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jb21wbGV0ZS5jYWxsKHRoaXMuZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuID0gdCAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuIC8gdGhpcy5vcHRpb25zLmR1cmF0aW9uO1xuXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgZWFzaW5nIGZ1bmN0aW9uLCBkZWZhdWx0cyB0byBzd2luZ1xuICAgICAgICAgICAgICAgIHZhciBzcGVjaWFsRWFzaW5nID0gdGhpcy5vcHRpb25zLnNwZWNpYWxFYXNpbmcgJiYgdGhpcy5vcHRpb25zLnNwZWNpYWxFYXNpbmdbdGhpcy5wcm9wXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEVhc2luZyA9IHRoaXMub3B0aW9ucy5lYXNpbmcgfHwgKGpRdWVyeS5lYXNpbmcuc3dpbmcgPyBcInN3aW5nXCIgOiBcImxpbmVhclwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGpRdWVyeS5lYXNpbmdbc3BlY2lhbEVhc2luZyB8fCBkZWZhdWx0RWFzaW5nXSh0aGlzLnN0YXRlLCBuLCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gdGhpcy5zdGFydCArICgodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHRoaXMucG9zKTtcblxuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIG5leHQgc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LmV4dGVuZChqUXVlcnkuZngsIHtcbiAgICAgICAgdGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lcnNbaV0oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRpbWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZnguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGludGVydmFsOiAxMyxcblxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BlZWRzOiB7XG4gICAgICAgICAgICBzbG93OiA2MDAsXG4gICAgICAgICAgICBmYXN0OiAyMDAsXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHNwZWVkXG4gICAgICAgICAgICBfZGVmYXVsdDogNDAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RlcDoge1xuICAgICAgICAgICAgb3BhY2l0eTogZnVuY3Rpb24gKGZ4KSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKGZ4LmVsZW0sIFwib3BhY2l0eVwiLCBmeC5ub3cpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uIChmeCkge1xuICAgICAgICAgICAgICAgIGlmIChmeC5lbGVtLnN0eWxlICYmIGZ4LmVsZW0uc3R5bGVbZngucHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmeC5lbGVtLnN0eWxlW2Z4LnByb3BdID0gKGZ4LnByb3AgPT09IFwid2lkdGhcIiB8fCBmeC5wcm9wID09PSBcImhlaWdodFwiID8gTWF0aC5tYXgoMCwgZngubm93KSA6IGZ4Lm5vdykgKyBmeC51bml0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ4LmVsZW1bZngucHJvcF0gPSBmeC5ub3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoalF1ZXJ5LmV4cHIgJiYgalF1ZXJ5LmV4cHIuZmlsdGVycykge1xuICAgICAgICBqUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0RGlzcGxheShub2RlTmFtZSkge1xuICAgICAgICBpZiAoIWVsZW1kaXNwbGF5W25vZGVOYW1lXSkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBqUXVlcnkoXCI8XCIgKyBub2RlTmFtZSArIFwiPlwiKS5hcHBlbmRUbyhcImJvZHlcIiksXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IGVsZW0uY3NzKFwiZGlzcGxheVwiKTtcblxuICAgICAgICAgICAgZWxlbS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgaWYgKGRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGRpc3BsYXkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZGlzcGxheVtub2RlTmFtZV0gPSBkaXNwbGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1kaXNwbGF5W25vZGVOYW1lXTtcbiAgICB9XG5cblxuXG5cbiAgICB2YXIgcnRhYmxlID0gL150KD86YWJsZXxkfGgpJC9pLFxuICAgICAgICBycm9vdCA9IC9eKD86Ym9keXxodG1sKSQvaTtcblxuICAgIGlmIChcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICBqUXVlcnkuZm4ub2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXSwgYm94O1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQodGhpcywgb3B0aW9ucywgaSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZWxlbSB8fCAhZWxlbS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtID09PSBlbGVtLm93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkub2Zmc2V0LmJvZHlPZmZzZXQoZWxlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgICAgICAgICB2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuICAgICAgICAgICAgaWYgKCFib3ggfHwgIWpRdWVyeS5jb250YWlucyhkb2NFbGVtLCBlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBib3ggfHwgeyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJvZHkgPSBkb2MuYm9keSxcbiAgICAgICAgICAgICAgICB3aW4gPSBnZXRXaW5kb3coZG9jKSxcbiAgICAgICAgICAgICAgICBjbGllbnRUb3AgPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwLFxuICAgICAgICAgICAgICAgIGNsaWVudExlZnQgPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDAsXG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gKHdpbi5wYWdlWU9mZnNldCB8fCBqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCAmJiBkb2NFbGVtLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcCksXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9ICh3aW4ucGFnZVhPZmZzZXQgfHwgalF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgJiYgZG9jRWxlbS5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdCksXG4gICAgICAgICAgICAgICAgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGpRdWVyeS5mbi5vZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQodGhpcywgb3B0aW9ucywgaSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZWxlbSB8fCAhZWxlbS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtID09PSBlbGVtLm93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkub2Zmc2V0LmJvZHlPZmZzZXQoZWxlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGpRdWVyeS5vZmZzZXQuaW5pdGlhbGl6ZSgpO1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQsIHByZXZPZmZzZXRQYXJlbnQgPSBlbGVtLFxuICAgICAgICAgICAgICAgIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCwgY29tcHV0ZWRTdHlsZSwgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgYm9keSA9IGRvYy5ib2R5LCBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldyxcbiAgICAgICAgICAgICAgICBwcmV2Q29tcHV0ZWRTdHlsZSA9IGRlZmF1bHRWaWV3ID8gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKSA6IGVsZW0uY3VycmVudFN0eWxlLFxuICAgICAgICAgICAgICAgIHRvcCA9IGVsZW0ub2Zmc2V0VG9wLCBsZWZ0ID0gZWxlbS5vZmZzZXRMZWZ0O1xuXG4gICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0gIT09IGJvZHkgJiYgZWxlbSAhPT0gZG9jRWxlbSkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkub2Zmc2V0LnN1cHBvcnRzRml4ZWRQb3NpdGlvbiAmJiBwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbXB1dGVkU3R5bGUgPSBkZWZhdWx0VmlldyA/IGRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCkgOiBlbGVtLmN1cnJlbnRTdHlsZTtcbiAgICAgICAgICAgICAgICB0b3AgLT0gZWxlbS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgbGVmdCAtPSBlbGVtLnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbSA9PT0gb2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5vZmZzZXQuZG9lc05vdEFkZEJvcmRlciAmJiAhKGpRdWVyeS5vZmZzZXQuZG9lc0FkZEJvcmRlckZvclRhYmxlQW5kQ2VsbHMgJiYgcnRhYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgKz0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCArPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldk9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5vZmZzZXQuc3VidHJhY3RzQm9yZGVyRm9yT3ZlcmZsb3dOb3RWaXNpYmxlICYmIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCArPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmV2Q29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICAgICAgdG9wICs9IGJvZHkub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIGxlZnQgKz0gYm9keS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoalF1ZXJ5Lm9mZnNldC5zdXBwb3J0c0ZpeGVkUG9zaXRpb24gJiYgcHJldkNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgICAgIHRvcCArPSBNYXRoLm1heChkb2NFbGVtLnNjcm9sbFRvcCwgYm9keS5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgICAgIGxlZnQgKz0gTWF0aC5tYXgoZG9jRWxlbS5zY3JvbGxMZWZ0LCBib2R5LnNjcm9sbExlZnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGpRdWVyeS5vZmZzZXQgPSB7XG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSwgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgaW5uZXJEaXYsIGNoZWNrRGl2LCB0YWJsZSwgdGQsIGJvZHlNYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KGpRdWVyeS5jc3MoYm9keSwgXCJtYXJnaW5Ub3BcIikpIHx8IDAsXG4gICAgICAgICAgICAgICAgaHRtbCA9IFwiPGRpdiBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO21hcmdpbjowO2JvcmRlcjo1cHggc29saWQgIzAwMDtwYWRkaW5nOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7Jz48ZGl2PjwvZGl2PjwvZGl2Pjx0YWJsZSBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO21hcmdpbjowO2JvcmRlcjo1cHggc29saWQgIzAwMDtwYWRkaW5nOjA7d2lkdGg6MXB4O2hlaWdodDoxcHg7JyBjZWxscGFkZGluZz0nMCcgY2VsbHNwYWNpbmc9JzAnPjx0cj48dGQ+PC90ZD48L3RyPjwvdGFibGU+XCI7XG5cbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoY29udGFpbmVyLnN0eWxlLCB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHRvcDogMCwgbGVmdDogMCwgbWFyZ2luOiAwLCBib3JkZXI6IDAsIHdpZHRoOiBcIjFweFwiLCBoZWlnaHQ6IFwiMXB4XCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgaW5uZXJEaXYgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGNoZWNrRGl2ID0gaW5uZXJEaXYuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHRkID0gaW5uZXJEaXYubmV4dFNpYmxpbmcuZmlyc3RDaGlsZC5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICB0aGlzLmRvZXNOb3RBZGRCb3JkZXIgPSAoY2hlY2tEaXYub2Zmc2V0VG9wICE9PSA1KTtcbiAgICAgICAgICAgIHRoaXMuZG9lc0FkZEJvcmRlckZvclRhYmxlQW5kQ2VsbHMgPSAodGQub2Zmc2V0VG9wID09PSA1KTtcblxuICAgICAgICAgICAgY2hlY2tEaXYuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICAgICAgICBjaGVja0Rpdi5zdHlsZS50b3AgPSBcIjIwcHhcIjtcblxuICAgICAgICAgICAgLy8gc2FmYXJpIHN1YnRyYWN0cyBwYXJlbnQgYm9yZGVyIHdpZHRoIGhlcmUgd2hpY2ggaXMgNXB4XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRzRml4ZWRQb3NpdGlvbiA9IChjaGVja0Rpdi5vZmZzZXRUb3AgPT09IDIwIHx8IGNoZWNrRGl2Lm9mZnNldFRvcCA9PT0gMTUpO1xuICAgICAgICAgICAgY2hlY2tEaXYuc3R5bGUucG9zaXRpb24gPSBjaGVja0Rpdi5zdHlsZS50b3AgPSBcIlwiO1xuXG4gICAgICAgICAgICBpbm5lckRpdi5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICBpbm5lckRpdi5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblxuICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdHNCb3JkZXJGb3JPdmVyZmxvd05vdFZpc2libGUgPSAoY2hlY2tEaXYub2Zmc2V0VG9wID09PSAtNSk7XG5cbiAgICAgICAgICAgIHRoaXMuZG9lc05vdEluY2x1ZGVNYXJnaW5JbkJvZHlPZmZzZXQgPSAoYm9keS5vZmZzZXRUb3AgIT09IGJvZHlNYXJnaW5Ub3ApO1xuXG4gICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBib2R5ID0gY29udGFpbmVyID0gaW5uZXJEaXYgPSBjaGVja0RpdiA9IHRhYmxlID0gdGQgPSBudWxsO1xuICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5pbml0aWFsaXplID0galF1ZXJ5Lm5vb3A7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYm9keU9mZnNldDogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBib2R5Lm9mZnNldFRvcCwgbGVmdCA9IGJvZHkub2Zmc2V0TGVmdDtcblxuICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5pbml0aWFsaXplKCk7XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkub2Zmc2V0LmRvZXNOb3RJbmNsdWRlTWFyZ2luSW5Cb2R5T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdG9wICs9IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhib2R5LCBcIm1hcmdpblRvcFwiKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhib2R5LCBcIm1hcmdpbkxlZnRcIikpIHx8IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucywgaSkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0galF1ZXJ5LmNzcyhlbGVtLCBcInBvc2l0aW9uXCIpO1xuXG4gICAgICAgICAgICAvLyBzZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VyRWxlbSA9IGpRdWVyeShlbGVtKSxcbiAgICAgICAgICAgICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpLFxuICAgICAgICAgICAgICAgIGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJ0b3BcIiksXG4gICAgICAgICAgICAgICAgY3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJsZWZ0XCIpLFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uID0gKHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgJiYgalF1ZXJ5LmluQXJyYXkoJ2F1dG8nLCBbY3VyQ1NTVG9wLCBjdXJDU1NMZWZ0XSkgPiAtMSksXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7fSwgY3VyUG9zaXRpb24gPSB7fSwgY3VyVG9wLCBjdXJMZWZ0O1xuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBhYnNvbHV0ZVxuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1clRvcCA9IGNhbGN1bGF0ZVBvc2l0aW9uID8gY3VyUG9zaXRpb24udG9wIDogcGFyc2VJbnQoY3VyQ1NTVG9wLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIGN1ckxlZnQgPSBjYWxjdWxhdGVQb3NpdGlvbiA/IGN1clBvc2l0aW9uLmxlZnQgOiBwYXJzZUludChjdXJDU1NMZWZ0LCAxMCkgfHwgMDtcblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMuY2FsbChlbGVtLCBpLCBjdXJPZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b3AgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByb3BzLnRvcCA9IChvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3ApICsgY3VyVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMubGVmdCA9IChvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCkgKyBjdXJMZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXCJ1c2luZ1wiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVzaW5nLmNhbGwoZWxlbSwgcHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJFbGVtLmNzcyhwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpc1swXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF0sXG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCksXG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSBycm9vdC50ZXN0KG9mZnNldFBhcmVudFswXS5ub2RlTmFtZSkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBlbGVtZW50IG1hcmdpbnNcbiAgICAgICAgICAgIC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG4gICAgICAgICAgICAvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuICAgICAgICAgICAgb2Zmc2V0LnRvcCAtPSBwYXJzZUZsb2F0KGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5Ub3BcIikpIHx8IDA7XG4gICAgICAgICAgICBvZmZzZXQubGVmdCAtPSBwYXJzZUZsb2F0KGpRdWVyeS5jc3MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIpKSB8fCAwO1xuXG4gICAgICAgICAgICAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcbiAgICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0gcGFyc2VGbG9hdChqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJUb3BXaWR0aFwiKSkgfHwgMDtcbiAgICAgICAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnRbMF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIpKSB8fCAwO1xuXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgdHdvIG9mZnNldHNcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmICghcnJvb3QudGVzdChvZmZzZXRQYXJlbnQubm9kZU5hbWUpICYmIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIpID09PSBcInN0YXRpY1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG4gICAgalF1ZXJ5LmVhY2goW1wiTGVmdFwiLCBcIlRvcFwiXSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IFwic2Nyb2xsXCIgKyBuYW1lO1xuXG4gICAgICAgIGpRdWVyeS5mblttZXRob2RdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdLCB3aW47XG5cbiAgICAgICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHNjcm9sbCBvZmZzZXRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luID0gZ2V0V2luZG93KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaSA/IHZhbCA6IGpRdWVyeSh3aW4pLnNjcm9sbExlZnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID8gdmFsIDogalF1ZXJ5KHdpbikuc2Nyb2xsVG9wKClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW4gPSBnZXRXaW5kb3coZWxlbSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNjcm9sbCBvZmZzZXRcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luID8gKFwicGFnZVhPZmZzZXRcIiBpbiB3aW4pID8gd2luW2kgPyBcInBhZ2VZT2Zmc2V0XCIgOiBcInBhZ2VYT2Zmc2V0XCJdIDpcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgJiYgd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFttZXRob2RdIHx8XG4gICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC5ib2R5W21ldGhvZF0gOlxuICAgICAgICAgICAgICAgICAgICBlbGVtW21ldGhvZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnZXRXaW5kb3coZWxlbSkge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmlzV2luZG93KGVsZW0pID9cbiAgICAgICAgICAgIGVsZW0gOlxuICAgICAgICAgICAgZWxlbS5ub2RlVHlwZSA9PT0gOSA/XG4gICAgICAgICAgICAgICAgZWxlbS5kZWZhdWx0VmlldyB8fCBlbGVtLnBhcmVudFdpbmRvdyA6XG4gICAgICAgICAgICAgICAgZmFsc2U7XG4gICAgfVxuXG5cblxuXG4gICAgLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG4gICAgalF1ZXJ5LmVhY2goW1wiSGVpZ2h0XCIsIFwiV2lkdGhcIl0sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG5cbiAgICAgICAgdmFyIHR5cGUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gaW5uZXJIZWlnaHQgYW5kIGlubmVyV2lkdGhcbiAgICAgICAgalF1ZXJ5LmZuW1wiaW5uZXJcIiArIG5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0gP1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyh0aGlzWzBdLCB0eXBlLCBcInBhZGRpbmdcIikpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoXG4gICAgICAgIGpRdWVyeS5mbltcIm91dGVyXCIgKyBuYW1lXSA9IGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdID9cbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGpRdWVyeS5jc3ModGhpc1swXSwgdHlwZSwgbWFyZ2luID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIpKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBqUXVlcnkuZm5bdHlwZV0gPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICAgICAgLy8gR2V0IHdpbmRvdyB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXTtcbiAgICAgICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaXplID09IG51bGwgPyBudWxsIDogdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHNpemUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZlt0eXBlXShzaXplLmNhbGwodGhpcywgaSwgc2VsZlt0eXBlXSgpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuaXNXaW5kb3coZWxlbSkgP1xuICAgICAgICAgICAgICAgIC8vIEV2ZXJ5b25lIGVsc2UgdXNlIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCBvciBkb2N1bWVudC5ib2R5IGRlcGVuZGluZyBvbiBRdWlya3MgdnMgU3RhbmRhcmRzIG1vZGVcbiAgICAgICAgICAgICAgICBlbGVtLmRvY3VtZW50LmNvbXBhdE1vZGUgPT09IFwiQ1NTMUNvbXBhdFwiICYmIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIgKyBuYW1lXSB8fFxuICAgICAgICAgICAgICAgIGVsZW0uZG9jdW1lbnQuYm9keVtcImNsaWVudFwiICsgbmFtZV0gOlxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuICAgICAgICAgICAgICAgIChlbGVtLm5vZGVUeXBlID09PSA5KSA/IC8vIGlzIGl0IGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdLCB3aGljaGV2ZXIgaXMgZ3JlYXRlclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIgKyBuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVtcInNjcm9sbFwiICsgbmFtZV0sIGVsZW0uZG9jdW1lbnRFbGVtZW50W1wic2Nyb2xsXCIgKyBuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVtcIm9mZnNldFwiICsgbmFtZV0sIGVsZW0uZG9jdW1lbnRFbGVtZW50W1wib2Zmc2V0XCIgKyBuYW1lXVxuICAgICAgICAgICAgICAgICAgICApIDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgb3Igc2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBzaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChqUXVlcnkuY3NzKGVsZW0sIHR5cGUpKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50IChkZWZhdWx0IHRvIHBpeGVscyBpZiB2YWx1ZSBpcyB1bml0bGVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzKHR5cGUsIHR5cGVvZiBzaXplID09PSBcInN0cmluZ1wiID8gc2l6ZSA6IHNpemUgKyBcInB4XCIpO1xuICAgICAgICB9O1xuXG4gICAgfSk7XG5cblxufSkod2luZG93KTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgd2luZG93LmpRdWVyeVNHID0galF1ZXJ5Lm5vQ29uZmxpY3QodHJ1ZSk7XG5cbn0pLmNhbGwodGhpcyk7IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIGxpbmUgMSwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbmRpdiNzZWxlY3RvcmdhZGdldF9tYWluIHtcXG4gICAgYXppbXV0aDogY2VudGVyICFpbXBvcnRhbnQ7XFxuICAgIGJhY2tncm91bmQtYXR0YWNobWVudDogc2Nyb2xsICFpbXBvcnRhbnQ7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCUgMCUgIWltcG9ydGFudDtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdCAhaW1wb3J0YW50O1xcbiAgICBib3JkZXItY29sbGFwc2U6IHNlcGFyYXRlICFpbXBvcnRhbnQ7XFxuICAgIGJvcmRlci1zcGFjaW5nOiAwICFpbXBvcnRhbnQ7XFxuICAgIGJvdHRvbTogYXV0byAhaW1wb3J0YW50O1xcbiAgICBjYXB0aW9uLXNpZGU6IHRvcCAhaW1wb3J0YW50O1xcbiAgICBjbGVhcjogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBjbGlwOiBhdXRvICFpbXBvcnRhbnQ7XFxuICAgIGNvbG9yOiBibGFjayAhaW1wb3J0YW50O1xcbiAgICBjb250ZW50OiBub3JtYWwgIWltcG9ydGFudDtcXG4gICAgY291bnRlci1pbmNyZW1lbnQ6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgY291bnRlci1yZXNldDogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBjdXJzb3I6IGF1dG8gIWltcG9ydGFudDtcXG4gICAgZGlyZWN0aW9uOiBsdHIgIWltcG9ydGFudDtcXG4gICAgZWxldmF0aW9uOiBsZXZlbCAhaW1wb3J0YW50O1xcbiAgICBlbXB0eS1jZWxsczogc2hvdyAhaW1wb3J0YW50O1xcbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZiAhaW1wb3J0YW50O1xcbiAgICBmb250LXZhcmlhbnQ6IG5vcm1hbCAhaW1wb3J0YW50O1xcbiAgICBmb250LXdlaWdodDogbm9ybWFsICFpbXBvcnRhbnQ7XFxuICAgIGhlaWdodDogYXV0byAhaW1wb3J0YW50O1xcbiAgICBsZWZ0OiBhdXRvICFpbXBvcnRhbnQ7XFxuICAgIGxldHRlci1zcGFjaW5nOiBub3JtYWwgIWltcG9ydGFudDtcXG4gICAgbGluZS1oZWlnaHQ6IG5vcm1hbCAhaW1wb3J0YW50O1xcbiAgICBsaXN0LXN0eWxlLWltYWdlOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIGxpc3Qtc3R5bGUtcG9zaXRpb246IG91dHNpZGUgIWltcG9ydGFudDtcXG4gICAgbGlzdC1zdHlsZS10eXBlOiBkaXNjICFpbXBvcnRhbnQ7XFxuICAgIG1heC1oZWlnaHQ6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgbWF4LXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIG1pbi1oZWlnaHQ6IDAgIWltcG9ydGFudDtcXG4gICAgbWluLXdpZHRoOiAwICFpbXBvcnRhbnQ7XFxuICAgIG9ycGhhbnM6IDIgIWltcG9ydGFudDtcXG4gICAgb3V0bGluZS1jb2xvcjogaW52ZXJ0ICFpbXBvcnRhbnQ7XFxuICAgIG91dGxpbmUtc3R5bGU6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgb3V0bGluZS13aWR0aDogbWVkaXVtICFpbXBvcnRhbnQ7XFxuICAgIG92ZXJmbG93OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxuICAgIHBhZ2UtYnJlYWstYWZ0ZXI6IGF1dG8gIWltcG9ydGFudDtcXG4gICAgcGFnZS1icmVhay1iZWZvcmU6IGF1dG8gIWltcG9ydGFudDtcXG4gICAgcGFnZS1icmVhay1pbnNpZGU6IGF1dG8gIWltcG9ydGFudDtcXG4gICAgdGFibGUtbGF5b3V0OiBhdXRvICFpbXBvcnRhbnQ7XFxuICAgIHRleHQtYWxpZ246IGxlZnQgIWltcG9ydGFudDtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIHRleHQtaW5kZW50OiAwICFpbXBvcnRhbnQ7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIHRvcDogYXV0byAhaW1wb3J0YW50O1xcbiAgICB1bmljb2RlLWJpZGk6IG5vcm1hbCAhaW1wb3J0YW50O1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmUgIWltcG9ydGFudDtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZSAhaW1wb3J0YW50O1xcbiAgICB3aGl0ZS1zcGFjZTogbm9ybWFsICFpbXBvcnRhbnQ7XFxuICAgIHdpZG93czogMiAhaW1wb3J0YW50O1xcbiAgICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcbiAgICB3b3JkLXNwYWNpbmc6IG5vcm1hbCAhaW1wb3J0YW50O1xcbiAgICBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcXG4gICAgei1pbmRleDogOTk5OTk5OSAhaW1wb3J0YW50O1xcbiAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xcbiAgICByaWdodDogNXB4ICFpbXBvcnRhbnQ7XFxuICAgIG1hcmdpbjogNXB4ICFpbXBvcnRhbnQ7XFxuICAgIHBhZGRpbmc6IDVweCAhaW1wb3J0YW50O1xcbiAgICBmb250LXNpemU6IDE0cHggIWltcG9ydGFudDtcXG4gICAgZmxvYXQ6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2sgIWltcG9ydGFudDtcXG4gICAgZm9udC1zdHlsZTogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZSAhaW1wb3J0YW50O1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0ICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgNzEsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG5kaXYjc2VsZWN0b3JnYWRnZXRfbWFpbiAqLFxcbi5zZWxlY3RvcmdhZGdldF9jbGVhbixcXG4uc2VsZWN0b3JnYWRnZXRfY2xlYW4gKiB7XFxuICAgIGF6aW11dGg6IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1hdHRhY2htZW50OiBzY3JvbGw7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IDAlIDAlO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0O1xcbiAgICBib3JkZXItY29sbGFwc2U6IHNlcGFyYXRlO1xcbiAgICBib3JkZXItc3BhY2luZzogMDtcXG4gICAgYm90dG9tOiBhdXRvO1xcbiAgICBjYXB0aW9uLXNpZGU6IHRvcDtcXG4gICAgY2xlYXI6IG5vbmU7XFxuICAgIGNsaXA6IGF1dG87XFxuICAgIGNvbG9yOiBibGFjaztcXG4gICAgY29udGVudDogbm9ybWFsO1xcbiAgICBjb3VudGVyLWluY3JlbWVudDogbm9uZTtcXG4gICAgY291bnRlci1yZXNldDogbm9uZTtcXG4gICAgY3Vyc29yOiBhdXRvO1xcbiAgICBkaXJlY3Rpb246IGx0cjtcXG4gICAgZWxldmF0aW9uOiBsZXZlbDtcXG4gICAgZW1wdHktY2VsbHM6IHNob3c7XFxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcbiAgICBmb250LXZhcmlhbnQ6IG5vcm1hbDtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgICBsZWZ0OiBhdXRvO1xcbiAgICBsZXR0ZXItc3BhY2luZzogbm9ybWFsO1xcbiAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xcbiAgICBsaXN0LXN0eWxlLWltYWdlOiBub25lO1xcbiAgICBsaXN0LXN0eWxlLXBvc2l0aW9uOiBvdXRzaWRlO1xcbiAgICBsaXN0LXN0eWxlLXR5cGU6IGRpc2M7XFxuICAgIG1heC1oZWlnaHQ6IG5vbmU7XFxuICAgIG1heC13aWR0aDogbm9uZTtcXG4gICAgbWluLWhlaWdodDogMDtcXG4gICAgbWluLXdpZHRoOiAwO1xcbiAgICBvcnBoYW5zOiAyO1xcbiAgICBvdXRsaW5lLWNvbG9yOiBpbnZlcnQ7XFxuICAgIG91dGxpbmUtc3R5bGU6IG5vbmU7XFxuICAgIG91dGxpbmUtd2lkdGg6IG1lZGl1bTtcXG4gICAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAgIHBhZ2UtYnJlYWstYWZ0ZXI6IGF1dG87XFxuICAgIHBhZ2UtYnJlYWstYmVmb3JlOiBhdXRvO1xcbiAgICBwYWdlLWJyZWFrLWluc2lkZTogYXV0bztcXG4gICAgdGFibGUtbGF5b3V0OiBhdXRvO1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIHRleHQtaW5kZW50OiAwO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgdG9wOiBhdXRvO1xcbiAgICB1bmljb2RlLWJpZGk6IG5vcm1hbDtcXG4gICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgICB3aWRvd3M6IDI7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICB3b3JkLXNwYWNpbmc6IG5vcm1hbDtcXG4gICAgcmlnaHQ6IDBweDtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGZsb2F0OiBub25lO1xcbiAgICBmb250LXN0eWxlOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuXFxuXFxuLyogbGluZSAxMzYsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4uc2VsZWN0b3JnYWRnZXRfY2xlYW4gYSB7XFxuICAgIGNvbG9yOiBibHVlO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5cXG4vKiBsaW5lIDE0MiwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbmRpdiNzZWxlY3RvcmdhZGdldF9tYWluIC5zZWxlY3RvcmdhZGdldF9pbnB1dF9maWVsZCB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgbWFyZ2luOiAwIDdweCAwIDA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZWRlZGU7XFxuICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZWVlO1xcbiAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNlZWU7XFxuICAgIGZvbnQtZmFtaWx5OiBcXFwiTHVjaWRhIEdyYW5kZVxcXCIsIFRhaG9tYSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgY29sb3I6ICM1NjU2NTY7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgcGFkZGluZzogNXB4IDhweCA2cHggN3B4O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDE2MSwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbmRpdiNzZWxlY3RvcmdhZGdldF9tYWluIC5zZWxlY3RvcmdhZGdldF93aXphcmQgLnNlbGVjdG9yZ2FkZ2V0X2lucHV0X2ZpZWxkIHtcXG4gICAgbWFyZ2luOiA3cHggM3B4IDdweCAzcHg7XFxuICAgIGZsb2F0OiBub25lO1xcbiAgICBkaXNwbGF5OiBpbmxpbmU7XFxufVxcblxcblxcbi8qIGxpbmUgMTY3LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuZGl2I3NlbGVjdG9yZ2FkZ2V0X21haW4gLnNlbGVjdG9yZ2FkZ2V0X3Byb21wdCB7XFxuICAgIG1hcmdpbjogM3B4IDBweCAzcHggMHB4O1xcbiAgICBmb250LWZhbWlseTogXFxcIkx1Y2lkYSBHcmFuZGVcXFwiLCBUYWhvbWEsIEFyaWFsLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgZmxvYXQ6IG5vbmU7XFxufVxcblxcblxcbi8qIGxpbmUgMTc0LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuZGl2I3NlbGVjdG9yZ2FkZ2V0X21haW4gLnNlbGVjdG9yZ2FkZ2V0X3dpemFyZCAjc2VsZWN0b3JnYWRnZXRfcGF0aF9maWVsZCB7XFxuICAgIG1hcmdpbjogNXB4IDBweDtcXG4gICAgY2xlYXI6IGJvdGg7XFxuICAgIGZsb2F0OiBub25lO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuXFxuLyogbGluZSAxODEsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4uc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMEYwICFpbXBvcnRhbnQ7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAxODYsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4uc2VsZWN0b3JnYWRnZXRfc3VnZ2VzdGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGNSAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiBub25lICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMTkxLCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuLnNlbGVjdG9yZ2FkZ2V0X2JvcmRlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50O1xcbiAgICB6LWluZGV4OiA5OTk5OTkgIWltcG9ydGFudDtcXG4gICAgYmFja2dyb3VuZDogd2hpdGUgIWltcG9ydGFudDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogb3JhbmdlICFpbXBvcnRhbnQ7XFxuICAgIG1hcmdpbjogMHB4ICFpbXBvcnRhbnQ7XFxuICAgIHBhZGRpbmc6IDBweCAhaW1wb3J0YW50O1xcbiAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xcbiAgICBmbG9hdDogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBib3JkZXI6IDAgIWltcG9ydGFudDtcXG4gICAgZm9udC1zdHlsZTogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBvdXRsaW5lOiAwICFpbXBvcnRhbnQ7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZSAhaW1wb3J0YW50O1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0ICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjA3LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuLnNlbGVjdG9yZ2FkZ2V0X2JvdHRvbV9ib3JkZXIge1xcbiAgICBmb250LXNpemU6IDEwcHggIWltcG9ydGFudDtcXG4gICAgcGFkZGluZzogMnB4IDBweCAycHggNXB4ICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjEyLCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuLnNlbGVjdG9yZ2FkZ2V0X2JvcmRlcl9yZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjAwICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjE5LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuLnNlbGVjdG9yZ2FkZ2V0X3JlamVjdGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0YwMCAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiBub25lICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjI1LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuaW1nLnNlbGVjdG9yZ2FkZ2V0X3JlamVjdGVkIHtcXG4gICAgYm9yZGVyOiA1cHggc29saWQgI0YwMCAhaW1wb3J0YW50O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDIyOSwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbmltZy5zZWxlY3RvcmdhZGdldF9zdWdnZXN0ZWQge1xcbiAgICBib3JkZXI6IDVweCBzb2xpZCAjRkY1ICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjMzLCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuaW1nLnNlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkIHtcXG4gICAgYm9yZGVyOiA1cHggc29saWQgIzBGMCAhaW1wb3J0YW50O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDIzOCwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbiNzZWxlY3RvcmdhZGdldF9tYWluLnNlbGVjdG9yZ2FkZ2V0X3RvcCB7XFxuICAgIHRvcDogNXB4ICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjQyLCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuI3NlbGVjdG9yZ2FkZ2V0X21haW4uc2VsZWN0b3JnYWRnZXRfYm90dG9tIHtcXG4gICAgYm90dG9tOiA1cHggIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAyNDYsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4jc2VsZWN0b3JnYWRnZXRfbWFpbiBpbnB1dCB7XFxuICAgIG1hcmdpbi1yaWdodDogMTBweCAhaW1wb3J0YW50O1xcbiAgICBmb250LXNpemU6IDE1cHggIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAyNTEsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4jc2VsZWN0b3JnYWRnZXRfcGF0aF9maWVsZCB7XFxuICAgIHdpZHRoOiA0MDBweCAhaW1wb3J0YW50O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDI1NSwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbiNzZWxlY3RvcmdhZGdldF9tYWluIC5zZWxlY3RvcmdhZGdldF9uZXdfbGluZSB7XFxuICAgIGNsZWFyOiBib3RoO1xcbn1cXG5cXG5cXG4vKiBsaW5lIDI1OSwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbiNzZWxlY3RvcmdhZGdldF9tYWluIC5zZWxlY3RvcmdhZGdldF9vcHRpb24ge1xcbiAgICBmbG9hdDogbGVmdDtcXG59XFxuXFxuXFxuLyogbGluZSAyNjMsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4jc2VsZWN0b3JnYWRnZXRfbWFpbiAuc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWRfb3B0aW9uIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICBpZiAoZXJyb3JMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICB2YXIgZXJyb3JMaXN0ZW5lcjtcblxuICAgIC8vIEFkZGluZyBhbiBlcnJvciBsaXN0ZW5lciBpcyBub3Qgb3B0aW9uYWwgYmVjYXVzZVxuICAgIC8vIGlmIGFuIGVycm9yIGlzIHRocm93biBvbiBhbiBldmVudCBlbWl0dGVyIHdlIGNhbm5vdFxuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBhY3R1YWwgZXZlbnQgd2UgYXJlIHdhaXRpbmcgd2lsbFxuICAgIC8vIGJlIGZpcmVkLiBUaGUgcmVzdWx0IGNvdWxkIGJlIGEgc2lsZW50IHdheSB0byBjcmVhdGVcbiAgICAvLyBtZW1vcnkgb3IgZmlsZSBkZXNjcmlwdG9yIGxlYWtzLCB3aGljaCBpcyBzb21ldGhpbmdcbiAgICAvLyB3ZSBzaG91bGQgYXZvaWQuXG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG5cbiAgICAgIGVtaXR0ZXIub25jZSgnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBlbWl0dGVyLm9uY2UobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gIH0pO1xufVxuIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5pbXBvcnQgbGlzdFRvU3R5bGVzIGZyb20gJy4vbGlzdFRvU3R5bGVzJ1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuIiwiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cbiIsImltcG9ydCB7IFNlbGVjdG9yR2FkZ2V0IH0gZnJvbSBcIkBzcGlkZXItcnVsZWdlbi92ZW5kb3JcIlxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJ1xuaW1wb3J0IHsgZ2V0VXJscyB9IGZyb20gXCIuL3V0aWxzXCJcblxuY29uc3QgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKVxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmVtaXR0ZXIgPSBlbWl0dGVyXG5cbmNvbnN0IHBvcnQgPSBjaHJvbWUucnVudGltZS5jb25uZWN0KHtcbiAgICBuYW1lOiAnY29udGVudC1zY3JpcHQnXG59KVxuXG5wb3J0Lm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihoYW5kbGVNZXNzYWdlRnJvbURldnRvb2xzKVxucG9ydC5vbkRpc2Nvbm5lY3QuYWRkTGlzdGVuZXIoaGFuZGxlRGlzY29ubmVjdClcblxubGV0IHBhdGhTdG9yZSA9ICcnXG5cbmVtaXR0ZXIub24oXCJzZXRQYXRoXCIsIChlKSA9PiB7XG4gICAgaWYgKHBhdGhTdG9yZSAhPT0gZSkge1xuICAgICAgICBwYXRoU3RvcmUgPSBlXG4gICAgICAgIHNlbmRNZXNzYWdlVG9EZXZ0b29scyh7IHR5cGU6IFwic2VsZWN0b3I6dXBkYXRlXCIsIHZhbHVlOiBlIH0pXG4gICAgfVxufSlcblxuZnVuY3Rpb24gc2VuZE1lc3NhZ2VUb0RldnRvb2xzKG1zZykge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UobXNnKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNZXNzYWdlRnJvbURldnRvb2xzKGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICBjYXNlIFwic2VsZWN0b3I6bG9hZFwiOlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJiYWNrZW5kIC0gbG9hZCBwYXRoOiBcIiwgZS52YWx1ZSlcbiAgICAgICAgICAgIC8vIGVuc3VyZSBvcGVuXG4gICAgICAgICAgICBjb25zdCBzZyA9IFNlbGVjdG9yR2FkZ2V0LnRvZ2dsZU9wZW4oKVxuICAgICAgICAgICAgcGF0aFN0b3JlID0gc2cucmVmcmVzaEZyb21QYXRoKHsgdmFsdWU6IGUudmFsdWUgfSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgXCJzZWxlY3RvcjpkZWFjdGl2ZVwiOlxuICAgICAgICAgICAgU2VsZWN0b3JHYWRnZXQudG9nZ2xlQ2xvc2UoKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcImxvY2F0aW9uOmhyZWZcIjpcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZS52YWx1ZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcImV4dHJhY3Q6dXJsc1wiOlxuICAgICAgICAgICAgc2VuZE1lc3NhZ2VUb0RldnRvb2xzKHsgdHlwZTogXCJleHRyYWN0ZWQ6dXJsc1wiLCB2YWx1ZTogZ2V0VXJscyhlLnZhbHVlKSB9KVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICBTZWxlY3RvckdhZGdldC50b2dnbGVDbG9zZSgpXG59XG5cbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRVcmxzKGNzc1NlbGVjdG9yKSB7XG4gICAgaWYgKCFjc3NTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgY29uc3QgZG9tTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY3NzU2VsZWN0b3IpXG4gICAgY29uc3QgdXJscyA9IG5ldyBTZXQoKVxuICAgIGNvbnN0IGhhc1NlZW4gPSBuZXcgU2V0KClcblxuICAgIGZ1bmN0aW9uIGNiKG5vZGUpIHtcbiAgICAgICAgaWYgKGhhc1NlZW4uaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc1NlZW4uYWRkKG5vZGUpXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gKG5vZGUuaHJlZiB8fCAnJykudHJpbSgpXG4gICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICB1cmxzLmFkZCh1cmwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBkb21JdGVtIG9mIGRvbUxpc3QpIHtcbiAgICAgICAgZG9tVHJhdmVyc2UoZG9tSXRlbSwgY2IpXG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHVybHMpO1xufVxuXG5mdW5jdGlvbiBkb21UcmF2ZXJzZShkb21JdGVtLCBjYikge1xuICAgIGNvbnN0IGdvSW50byA9IGNiKGRvbUl0ZW0pXG4gICAgaWYgKGdvSW50byAmJiBkb21JdGVtLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGRvbUl0ZW0uY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgZG9tVHJhdmVyc2Uobm9kZSwgY2IpXG4gICAgICAgIH1cbiAgICB9XG59Il0sInNvdXJjZVJvb3QiOiIifQ==