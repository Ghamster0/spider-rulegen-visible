/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/backend.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@spider-rulegen/vendor/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/index.js ***!
  \******************************************************/
/*! exports provided: SelectorGadget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selectorgadget_css_selectorgadget_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selectorgadget/css/selectorgadget.css */ "./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css");
/* harmony import */ var _selectorgadget_css_selectorgadget_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_selectorgadget_css_selectorgadget_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _selectorgadget_js_jquery_bind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectorgadget/js/jquery-bind */ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/jquery-bind.js");
/* harmony import */ var _selectorgadget_js_jquery_bind__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_selectorgadget_js_jquery_bind__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _selectorgadget_js_diff_bind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectorgadget/js/diff-bind */ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/diff-bind.js");
/* harmony import */ var _selectorgadget_js_diff_bind__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_selectorgadget_js_diff_bind__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _selectorgadget_js_core_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectorgadget/js/core/core */ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/core.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectorGadget", function() { return _selectorgadget_js_core_core__WEBPACK_IMPORTED_MODULE_3__["SelectorGadget"]; });






/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css":
/*!***********************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../../css-loader!../../../../postcss-loader/src??ref--2-2!./selectorgadget.css */ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/src/index.js?!./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../../vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("4bfbbf6b", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/core.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/core.js ***!
  \****************************************************************************/
/*! exports provided: SelectorGadget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectorGadget", function() { return SelectorGadget; });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom */ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/dom.js");

/*
 The MIT License
 Copyright (c) 2012 Andrew Cantino
 Copyright (c) 2009 Andrew Cantino & Kyle Maxwell
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/



function SelectorGadget() { }

SelectorGadget.prototype.border_width = 5;

SelectorGadget.prototype.border_padding = 2;

SelectorGadget.prototype.b_top = null;

SelectorGadget.prototype.b_left = null;

SelectorGadget.prototype.b_right = null;

SelectorGadget.prototype.b_bottom = null;

SelectorGadget.prototype.selected = [];

SelectorGadget.prototype.rejected = [];

SelectorGadget.prototype.special_mode = null;

SelectorGadget.prototype.path_output_field = null;

SelectorGadget.prototype.sg_div = null;

SelectorGadget.prototype.ignore_class = 'selectorgadget_ignore';

SelectorGadget.prototype.unbound = false;

SelectorGadget.prototype.prediction_helper = new _dom__WEBPACK_IMPORTED_MODULE_0__["DomPredictionHelper"]();

SelectorGadget.prototype.restricted_elements = jQuerySG.map(['html', 'body', 'head', 'base'], function (selector) {
    return jQuerySG(selector).get(0);
});

SelectorGadget.prototype.makeBorders = function (orig_elem, makeRed) {
    var elem, height, left, p, path_to_show, top, width;
    this.removeBorders();
    this.setupBorders();
    if (orig_elem.parentNode) {
        path_to_show = orig_elem.parentNode.tagName.toLowerCase() + ' ' + orig_elem.tagName.toLowerCase();
    } else {
        path_to_show = orig_elem.tagName.toLowerCase();
    }
    elem = jQuerySG(orig_elem);
    p = elem.offset();
    top = p.top;
    left = p.left;
    width = elem.outerWidth();
    height = elem.outerHeight();
    this.b_top.css('width', this.px(width + this.border_padding * 2 + this.border_width * 2)).css('top', this.px(top - this.border_width - this.border_padding)).css('left', this.px(left - this.border_padding - this.border_width));
    this.b_bottom.css('width', this.px(width + this.border_padding * 2 + this.border_width * 2 - 5)).css('top', this.px(top + height + this.border_padding)).css('left', this.px(left - this.border_padding - this.border_width)).text(path_to_show);
    this.b_left.css('height', this.px(height + this.border_padding * 2)).css('top', this.px(top - this.border_padding)).css('left', this.px(left - this.border_padding - this.border_width));
    this.b_right.css('height', this.px(height + this.border_padding * 2)).css('top', this.px(top - this.border_padding)).css('left', this.px(left + width + this.border_padding));
    this.b_right.get(0).target_elem = this.b_left.get(0).target_elem = this.b_top.get(0).target_elem = this.b_bottom.get(0).target_elem = orig_elem;
    if (makeRed || elem.hasClass("selectorgadget_suggested") || elem.hasClass("selectorgadget_selected")) {
        this.b_top.addClass('selectorgadget_border_red');
        this.b_bottom.addClass('selectorgadget_border_red');
        this.b_left.addClass('selectorgadget_border_red');
        this.b_right.addClass('selectorgadget_border_red');
    } else {
        if (this.b_top.hasClass('selectorgadget_border_red')) {
            this.b_top.removeClass('selectorgadget_border_red');
            this.b_bottom.removeClass('selectorgadget_border_red');
            this.b_left.removeClass('selectorgadget_border_red');
            this.b_right.removeClass('selectorgadget_border_red');
        }
    }
    return this.showBorders();
};

SelectorGadget.prototype.px = function (p) {
    return p + 'px';
};

SelectorGadget.prototype.showBorders = function () {
    this.b_top.show();
    this.b_bottom.show();
    this.b_left.show();
    return this.b_right.show();
};

SelectorGadget.prototype.removeBorders = function () {
    if (this.b_top) {
        this.b_top.hide();
        this.b_bottom.hide();
        this.b_left.hide();
        return this.b_right.hide();
    }
};

SelectorGadget.prototype.setupBorders = function () {
    var width;
    if (!this.b_top) {
        width = this.border_width + 'px';
        this.b_top = jQuerySG('<div>').addClass('selectorgadget_border').css('height', width).hide().bind("mousedown.sg", {
            'self': this
        }, this.sgMousedown);
        this.b_bottom = jQuerySG('<div>').addClass('selectorgadget_border').addClass('selectorgadget_bottom_border').css('height', this.px(this.border_width + 6)).hide().bind("mousedown.sg", {
            'self': this
        }, this.sgMousedown);
        this.b_left = jQuerySG('<div>').addClass('selectorgadget_border').css('width', width).hide().bind("mousedown.sg", {
            'self': this
        }, this.sgMousedown);
        this.b_right = jQuerySG('<div>').addClass('selectorgadget_border').css('width', width).hide().bind("mousedown.sg", {
            'self': this
        }, this.sgMousedown);
        return this.addBorderToDom();
    }
};

SelectorGadget.prototype.addBorderToDom = function () {
    document.body.appendChild(this.b_top.get(0));
    document.body.appendChild(this.b_bottom.get(0));
    document.body.appendChild(this.b_left.get(0));
    return document.body.appendChild(this.b_right.get(0));
};

SelectorGadget.prototype.removeBorderFromDom = function () {
    if (this.b_top) {
        this.b_top.remove();
        this.b_bottom.remove();
        this.b_left.remove();
        this.b_right.remove();
        return this.b_top = this.b_bottom = this.b_left = this.b_right = null;
    }
};

SelectorGadget.prototype.selectable = function (elem) {
    return !this.css_restriction || (this.css_restriction && jQuerySG(elem).is(this.css_restriction));
};

SelectorGadget.prototype.sgMouseover = function (e) {
    var gadget, parent, self;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    if (this === document.body || this === document.body.parentNode) {
        return false;
    }
    self = jQuerySG(this);
    gadget.unhighlightIframes();
    if (self.is("iframe")) {
        gadget.highlightIframe(self, e);
    }
    if (gadget.special_mode !== 'd') {
        parent = gadget.firstSelectedOrSuggestedParent(this);
        if (parent !== null && parent !== this && gadget.selectable(parent)) {
            gadget.makeBorders(parent, true);
        } else {
            if (gadget.selectable(self)) {
                gadget.makeBorders(this);
            }
        }
    } else {
        if (!jQuerySG('.selectorgadget_selected', this).get(0)) {
            if (gadget.selectable(self)) {
                gadget.makeBorders(this);
            }
        }
    }
    return false;
};

SelectorGadget.prototype.firstSelectedOrSuggestedParent = function (elem) {
    var orig;
    orig = elem;
    if (jQuerySG(elem).hasClass('selectorgadget_suggested') || jQuerySG(elem).hasClass('selectorgadget_selected')) {
        return elem;
    }
    while (elem.parentNode && (elem = elem.parentNode)) {
        if (jQuerySG.inArray(elem, this.restricted_elements) === -1) {
            if (jQuerySG(elem).hasClass('selectorgadget_suggested') || jQuerySG(elem).hasClass('selectorgadget_selected')) {
                return elem;
            }
        }
    }
    return null;
};

SelectorGadget.prototype.sgMouseout = function (e) {
    var elem, gadget;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    if (this === document.body || this === document.body.parentNode) {
        return false;
    }
    elem = jQuerySG(this);
    gadget.removeBorders();
    return false;
};

SelectorGadget.prototype.highlightIframe = function (elem, click) {
    var block, instructions, p, self, src, target;
    p = elem.offset();
    self = this;
    target = jQuerySG(click.target);
    block = jQuerySG('<div>').css('position', 'absolute').css('z-index', '99998').css('width', this.px(elem.outerWidth())).css('height', this.px(elem.outerHeight())).css('top', this.px(p.top)).css('left', this.px(p.left)).css('background-color', '#AAA').css('opacity', '0.6').addClass("selectorgadget_iframe").addClass('selectorgadget_clean');
    instructions = jQuerySG("<div><span>This is an iframe.  To select in it, </span></div>").addClass("selectorgadget_iframe_info").addClass("selectorgadget_iframe").addClass('selectorgadget_clean');
    instructions.css({
        width: "200px",
        border: "1px solid #888"
    }, {
        padding: "5px",
        "background-color": "white",
        position: "absolute",
        "z-index": "99999",
        top: this.px(p.top + (elem.outerHeight() / 4.0)),
        left: this.px(p.left + (elem.outerWidth() - 200) / 2.0),
        height: "150px"
    });
    src = null;
    try {
        src = elem.contents().get(0).location.href;
    } catch (e) {
        src = elem.attr("src");
    }
    instructions.append(jQuerySG("<a target='_top'>click here to open it</a>").attr("href", src));
    instructions.append(jQuerySG("<span>, then relaunch SelectorGadget.</span>"));
    document.body.appendChild(instructions.get(0));
    block.click(function () {
        if (self.selectable(target)) {
            return target.mousedown();
        }
    });
    return document.body.appendChild(block.get(0));
};

SelectorGadget.prototype.unhighlightIframes = function (elem, click) {
    return jQuerySG(".selectorgadget_iframe").remove();
};

SelectorGadget.prototype.sgMousedown = function (e) {
    var elem, gadget, potential_elem, prediction, w_elem;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    elem = this;
    w_elem = jQuerySG(elem);
    if (w_elem.hasClass('selectorgadget_border')) {
        elem = elem.target_elem || elem;
        w_elem = jQuerySG(elem);
    }
    if (elem === document.body || elem === document.body.parentNode) {
        return;
    }
    if (gadget.special_mode !== 'd') {
        potential_elem = gadget.firstSelectedOrSuggestedParent(elem);
        if (potential_elem !== null && potential_elem !== elem) {
            elem = potential_elem;
            w_elem = jQuerySG(elem);
        }
    } else {
        if (jQuerySG('.selectorgadget_selected', this).get(0)) {
            gadget.blockClicksOn(elem);
        }
    }
    if (!gadget.selectable(w_elem)) {
        gadget.removeBorders();
        gadget.blockClicksOn(elem);
        return false;
    }
    if (w_elem.hasClass('selectorgadget_selected')) {
        w_elem.removeClass('selectorgadget_selected');
        gadget.selected.splice(jQuerySG.inArray(elem, gadget.selected), 1);
    } else if (w_elem.hasClass("selectorgadget_rejected")) {
        w_elem.removeClass('selectorgadget_rejected');
        gadget.rejected.splice(jQuerySG.inArray(elem, gadget.rejected), 1);
    } else if (w_elem.hasClass("selectorgadget_suggested")) {
        w_elem.addClass('selectorgadget_rejected');
        gadget.rejected.push(elem);
    } else {
        w_elem.addClass('selectorgadget_selected');
        gadget.selected.push(elem);
    }
    gadget.clearSuggested();
    prediction = gadget.prediction_helper.predictCss(jQuerySG(gadget.selected), jQuerySG(gadget.rejected.concat(gadget.restricted_elements)));
    gadget.suggestPredicted(prediction);
    gadget.setPath(prediction);
    gadget.removeBorders();
    gadget.blockClicksOn(elem);
    w_elem.trigger("mouseover.sg", {
        'self': gadget
    });
    return false;
};

SelectorGadget.prototype.setupEventHandlers = function () {
    jQuerySG("*:not(.selectorgadget_ignore)").bind("mouseover.sg", {
        'self': this
    }, this.sgMouseover);
    jQuerySG("*:not(.selectorgadget_ignore)").bind("mouseout.sg", {
        'self': this
    }, this.sgMouseout);
    jQuerySG("*:not(.selectorgadget_ignore)").bind("mousedown.sg", {
        'self': this
    }, this.sgMousedown);
    jQuerySG("html").bind("keydown.sg", {
        'self': this
    }, this.listenForActionKeys);
    return jQuerySG("html").bind("keyup.sg", {
        'self': this
    }, this.clearActionKeys);
};

SelectorGadget.prototype.listenForActionKeys = function (e) {
    var gadget;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    if (e.keyCode === 16 || e.keyCode === 68) {
        gadget.special_mode = 'd';
        return gadget.removeBorders();
    }
};

SelectorGadget.prototype.clearActionKeys = function (e) {
    var gadget;
    gadget = e.data.self;
    if (gadget.unbound) {
        return true;
    }
    gadget.removeBorders();
    return gadget.special_mode = null;
};

SelectorGadget.prototype.blockClicksOn = function (elem) {
    var block, p;
    elem = jQuerySG(elem);
    p = elem.offset();
    block = jQuerySG('<div>').css('position', 'absolute').css('z-index', '9999999').css('width', this.px(elem.outerWidth())).css('height', this.px(elem.outerHeight())).css('top', this.px(p.top)).css('left', this.px(p.left)).css('background-color', '');
    document.body.appendChild(block.get(0));
    setTimeout((function () {
        return block.remove();
    }), 400);
    return false;
};

SelectorGadget.prototype.setMode = function (mode) {
    if (mode === 'browse') {
        this.removeEventHandlers();
    } else if (mode === 'interactive') {
        this.setupEventHandlers();
    }
    return this.clearSelected();
};

SelectorGadget.prototype.suggestPredicted = function (prediction) {
    var count;
    if (prediction && prediction !== '') {
        count = 0;
        jQuerySG(prediction).each(function () {
            count += 1;
            if (!jQuerySG(this).hasClass('selectorgadget_selected') && !jQuerySG(this).hasClass('selectorgadget_ignore') && !jQuerySG(this).hasClass('selectorgadget_rejected')) {
                return jQuerySG(this).addClass('selectorgadget_suggested');
            }
        });
        if (this.clear_button) {
            if (count > 0) {
                return this.clear_button.attr('value', 'Clear (' + count + ')');
            } else {
                return this.clear_button.attr('value', 'Clear');
            }
        }
    }
};

// Modify: emit setPath event
SelectorGadget.prototype.setPath = function (prediction) {
    let path = ''
    if (prediction && prediction.length > 0) {
        path = prediction
    }
    this.path_output_field.value = path
    this.emitter && this.emitter.emit('setPath', path)
    return path
};

SelectorGadget.prototype.refreshFromPath = function (e) {
    var path, self;
    self = (e && e.data && e.data.self) || this;

    // Modify: set path from e
    if (e && e.value !== undefined) {
        self.path_output_field.value = e.value
    }

    path = self.path_output_field.value;
    self.clearSelected();
    self.suggestPredicted(path);
    return self.setPath(path);
};

SelectorGadget.prototype.showXPath = function (e) {
    var path, self;
    self = (e && e.data && e.data.self) || this;
    path = self.path_output_field.value;
    if (path === 'No valid path found.') {
        return;
    }
    return prompt("The CSS selector '" + path + "' as an XPath is shown below.  Please report any bugs that you find with this converter.", self.prediction_helper.cssToXPath(path));
};

SelectorGadget.prototype.clearSelected = function (e) {
    var self;
    self = (e && e.data && e.data.self) || this;
    self.selected = [];
    self.rejected = [];
    jQuerySG('.selectorgadget_selected').removeClass('selectorgadget_selected');
    jQuerySG('.selectorgadget_rejected').removeClass('selectorgadget_rejected');
    self.removeBorders();
    return self.clearSuggested();
};

SelectorGadget.prototype.clearEverything = function (e) {
    var self;
    self = (e && e.data && e.data.self) || this;
    self.clearSelected();
    return self.resetOutputs();
};

SelectorGadget.prototype.resetOutputs = function () {
    return this.setPath();
};

SelectorGadget.prototype.clearSuggested = function () {
    jQuerySG('.selectorgadget_suggested').removeClass('selectorgadget_suggested');
    if (this.clear_button) {
        return this.clear_button.attr('value', 'Clear');
    }
};

SelectorGadget.prototype.showHelp = function () {
    return alert("Click on a page element that you would like your selector to match (it will turn green). SelectorGadget will then generate a minimal CSS selector for that element, and will highlight (yellow) everything that is matched by the selector. Now click on a highlighted element to reject it (red), or click on an unhighlighted element to add it (green). Through this process of selection and rejection, SelectorGadget helps you to come up with the perfect CSS selector for your needs.\n\nHolding 'shift' while moving the mouse will let you select elements inside of other selected elements.");
};

SelectorGadget.prototype.useRemoteInterface = function () {
    return window.sg_options && window.sg_options.remote_interface;
};

SelectorGadget.prototype.updateRemoteInterface = function (data_obj) {
    return this.addScript(this.composeRemoteUrl(window.sg_options.remote_interface, data_obj));
};

SelectorGadget.prototype.composeRemoteUrl = function (url, data_obj) {
    var key, params;
    params = (url.split("?")[1] && url.split("?")[1].split("&")) || [];
    params.push("t=" + (new Date()).getTime());
    params.push("url=" + encodeURIComponent(window.location.href));
    if (data_obj) {
        for (key in data_obj) {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(data_obj[key]));
        }
    }
    if (this.remote_data) {
        for (key in this.remote_data) {
            params.push(encodeURIComponent("data[" + key + "]") + '=' + encodeURIComponent(this.remote_data[key]));
        }
    }
    return url.split("?")[0] + "?" + params.join("&");
};

SelectorGadget.prototype.addScript = function (src) {
    var head, s;
    s = document.createElement('script');
    s.setAttribute('type', 'text/javascript');
    s.setAttribute('src', src);
    head = document.getElementsByTagName('head')[0];
    if (head) {
        return head.appendChild(s);
    } else {
        return document.body.appendChild(s);
    }
};

// SelectorGadget.prototype.makeInterface = function () {
//     this.sg_div = jQuerySG('<div>').attr('id', 'selectorgadget_main').addClass('selectorgadget_bottom').addClass('selectorgadget_ignore');
//     if (this.useRemoteInterface()) {
//         this.path_output_field = {
//             value: null
//         };
//         this.remote_data = {};
//         this.updateRemoteInterface();
//     } else {
//         this.makeStandardInterface();
//     }
//     return jQuerySG('body').append(this.sg_div);
// };

// Modify: notify parent to show interface
SelectorGadget.prototype.makeInterface = function () {
    this.path_output_field = { value: "" }
}

SelectorGadget.prototype.makeStandardInterface = function () {
    var path, self;
    self = this;
    path = jQuerySG('<input>').attr('id', 'selectorgadget_path_field').addClass('selectorgadget_ignore').addClass('selectorgadget_input_field').keydown(function (e) {
        if (e.keyCode === 13) {
            return self.refreshFromPath(e);
        }
    }).focus(function () {
        return jQuerySG(this).select();
    });
    this.sg_div.append(path);
    this.clear_button = jQuerySG('<input type="button" value="Clear"/>').bind("click", {
        'self': this
    }, this.clearEverything).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field');
    this.sg_div.append(this.clear_button);
    this.sg_div.append(jQuerySG('<input type="button" value="Toggle Position"/>').click(function () {
        if (self.sg_div.hasClass('selectorgadget_top')) {
            return self.sg_div.removeClass('selectorgadget_top').addClass('selectorgadget_bottom');
        } else {
            return self.sg_div.removeClass('selectorgadget_bottom').addClass('selectorgadget_top');
        }
    }).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field'));
    this.sg_div.append(jQuerySG('<input type="button" value="XPath"/>').bind("click", {
        'self': this
    }, this.showXPath).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field'));
    this.sg_div.append(jQuerySG('<input type="button" value="?"/>').bind("click", {
        'self': this
    }, this.showHelp).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field'));
    this.sg_div.append(jQuerySG('<input type="button" value="X"/>').bind("click", {
        'self': this
    }, this.unbindAndRemoveInterface).addClass('selectorgadget_ignore').addClass('selectorgadget_input_field'));
    return this.path_output_field = path.get(0);
};

SelectorGadget.prototype.removeInterface = function (e) {
    // Modify: do nothing, cause no element was insert on makeInterface
    // this.sg_div.remove();
    // return this.sg_div = null;
};

SelectorGadget.prototype.unbind = function (e) {
    var self;
    self = (e && e.data && e.data.self) || this;
    self.unbound = true;
    self.removeBorderFromDom();
    return self.clearSelected();
};

SelectorGadget.prototype.unbindAndRemoveInterface = function (e) {
    var self;
    self = (e && e.data && e.data.self) || this;
    self.unbind();
    return self.removeInterface();
};

SelectorGadget.prototype.setOutputMode = function (e, output_mode) {
    var self;
    self = (e && e.data && e.data.self) || this;
    return self.output_mode = (e && e.data && e.data.mode) || output_mode;
};

SelectorGadget.prototype.rebind = function () {
    this.unbound = false;
    this.clearEverything();
    return this.setupBorders();
};

SelectorGadget.prototype.rebindAndMakeInterface = function () {
    this.makeInterface();
    return this.rebind();
};

SelectorGadget.prototype.randBetween = function (a, b) {
    return Math.floor(Math.random() * b) + a;
};

SelectorGadget.toggle = function (options) {
    if (!window.selector_gadget) {
        window.selector_gadget = new SelectorGadget();
        window.selector_gadget.makeInterface();
        window.selector_gadget.clearEverything();
        window.selector_gadget.setMode('interactive');
        if ((options != null ? options.analytics : void 0) !== false) {
            window.selector_gadget.analytics();
        }
    } else if (window.selector_gadget.unbound) {
        window.selector_gadget.rebindAndMakeInterface();
    } else {
        window.selector_gadget.unbindAndRemoveInterface();
    }
    return jQuerySG('.selector_gadget_loading').remove();
};

// Modify: add SelectorGadget.toggleOpen
SelectorGadget.toggleOpen = function (options) {
    if (!window.selector_gadget) {
        window.selector_gadget = new SelectorGadget();
        window.selector_gadget.makeInterface();
        window.selector_gadget.clearEverything();
        window.selector_gadget.setMode('interactive');
        // if ((options != null ? options.analytics : void 0) !== false) {
        //     window.selector_gadget.analytics();
        // }
    } else if (window.selector_gadget.unbound) {
        window.selector_gadget.rebindAndMakeInterface();
    }
    jQuerySG('.selector_gadget_loading').remove();
    return window.selector_gadget
}

SelectorGadget.toggleClose = function () {
    window.selector_gadget && !window.selector_gadget.unbound && window.selector_gadget.unbindAndRemoveInterface();
    return jQuerySG('.selector_gadget_loading').remove();
}

SelectorGadget.prototype.analytics = function () {
    var cookie, random, referer, today, urchinUrl, uservar, utmac, utmhn, utmn, utmp;
    utmac = 'UA-148948-9';
    utmhn = encodeURIComponent('www.selectorgadget.com');
    utmn = this.randBetween(1000000000, 9999999999);
    cookie = this.randBetween(10000000, 99999999);
    random = this.randBetween(1000000000, 2147483647);
    today = Math.round(new Date().getTime() / 1000.0);
    referer = encodeURIComponent(window.location.href);
    uservar = '-';
    utmp = 'sg';
    urchinUrl = 'http://www.google-analytics.com/__utm.gif?utmwv=1&utmn=' + utmn + '&utmsr=-&utmsc=-&utmul=-&utmje=0&utmfl=-&utmdt=-&utmhn=' + utmhn + '&utmr=' + referer + '&utmp=' + utmp + '&utmac=' + utmac + '&utmcc=__utma%3D' + cookie + '.' + random + '.' + today + '.' + today + '.' + today + '.2%3B%2B__utmb%3D' + cookie + '%3B%2B__utmc%3D' + cookie + '%3B%2B__utmz%3D' + cookie + '.' + today + '.2.2.utmccn%3D(direct)%7Cutmcsr%3D(direct)%7Cutmcmd%3D(none)%3B%2B__utmv%3D' + cookie + '.' + uservar + '%3B';
    return document.body.appendChild(jQuerySG('<img />').attr('src', urchinUrl).get(0));
};

/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/dom.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/js/core/dom.js ***!
  \***************************************************************************/
/*! exports provided: DomPredictionHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomPredictionHelper", function() { return DomPredictionHelper; });

/*
 The MIT License
 Copyright (c) 2012 Andrew Cantino
 Copyright (c) 2009 Andrew Cantino & Kyle Maxwell
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

function DomPredictionHelper() { }

DomPredictionHelper.prototype.recursiveNodes = function (e) {
    var n;
    if (e.nodeName && e.parentNode && e !== document.body) {
        n = this.recursiveNodes(e.parentNode);
    } else {
        n = new Array();
    }
    n.push(e);
    return n;
};

DomPredictionHelper.prototype.escapeCssNames = function (name) {
    if (name) {
        try {
            return name.replace(/\bselectorgadget_\w+\b/g, '').replace(/\\/g, '\\\\').replace(/[\#\;\&\,\.\+\*\~\'\:\"\!\^\$\[\]\(\)\=\>\|\/]/g, function (e) {
                return '\\' + e;
            }).replace(/\s+/, '');
        } catch (e) {
            if (window.console) {
                console.log('---');
                console.log("exception in escapeCssNames");
                console.log(name);
                console.log('---');
            }
            return '';
        }
    } else {
        return '';
    }
};

DomPredictionHelper.prototype.childElemNumber = function (elem) {
    var count;
    count = 0;
    while (elem.previousSibling && (elem = elem.previousSibling)) {
        if (elem.nodeType === 1) {
            count++;
        }
    }
    return count;
};

DomPredictionHelper.prototype.siblingsWithoutTextNodes = function (e) {
    var filtered_nodes, node, nodes, _i, _len;
    nodes = e.parentNode.childNodes;
    filtered_nodes = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        if (node.nodeName.substring(0, 1) === "#") {
            continue;
        }
        if (node === e) {
            break;
        }
        filtered_nodes.push(node);
    }
    return filtered_nodes;
};

DomPredictionHelper.prototype.pathOf = function (elem) {
    var e, j, path, siblings, _i, _len, _ref;
    path = "";
    _ref = this.recursiveNodes(elem);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        if (e) {
            siblings = this.siblingsWithoutTextNodes(e);
            if (e.nodeName.toLowerCase() !== "body") {
                j = siblings.length - 2 < 0 ? 0 : siblings.length - 2;
                while (j < siblings.length) {
                    if (siblings[j] === e) {
                        break;
                    }
                    if (!siblings[j].nodeName.match(/^(script|#.*?)$/i)) {
                        path += this.cssDescriptor(siblings[j]) + (j + 1 === siblings.length ? "+ " : "~ ");
                    }
                    j++;
                }
            }
            path += this.cssDescriptor(e) + " > ";
        }
    }
    return this.cleanCss(path);
};

DomPredictionHelper.prototype.cssDescriptor = function (node) {
    var cssName, escaped, path, _i, _len, _ref;
    path = node.nodeName.toLowerCase();
    escaped = node.id && this.escapeCssNames(new String(node.id));
    if (escaped && escaped.length > 0) {
        path += '#' + escaped;
    }
    if (node.className) {
        _ref = node.className.split(" ");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            cssName = _ref[_i];
            escaped = this.escapeCssNames(cssName);
            if (cssName && escaped.length > 0) {
                path += '.' + escaped;
            }
        }
    }
    if (node.nodeName.toLowerCase() !== "body") {
        path += ':nth-child(' + (this.childElemNumber(node) + 1) + ')';
    }
    return path;
};

DomPredictionHelper.prototype.cssDiff = function (array) {
    var collective_common, cssElem, diff, dmp, encoded_css_array, existing_tokens, part, _i, _j, _len, _len1;
    try {
        dmp = new diff_match_patch();
    } catch (e) {
        throw "Please include the diff_match_patch library.";
    }
    if (typeof array === 'undefined' || array.length === 0) {
        return '';
    }
    existing_tokens = {};
    encoded_css_array = this.encodeCssForDiff(array, existing_tokens);
    collective_common = encoded_css_array.pop();
    for (_i = 0, _len = encoded_css_array.length; _i < _len; _i++) {
        cssElem = encoded_css_array[_i];
        diff = dmp.diff_main(collective_common, cssElem);
        collective_common = '';
        for (_j = 0, _len1 = diff.length; _j < _len1; _j++) {
            part = diff[_j];
            if (part[0] === 0) {
                collective_common += part[1];
            }
        }
    }
    return this.decodeCss(collective_common, existing_tokens);
};

DomPredictionHelper.prototype.tokenizeCss = function (css_string) {
    var char, skip, tokens, word, _i, _len, _ref;
    skip = false;
    word = '';
    tokens = [];
    _ref = this.cleanCss(css_string);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        char = _ref[_i];
        if (skip) {
            skip = false;
        } else if (char === '\\') {
            skip = true;
        } else if (char === '.' || char === ' ' || char === '#' || char === '>' || char === ':' || char === ',' || char === '+' || char === '~') {
            if (word.length > 0) {
                tokens.push(word);
            }
            word = '';
        }
        word += char;
        if (char === ' ' || char === ',') {
            tokens.push(word);
            word = '';
        }
    }
    if (word.length > 0) {
        tokens.push(word);
    }
    return tokens;
};

DomPredictionHelper.prototype.tokenizeCssForDiff = function (css_string) {
    var block, combined_tokens, token, _i, _len, _ref;
    combined_tokens = [];
    block = [];
    _ref = this.tokenizeCss(css_string);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        block.push(token);
        if (token === ' ' && block.length > 0) {
            combined_tokens = combined_tokens.concat(block);
            block = [];
        } else if (token === '+' || token === '~') {
            block = [block.join('')];
        }
    }
    if (block.length > 0) {
        return combined_tokens.concat(block);
    } else {
        return combined_tokens;
    }
};

DomPredictionHelper.prototype.decodeCss = function (string, existing_tokens) {
    var character, inverted, out, _i, _len, _ref;
    inverted = this.invertObject(existing_tokens);
    out = '';
    _ref = string.split('');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        character = _ref[_i];
        out += inverted[character];
    }
    return this.cleanCss(out);
};

DomPredictionHelper.prototype.encodeCssForDiff = function (strings, existing_tokens) {
    var codepoint, out, string, strings_out, token, _i, _j, _len, _len1, _ref;
    codepoint = 50;
    strings_out = [];
    for (_i = 0, _len = strings.length; _i < _len; _i++) {
        string = strings[_i];
        out = new String();
        _ref = this.tokenizeCssForDiff(string);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            token = _ref[_j];
            if (!existing_tokens[token]) {
                existing_tokens[token] = String.fromCharCode(codepoint++);
            }
            out += existing_tokens[token];
        }
        strings_out.push(out);
    }
    return strings_out;
};

DomPredictionHelper.prototype.tokenPriorities = function (tokens) {
    var epsilon, first, i, priorities, second, token, _i, _len;
    epsilon = 0.001;
    priorities = new Array();
    i = 0;
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        first = token.substring(0, 1);
        second = token.substring(1, 2);
        if (first === ':' && second === 'n') {
            priorities[i] = 0;
        } else if (first === '>') {
            priorities[i] = 2;
        } else if (first === '+' || first === '~') {
            priorities[i] = 3;
        } else if (first !== ':' && first !== '.' && first !== '#' && first !== ' ' && first !== '>' && first !== '+' && first !== '~') {
            priorities[i] = 4;
        } else if (first === '.') {
            priorities[i] = 5;
        } else if (first = '#') {
            priorities[i] = 6;
            if (token.match(/\d{3,}/)) {
                priorities[i] = 2.5;
            }
        } else {
            priorities[i] = 0;
        }
        priorities[i] += i * epsilon;
        i++;
    }
    return priorities;
};

DomPredictionHelper.prototype.orderFromPriorities = function (priorities) {
    var i, ordering, tmp, _i, _j, _ref, _ref1;
    tmp = new Array();
    ordering = new Array();
    for (i = _i = 0, _ref = priorities.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        tmp[i] = {
            value: priorities[i],
            original: i
        };
    }
    tmp.sort(function (a, b) {
        return a.value - b.value;
    });
    for (i = _j = 0, _ref1 = priorities.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        ordering[i] = tmp[i].original;
    }
    return ordering;
};

DomPredictionHelper.prototype.simplifyCss = function (css, selected, rejected) {
    var best_so_far, first, got_shorter, i, look_back_index, ordering, part, parts, priorities, second, selector, _i, _ref,
        _this = this;
    parts = this.tokenizeCss(css);
    priorities = this.tokenPriorities(parts);
    ordering = this.orderFromPriorities(priorities);
    selector = this.cleanCss(css);
    look_back_index = -1;
    best_so_far = "";
    if (this.selectorGets('all', selected, selector) && this.selectorGets('none', rejected, selector)) {
        best_so_far = selector;
    }
    got_shorter = true;
    while (got_shorter) {
        got_shorter = false;
        for (i = _i = 0, _ref = parts.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            part = ordering[i];
            if (parts[part].length === 0) {
                continue;
            }
            first = parts[part].substring(0, 1);
            second = parts[part].substring(1, 2);
            if (first === ' ') {
                continue;
            }
            if (this.wouldLeaveFreeFloatingNthChild(parts, part)) {
                continue;
            }
            this._removeElements(part, parts, first, function (selector) {
                if (_this.selectorGets('all', selected, selector) && _this.selectorGets('none', rejected, selector) && (selector.length < best_so_far.length || best_so_far.length === 0)) {
                    best_so_far = selector;
                    got_shorter = true;
                    return true;
                } else {
                    return false;
                }
            });
        }
    }
    return this.cleanCss(best_so_far);
};

DomPredictionHelper.prototype._removeElements = function (part, parts, firstChar, callback) {
    var j, look_back_index, selector, tmp, _i, _j;
    if (firstChar === '+' || firstChar === '~') {
        look_back_index = this.positionOfSpaceBeforeIndexOrLineStart(part, parts);
    } else {
        look_back_index = part;
    }
    tmp = parts.slice(look_back_index, part + 1);
    for (j = _i = look_back_index; look_back_index <= part ? _i <= part : _i >= part; j = look_back_index <= part ? ++_i : --_i) {
        parts[j] = '';
    }
    selector = this.cleanCss(parts.join(''));
    if (selector === '' || !callback(selector)) {
        for (j = _j = look_back_index; look_back_index <= part ? _j <= part : _j >= part; j = look_back_index <= part ? ++_j : --_j) {
            parts[j] = tmp[j - look_back_index];
        }
    }
    return parts;
};

DomPredictionHelper.prototype.positionOfSpaceBeforeIndexOrLineStart = function (part, parts) {
    var i;
    i = part;
    while (i >= 0 && parts[i] !== ' ') {
        i--;
    }
    if (i < 0) {
        i = 0;
    }
    return i;
};

DomPredictionHelper.prototype.wouldLeaveFreeFloatingNthChild = function (parts, part) {
    var i, nth_child_is_on_right, space_is_on_left;
    space_is_on_left = nth_child_is_on_right = false;
    i = part + 1;
    while (i < parts.length && parts[i].length === 0) {
        i++;
    }
    if (i < parts.length && parts[i].substring(0, 2) === ':n') {
        nth_child_is_on_right = true;
    }
    i = part - 1;
    while (i > -1 && parts[i].length === 0) {
        i--;
    }
    if (i < 0 || parts[i] === ' ') {
        space_is_on_left = true;
    }
    return space_is_on_left && nth_child_is_on_right;
};

DomPredictionHelper.prototype.cleanCss = function (css) {
    var cleaned_css, last_cleaned_css;
    cleaned_css = css;
    last_cleaned_css = null;
    while (last_cleaned_css !== cleaned_css) {
        last_cleaned_css = cleaned_css;
        cleaned_css = cleaned_css.replace(/(^|\s+)(\+|\~)/, '').replace(/(\+|\~)\s*$/, '').replace(/>/g, ' > ').replace(/\s*(>\s*)+/g, ' > ').replace(/,/g, ' , ').replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '').replace(/\s*,$/g, '').replace(/^\s*,\s*/g, '').replace(/\s*>$/g, '').replace(/^>\s*/g, '').replace(/[\+\~\>]\s*,/g, ',').replace(/[\+\~]\s*>/g, '>').replace(/\s*(,\s*)+/g, ' , ');
    }
    return cleaned_css;
};

DomPredictionHelper.prototype.getPathsFor = function (nodeset) {
    var node, out, _i, _len;
    out = [];
    for (_i = 0, _len = nodeset.length; _i < _len; _i++) {
        node = nodeset[_i];
        if (node && node.nodeName) {
            out.push(this.pathOf(node));
        }
    }
    return out;
};

DomPredictionHelper.prototype.predictCss = function (s, r) {
    var css, selected, selected_paths, simplest, union, _i, _len;
    if (s.length === 0) {
        return '';
    }
    selected_paths = this.getPathsFor(s);
    css = this.cssDiff(selected_paths);
    simplest = this.simplifyCss(css, s, r);
    if (simplest.length > 0) {
        return simplest;
    }
    union = '';
    for (_i = 0, _len = s.length; _i < _len; _i++) {
        selected = s[_i];
        union = this.pathOf(selected) + ", " + union;
    }
    union = this.cleanCss(union);
    return this.simplifyCss(union, s, r);
};

DomPredictionHelper.prototype.selectorGets = function (type, list, the_selector) {
    if (list.length === 0 && type === 'all') {
        return false;
    }
    if (list.length === 0 && type === 'none') {
        return true;
    }
    try {
        if (type === 'all') {
            return list.not(the_selector).length === 0;
        } else {
            return !(list.is(the_selector));
        }
    } catch (e) {
        if (window.console) {
            console.log("Error on selector: " + the_selector);
        }
        throw e;
    }
};

DomPredictionHelper.prototype.invertObject = function (object) {
    var key, new_object, value;
    new_object = {};
    for (key in object) {
        value = object[key];
        new_object[value] = key;
    }
    return new_object;
};

DomPredictionHelper.prototype.cssToXPath = function (css_string) {
    var css_block, out, token, tokens, _i, _len;
    tokens = this.tokenizeCss(css_string);
    if (tokens[0] && tokens[0] === ' ') {
        tokens.splice(0, 1);
    }
    if (tokens[tokens.length - 1] && tokens[tokens.length - 1] === ' ') {
        tokens.splice(tokens.length - 1, 1);
    }
    css_block = [];
    out = "";
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        if (token === ' ') {
            out += this.cssToXPathBlockHelper(css_block);
            css_block = [];
        } else {
            css_block.push(token);
        }
    }
    return out + this.cssToXPathBlockHelper(css_block);
};

DomPredictionHelper.prototype.cssToXPathBlockHelper = function (css_block) {
    var current, expressions, first, i, out, re, rest, _i, _j, _len, _ref;
    if (css_block.length === 0) {
        return '//';
    }
    out = '//';
    first = css_block[0].substring(0, 1);
    if (first === ',') {
        return " | ";
    }
    if (first === ':' || first === '#' || first === '.') {
        out += '*';
    }
    expressions = [];
    re = null;
    for (_i = 0, _len = css_block.length; _i < _len; _i++) {
        current = css_block[_i];
        first = current.substring(0, 1);
        rest = current.substring(1);
        if (first === ':') {
            if (re = rest.match(/^nth-child\((\d+)\)$/)) {
                expressions.push('(((count(preceding-sibling::*) + 1) = ' + re[1] + ') and parent::*)');
            }
        } else if (first === '.') {
            expressions.push('contains(concat( " ", @class, " " ), concat( " ", "' + rest + '", " " ))');
        } else if (first === '#') {
            expressions.push('(@id = "' + rest + '")');
        } else if (first === ',') {

        } else {
            out += current;
        }
    }
    if (expressions.length > 0) {
        out += '[';
    }
    for (i = _j = 0, _ref = expressions.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        out += expressions[i];
        if (i < expressions.length - 1) {
            out += ' and ';
        }
    }
    if (expressions.length > 0) {
        out += ']';
    }
    return out;
};


/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/diff-bind.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/js/diff-bind.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up.  (0 for infinity)
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // The size beyond which the double-ended diff activates.
  // Double-ending is twice as fast, but less accurate.
  this.Diff_DualThreshold = 32;
  // Tweak the relative importance (0.0 = accuracy, 1.0 = proximity)
  this.Match_Balance = 0.5;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose)
  this.Match_Threshold = 0.5;
  // The min and max cutoffs used when computing text lengths.
  this.Match_MinLength = 100;
  this.Match_MaxLength = 1000;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  /**
   * Compute the number of bits in an int.
   * The normal answer for JavaScript is 32.
   * @return {number} Max bits
   */
  function getMaxBits() {
    var maxbits = 0;
    var oldi = 1;
    var newi = 2;
    while (oldi != newi) {
      maxbits++;
      oldi = newi;
      newi = newi << 1;
    }
    return maxbits;
  }
  // How many bits in a number?
  this.Match_MaxBits = getMaxBits();
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed
 * @param {string} text2 New string to be diffed
 * @param {boolean} opt_checklines Optional speedup flag.  If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff
 * @return {Array.<Array.<*>>} Array of diff tuples
 */
diff_match_patch.prototype.diff_main = function (text1, text2, opt_checklines) {
  // Check for equality (speedup)
  if (text1 == text2) {
    return [[DIFF_EQUAL, text1]];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup)
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup)
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block
  var diffs = this.diff_compute(text1, text2, checklines);

  // Restore the prefix and suffix
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed
 * @param {string} text2 New string to be diffed
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff
 * @return {Array.<Array.<*>>} Array of diff tuples
 * @private
 */
diff_match_patch.prototype.diff_compute = function (text1, text2, checklines) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup)
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup)
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup)
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
    [DIFF_EQUAL, shorttext],
    [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  longtext = shorttext = null;  // Garbage collect

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  // Perform a real diff.
  if (checklines && (text1.length < 100 || text2.length < 100)) {
    // Too trivial for the overhead.
    checklines = false;
  }
  var linearray;
  if (checklines) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars(text1, text2);
    text1 = a[0];
    text2 = a[1];
    linearray = a[2];
  }
  diffs = this.diff_map(text1, text2);
  if (!diffs) {
    // No acceptable result.
    diffs = [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }
  if (checklines) {
    // Convert the diff back to original text.
    this.diff_charsToLines(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push([DIFF_EQUAL, '']);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete >= 1 && count_insert >= 1) {
            // Delete the offending records and add the merged ones.
            var a = this.diff_main(text_delete, text_insert, false);
            diffs.splice(pointer - count_delete - count_insert,
              count_delete + count_insert);
            pointer = pointer - count_delete - count_insert;
            for (var j = a.length - 1; j >= 0; j--) {
              diffs.splice(pointer, 0, a[j]);
            }
            pointer = pointer + a.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = '';
          text_insert = '';
          break;
      }
      pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.
  }
  return diffs;
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string
 * @param {string} text2 Second string
 * @return {Array.<string|Array.<string>>} Three element Array, containing the
 *     encoded text1, the encoded text2 and the array of unique strings.  The
 *     zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars = function (text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode
   * @return {string} Encoded string
   * @private
   */
  function diff_linesToCharsMunge(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
        (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge(text1);
  var chars2 = diff_linesToCharsMunge(text2);
  return [chars1, chars2, lineArray];
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @param {Array.<string>} lineArray Array of unique strings
 * @private
 */
diff_match_patch.prototype.diff_charsToLines = function (diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Explore the intersection points between the two texts.
 * @param {string} text1 Old string to be diffed
 * @param {string} text2 New string to be diffed
 * @return {Array.<Array.<*>>?} Array of diff tuples or null if no diff
 *     available
 * @private
 */
diff_match_patch.prototype.diff_map = function (text1, text2) {
  // Don't run for too long.
  var ms_end = (new Date()).getTime() + this.Diff_Timeout * 1000;
  var max_d = text1.length + text2.length - 1;
  var doubleEnd = this.Diff_DualThreshold * 2 < max_d;
  var v_map1 = [];
  var v_map2 = [];
  var v1 = {};
  var v2 = {};
  v1[1] = 0;
  v2[1] = 0;
  var x, y;
  var footstep;  // Used to track overlapping paths.
  var footsteps = {};
  var done = false;
  // Safari 1.x doesn't have hasOwnProperty
  var hasOwnProperty = !!(footsteps.hasOwnProperty);
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (text1.length + text2.length) % 2;
  for (var d = 0; d < max_d; d++) {
    // Bail out if timeout reached.
    if (this.Diff_Timeout > 0 && (new Date()).getTime() > ms_end) {
      return null;
    }

    // Walk the front path one step.
    v_map1[d] = {};
    for (var k = -d; k <= d; k += 2) {
      if (k == -d || k != d && v1[k - 1] < v1[k + 1]) {
        x = v1[k + 1];
      } else {
        x = v1[k - 1] + 1;
      }
      y = x - k;
      if (doubleEnd) {
        footstep = x + ',' + y;
        if (front && (hasOwnProperty ? footsteps.hasOwnProperty(footstep) :
          (footsteps[footstep] !== undefined))) {
          done = true;
        }
        if (!front) {
          footsteps[footstep] = d;
        }
      }
      while (!done && x < text1.length && y < text2.length &&
        text1.charAt(x) == text2.charAt(y)) {
        x++;
        y++;
        if (doubleEnd) {
          footstep = x + ',' + y;
          if (front && (hasOwnProperty ? footsteps.hasOwnProperty(footstep) :
            (footsteps[footstep] !== undefined))) {
            done = true;
          }
          if (!front) {
            footsteps[footstep] = d;
          }
        }
      }
      v1[k] = x;
      v_map1[d][x + ',' + y] = true;
      if (x == text1.length && y == text2.length) {
        // Reached the end in single-path mode.
        return this.diff_path1(v_map1, text1, text2);
      } else if (done) {
        // Front path ran over reverse path.
        v_map2 = v_map2.slice(0, footsteps[footstep] + 1);
        var a = this.diff_path1(v_map1, text1.substring(0, x),
          text2.substring(0, y));
        return a.concat(this.diff_path2(v_map2, text1.substring(x),
          text2.substring(y)));
      }
    }

    if (doubleEnd) {
      // Walk the reverse path one step.
      v_map2[d] = {};
      for (var k = -d; k <= d; k += 2) {
        if (k == -d || k != d && v2[k - 1] < v2[k + 1]) {
          x = v2[k + 1];
        } else {
          x = v2[k - 1] + 1;
        }
        y = x - k;
        footstep = (text1.length - x) + ',' + (text2.length - y);
        if (!front && (hasOwnProperty ? footsteps.hasOwnProperty(footstep) :
          (footsteps[footstep] !== undefined))) {
          done = true;
        }
        if (front) {
          footsteps[footstep] = d;
        }
        while (!done && x < text1.length && y < text2.length &&
          text1.charAt(text1.length - x - 1) ==
          text2.charAt(text2.length - y - 1)) {
          x++;
          y++;
          footstep = (text1.length - x) + ',' + (text2.length - y);
          if (!front && (hasOwnProperty ? footsteps.hasOwnProperty(footstep) :
            (footsteps[footstep] !== undefined))) {
            done = true;
          }
          if (front) {
            footsteps[footstep] = d;
          }
        }
        v2[k] = x;
        v_map2[d][x + ',' + y] = true;
        if (done) {
          // Reverse path ran over front path.
          v_map1 = v_map1.slice(0, footsteps[footstep] + 1);
          var a = this.diff_path1(v_map1, text1.substring(0, text1.length - x),
            text2.substring(0, text2.length - y));
          return a.concat(this.diff_path2(v_map2,
            text1.substring(text1.length - x),
            text2.substring(text2.length - y)));
        }
      }
    }
  }
  // Number of diffs equals number of characters, no commonality at all.
  return null;
};


/**
 * Work from the middle back to the start to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed
 * @param {string} text2 New string fragment to be diffed
 * @return {Array.<Array.<*>>} Array of diff tuples
 * @private
 */
diff_match_patch.prototype.diff_path1 = function (v_map, text1, text2) {
  var path = [];
  var x = text1.length;
  var y = text2.length;
  /** @type {number?} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d].hasOwnProperty ? v_map[d].hasOwnProperty((x - 1) + ',' + y) :
        (v_map[d][(x - 1) + ',' + y] !== undefined)) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_DELETE, text1.charAt(x)]);
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d].hasOwnProperty ?
        v_map[d].hasOwnProperty(x + ',' + (y - 1)) :
        (v_map[d][x + ',' + (y - 1)] !== undefined)) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[0][1] = text2.charAt(y) + path[0][1];
        } else {
          path.unshift([DIFF_INSERT, text2.charAt(y)]);
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        //if (text1.charAt(x) != text2.charAt(y)) {
        //  throw new Error('No diagonal.  Can\'t happen. (diff_path1)');
        //}
        if (last_op === DIFF_EQUAL) {
          path[0][1] = text1.charAt(x) + path[0][1];
        } else {
          path.unshift([DIFF_EQUAL, text1.charAt(x)]);
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Work from the middle back to the end to determine the path.
 * @param {Array.<Object>} v_map Array of paths.
 * @param {string} text1 Old string fragment to be diffed
 * @param {string} text2 New string fragment to be diffed
 * @return {Array.<Array.<*>>} Array of diff tuples
 * @private
 */
diff_match_patch.prototype.diff_path2 = function (v_map, text1, text2) {
  var path = [];
  var pathLength = 0;
  var x = text1.length;
  var y = text2.length;
  /** @type {number?} */
  var last_op = null;
  for (var d = v_map.length - 2; d >= 0; d--) {
    while (1) {
      if (v_map[d].hasOwnProperty ? v_map[d].hasOwnProperty((x - 1) + ',' + y) :
        (v_map[d][(x - 1) + ',' + y] !== undefined)) {
        x--;
        if (last_op === DIFF_DELETE) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
            [DIFF_DELETE, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_DELETE;
        break;
      } else if (v_map[d].hasOwnProperty ?
        v_map[d].hasOwnProperty(x + ',' + (y - 1)) :
        (v_map[d][x + ',' + (y - 1)] !== undefined)) {
        y--;
        if (last_op === DIFF_INSERT) {
          path[pathLength - 1][1] += text2.charAt(text2.length - y - 1);
        } else {
          path[pathLength++] =
            [DIFF_INSERT, text2.charAt(text2.length - y - 1)];
        }
        last_op = DIFF_INSERT;
        break;
      } else {
        x--;
        y--;
        //if (text1.charAt(text1.length - x - 1) !=
        //    text2.charAt(text2.length - y - 1)) {
        //  throw new Error('No diagonal.  Can\'t happen. (diff_path2)');
        //}
        if (last_op === DIFF_EQUAL) {
          path[pathLength - 1][1] += text1.charAt(text1.length - x - 1);
        } else {
          path[pathLength++] =
            [DIFF_EQUAL, text1.charAt(text1.length - x - 1)];
        }
        last_op = DIFF_EQUAL;
      }
    }
  }
  return path;
};


/**
 * Determine the common prefix of two strings
 * @param {string} text1 First string
 * @param {string} text2 Second string
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function (text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charCodeAt(0) !== text2.charCodeAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
      text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings
 * @param {string} text1 First string
 * @param {string} text2 Second string
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function (text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charCodeAt(text1.length - 1) !==
    text2.charCodeAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * @param {string} text1 First string
 * @param {string} text2 Second string
 * @return {Array.<string>?} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
diff_match_patch.prototype.diff_halfMatch = function (text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 10 || shorttext.length < 1) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string
   * @param {string} shorttext Shorter string
   * @param {number} i Start index of quarter length substring within longtext
   * @return {Array.<string>?} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
        shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
        shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
          shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length >= longtext.length / 2) {
      return [best_longtext_a, best_longtext_b,
        best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI(longtext, shorttext,
    Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI(longtext, shorttext,
    Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 */
diff_match_patch.prototype.diff_cleanupSemantic = function (diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = null;  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_changes1 = 0;
  // Number of characters that changed after the equality.
  var length_changes2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      equalities[equalitiesLength++] = pointer;
      length_changes1 = length_changes2;
      length_changes2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // an insertion or deletion
      length_changes2 += diffs[pointer][1].length;
      if (lastequality !== null && (lastequality.length <= length_changes1) &&
        (lastequality.length <= length_changes2)) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
          [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_changes1 = 0;  // Reset the counters.
        length_changes2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function (diffs) {
  // Define some regex patterns for matching boundaries. 
  var punctuation = /[^a-zA-Z0-9]/;
  var whitespace = /\s/;
  var linebreak = /[\r\n]/;
  var blanklineEnd = /\n\r?\n$/;
  var blanklineStart = /^\r?\n\r?\n/;

  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 5 (best) to 0 (worst).
   * Closure, makes reference to regex patterns defined above.
   * @param {string} one First string
   * @param {string} two Second string
   * @return {number} The score.
   */
  function diff_cleanupSemanticScore(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 5;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var score = 0;
    // One point for non-alphanumeric.
    if (one.charAt(one.length - 1).match(punctuation) ||
      two.charAt(0).match(punctuation)) {
      score++;
      // Two points for whitespace.
      if (one.charAt(one.length - 1).match(whitespace) ||
        two.charAt(0).match(whitespace)) {
        score++;
        // Three points for line breaks.
        if (one.charAt(one.length - 1).match(linebreak) ||
          two.charAt(0).match(linebreak)) {
          score++;
          // Four points for blank lines.
          if (one.match(blanklineEnd) || two.match(blanklineStart)) {
            score++;
          }
        }
      }
    }
    return score;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
      diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore(equality1, edit) +
        diff_cleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore(equality1, edit) +
          diff_cleanupSemanticScore(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};


/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function (diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  var lastequality = '';  // Always equal to equalities[equalitiesLength-1][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // equality found
      if (diffs[pointer][1].length < this.Diff_EditCost &&
        (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = '';
      }
      post_ins = post_del = false;
    } else {  // an insertion or deletion
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
        ((lastequality.length < this.Diff_EditCost / 2) &&
          (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record
        diffs.splice(equalities[equalitiesLength - 1], 0,
          [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = '';
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 */
diff_match_patch.prototype.diff_cleanupMerge = function (diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete !== 0 || count_insert !== 0) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                diffs[pointer - count_delete - count_insert - 1][0] ==
                DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                  text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                  text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_delete - count_insert,
              count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete - count_insert,
              count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
              count_delete + count_insert, [DIFF_DELETE, text_delete],
              [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
            (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
      diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
        diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
          diffs[pointer][1].substring(0, diffs[pointer][1].length -
            diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length)
        == diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
          diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @param {number} loc Location within text1
 * @return {number} Location within text2
 */
diff_match_patch.prototype.diff_xIndex = function (diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @return {string} HTML representation
 */
diff_match_patch.prototype.diff_prettyHtml = function (diffs) {
  var html = [];
  var i = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];   // Operation (insert, delete, equal)
    var data = diffs[x][1]; // Text of change.
    var text = data.replace(/&/g, '&amp;').replace(/</g, '&lt;')
      .replace(/>/g, '&gt;').replace(/\n/g, '&para;<BR>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<INS STYLE="background:#E6FFE6;" TITLE="i=' + i + '">' +
          text + '</INS>';
        break;
      case DIFF_DELETE:
        html[x] = '<DEL STYLE="background:#FFE6E6;" TITLE="i=' + i + '">' +
          text + '</DEL>';
        break;
      case DIFF_EQUAL:
        html[x] = '<SPAN TITLE="i=' + i + '">' + text + '</SPAN>';
        break;
    }
    if (op !== DIFF_DELETE) {
      i += data.length;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @return {string} Source text
 */
diff_match_patch.prototype.diff_text1 = function (diffs) {
  var txt = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      txt[x] = diffs[x][1];
    }
  }
  return txt.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @return {string} Destination text
 */
diff_match_patch.prototype.diff_text2 = function (diffs) {
  var txt = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      txt[x] = diffs[x][1];
    }
  }
  return txt.join('');
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {Array.<Array.<*>>} diffs Array of diff tuples
 * @return {string} Delta text
 */
diff_match_patch.prototype.diff_toDelta = function (diffs) {
  var txt = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        txt[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        txt[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        txt[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  // Opera doesn't know how to encode char 0.
  return txt.join('\t').replace(/\0/g, '%00').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff
 * @param {string} delta Delta text
 * @return {Array.<Array.<*>>} Array of diff tuples
 * @throws {Error} If invalid input
 */
diff_match_patch.prototype.diff_fromDelta = function (text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  // Opera doesn't know how to decode char 0.
  delta = delta.replace(/%00/g, '\0');
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
      // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
            tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
      ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search
 * @param {string} pattern The pattern to search for
 * @param {number} loc The location to search around
 * @return {number?} Best match index or null
 */
diff_match_patch.prototype.match_main = function (text, pattern, loc) {
  loc = Math.max(0, Math.min(loc, text.length - pattern.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (text.length === 0) {
    // Nothing to match.
    return null;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search
 * @param {string} pattern The pattern to search for
 * @param {number} loc The location to search around
 * @return {number?} Best match index or null
 * @private
 */
diff_match_patch.prototype.match_bitap = function (text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet(pattern);

  var score_text_length = text.length;
  // Coerce the text length between reasonable maximums and minimums.
  score_text_length = Math.max(score_text_length, this.Match_MinLength);
  score_text_length = Math.min(score_text_length, this.Match_MaxLength);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc, score_text_length and pattern through being a closure.
   * @param {number} e Number of errors in match
   * @param {number} x Location of match
   * @return {number} Overall score for match
   * @private
   */
  function match_bitapScore(e, x) {
    var d = Math.abs(loc - x);
    return (e / pattern.length / dmp.Match_Balance) +
      (d / score_text_length / (1.0 - dmp.Match_Balance));
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
  }
  // What about in the other direction? (speedup)
  best_loc = text.lastIndexOf(pattern, loc + pattern.length);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore(0, best_loc), score_threshold);
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = null;

  var bin_min, bin_mid;
  var bin_max = Math.max(loc + loc, text.length);
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    var rd = Array(text.length);

    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = loc;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore(d, bin_mid) < score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(0, loc - (bin_mid - loc) - 1);
    var finish = Math.min(text.length - 1, pattern.length + bin_mid);

    if (text.charAt(finish) == pattern.charAt(pattern.length - 1)) {
      rd[finish] = (1 << (d + 1)) - 1;
    } else {
      rd[finish] = (1 << d) - 1;
    }
    for (var j = finish - 1; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following lines generate
      // warnings.
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & s[text.charAt(j)];
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = ((rd[j + 1] << 1) | 1) & s[text.charAt(j)] |
          ((last_rd[j + 1] << 1) | 1) | ((last_rd[j] << 1) | 1) |
          last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore(d, j);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j;
          if (j > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(0, loc - (j - loc));
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode
 * @return {Object} Hash of character locations
 * @private
 */
diff_match_patch.prototype.match_alphabet = function (pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {patch_obj} patch The patch to grow
 * @param {string} text Source text
 * @private
 */
diff_match_patch.prototype.patch_addContext = function (patch, text) {
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
    pattern.length < this.Match_MaxBits - this.Patch_Margin
    - this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
      patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;
  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix !== '') {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
    patch.start2 + patch.length1 + padding);
  if (suffix !== '') {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are two ways to call this function:
 * Method 1:
 * a = Old text, b = New text, c = array of diff tuplle for a to b
 * Method 2:
 * a = Array of diff tuples for text 1 to text 2, b and c undefined
 * @param {string|Array.<Array.<*>>} a Old text (method 1) or Array of diff
 * tuples for text1 to text2 (method 2)
 * @param {string?} b New text (method 1)
 * @param {Array.<Array.<*>>} c Optional array of diff tuples for text1 to text2
 * (method 1)
 * @return {Array.<patch_obj>} Array of patch objects
 */
diff_match_patch.prototype.patch_make = function (a, b, c) {
  var text1, text2, diffs;
  if (typeof b == 'undefined') {
    diffs = a;
    text1 = this.diff_text1(diffs);
    text2 = '';  // text2 is not actually used.
  } else {
    text1 = a;
    text2 = b;
    if (typeof c != 'undefined') {
      diffs = c;
    } else {
      diffs = this.diff_main(text1, text2, true);
      if (diffs.length > 2) {
        this.diff_cleanupSemantic(diffs);
        this.diff_cleanupEfficiency(diffs);
      }
    }
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  var prepatch_text = text1;  // Recreate the patches to determine context info.
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
          postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
          postpatch_text.substring(char_count2 + diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
          patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext(patch, prepatch_text);
            patches.push(patch);
            patch = new patch_obj();
            patchDiffLength = 0;
            prepatch_text = postpatch_text;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {Array.<patch_obj>} patches Array of patch objects
 * @param {string} text Old text
 * @return {Array.<string|Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values
 */
diff_match_patch.prototype.patch_apply = function (patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new patch_obj();
    patchCopy.diffs = patch.diffs.slice();
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  patches = patchesCopy;

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc = this.match_main(text, text1, expected_loc);
    if (start_loc === null) {
      // No match found.  :(
      results[x] = false;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2 = text.substring(start_loc, start_loc + text1.length);
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
          this.diff_text2(patches[x].diffs) +
          text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indicies.
        var diffs = this.diff_main(text1, text2, false);
        this.diff_cleanupSemanticLossless(diffs);
        var index1 = 0;
        var index2;
        for (var y = 0; y < patches[x].diffs.length; y++) {
          var mod = patches[x].diffs[y];
          if (mod[0] !== DIFF_EQUAL) {
            index2 = this.diff_xIndex(diffs, index1);
          }
          if (mod[0] === DIFF_INSERT) {  // Insertion
            text = text.substring(0, start_loc + index2) + mod[1] +
              text.substring(start_loc + index2);
          } else if (mod[0] === DIFF_DELETE) {  // Deletion
            text = text.substring(0, start_loc + index2) +
              text.substring(start_loc + this.diff_xIndex(diffs,
                index1 + mod[1].length));
          }
          if (mod[0] !== DIFF_DELETE) {
            index1 += mod[1].length;
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * @param {Array.<patch_obj>} patches Array of patch objects
 * @return {string} The padding string added to each side.
 * @private
 */
diff_match_patch.prototype.patch_addPadding = function (patches) {
  var nullPadding = '';
  for (var x = 0; x < this.Patch_Margin; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += nullPadding.length;
    patches[x].start2 += nullPadding.length;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= nullPadding.length;  // Should be 0.
    patch.start2 -= nullPadding.length;  // Should be 0.
    patch.length1 += nullPadding.length;
    patch.length2 += nullPadding.length;
  } else if (nullPadding.length > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = nullPadding.length - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += nullPadding.length;
    patch.length2 += nullPadding.length;
  } else if (nullPadding.length > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = nullPadding.length - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * @param {Array.<patch_obj>} patches Array of patch objects
 */
diff_match_patch.prototype.patch_splitMax = function (patches) {
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 > this.Match_MaxBits) {
      var bigpatch = patches[x];
      // Remove the big old patch.
      patches.splice(x, 1);
      var patch_size = this.Match_MaxBits;
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = '';
      while (bigpatch.diffs.length !== 0) {
        // Create one of several smaller patches.
        var patch = new patch_obj();
        var empty = true;
        patch.start1 = start1 - precontext.length;
        patch.start2 = start2 - precontext.length;
        if (precontext !== '') {
          patch.length1 = patch.length2 = precontext.length;
          patch.diffs.push([DIFF_EQUAL, precontext]);
        }
        while (bigpatch.diffs.length !== 0 &&
          patch.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            // Insertions are harmless.
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
            patch.diffs.push(bigpatch.diffs.shift());
            empty = false;
          } else {
            // Deletion or equality.  Only take as much as we can stomach.
            diff_text = diff_text.substring(0, patch_size - patch.length1 -
              this.Patch_Margin);
            patch.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty = false;
            }
            patch.diffs.push([diff_type, diff_text]);
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        // Compute the head context for the next patch.
        precontext = this.diff_text2(patch.diffs);
        precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
        // Append the end context for this patch.
        var postcontext = this.diff_text1(bigpatch.diffs)
          .substring(0, this.Patch_Margin);
        if (postcontext !== '') {
          patch.length1 += postcontext.length;
          patch.length2 += postcontext.length;
          if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
            patch.diffs[patch.diffs.length - 1][1] += postcontext;
          } else {
            patch.diffs.push([DIFF_EQUAL, postcontext]);
          }
        }
        if (!empty) {
          patches.splice(x++, 0, patch);
        }
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {Array.<patch_obj>} patches Array of patch objects
 * @return {string} Text representation of patches
 */
diff_match_patch.prototype.patch_toText = function (patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of patch objects.
 * @param {string} textline Text representation of patches
 * @return {Array.<patch_obj>} Array of patch objects
 * @throws {Error} If invalid input
 */
diff_match_patch.prototype.patch_fromText = function (textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  // Opera doesn't know how to decode char 0.
  textline = textline.replace(/%00/g, '\0');
  var text = textline.split('\n');
  var textPointer = 0;
  while (textPointer < text.length) {
    var m = text[textPointer].match(/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
function patch_obj() {
  this.diffs = [];
  /** @type {number?} */
  this.start1 = null;
  /** @type {number?} */
  this.start2 = null;
  this.length1 = 0;
  this.length2 = 0;
}


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string
 */
patch_obj.prototype.toString = function () {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var txt = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    txt[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  // Opera doesn't know how to encode char 0.
  return txt.join('').replace(/\0/g, '%00').replace(/%20/g, ' ');
};

(function () {

  window.diff_match_patch = diff_match_patch;

}).call(this);

/***/ }),

/***/ "./node_modules/@spider-rulegen/vendor/selectorgadget/js/jquery-bind.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@spider-rulegen/vendor/selectorgadget/js/jquery-bind.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * jQuery JavaScript Library v1.4.3
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Oct 14 23:10:06 2010 -0400
 */

(function (window, undefined) {

    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document;
    var jQuery = (function () {

        // Define a local copy of jQuery
        var jQuery = function (selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context);
        },

            // Map over jQuery in case of overwrite
            _jQuery = window.jQuery,

            // Map over the $ in case of overwrite
            _$ = window.$,

            // A central reference to the root jQuery(document)
            rootjQuery,

            // A simple way to check for HTML strings or ID strings
            // (both of which we optimize for)
            quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,

            // Is it a simple selector
            isSimple = /^.[^:#\[\.,]*$/,

            // Check if a string has a non-whitespace character in it
            rnotwhite = /\S/,
            rwhite = /\s/,

            // Used for trimming whitespace
            trimLeft = /^\s+/,
            trimRight = /\s+$/,

            // Check for non-word characters
            rnonword = /\W/,

            // Check for digits
            rdigit = /\d/,

            // Match a standalone tag
            rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

            // JSON RegExp
            rvalidchars = /^[\],:{}\s]*$/,
            rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
            rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
            rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

            // Useragent RegExp
            rwebkit = /(webkit)[ \/]([\w.]+)/,
            ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
            rmsie = /(msie) ([\w.]+)/,
            rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

            // Keep a UserAgent string for use with jQuery.browser
            userAgent = navigator.userAgent,

            // For matching the engine and version of the browser
            browserMatch,

            // Has the ready events already been bound?
            readyBound = false,

            // The functions to execute on DOM ready
            readyList = [],

            // The ready event handler
            DOMContentLoaded,

            // Save a reference to some core methods
            toString = Object.prototype.toString,
            hasOwn = Object.prototype.hasOwnProperty,
            push = Array.prototype.push,
            slice = Array.prototype.slice,
            trim = String.prototype.trim,
            indexOf = Array.prototype.indexOf,

            // [[Class]] -> type pairs
            class2type = {};

        jQuery.fn = jQuery.prototype = {
            init: function (selector, context) {
                var match, elem, ret, doc;

                // Handle $(""), $(null), or $(undefined)
                if (!selector) {
                    return this;
                }

                // Handle $(DOMElement)
                if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                }

                // The body element only exists once, optimize finding it
                if (selector === "body" && !context && document.body) {
                    this.context = document;
                    this[0] = document.body;
                    this.selector = "body";
                    this.length = 1;
                    return this;
                }

                // Handle HTML strings
                if (typeof selector === "string") {
                    // Are we dealing with HTML string or an ID?
                    match = quickExpr.exec(selector);

                    // Verify a match, and that no context was specified for #id
                    if (match && (match[1] || !context)) {

                        // HANDLE: $(html) -> $(array)
                        if (match[1]) {
                            doc = (context ? context.ownerDocument || context : document);

                            // If a single string is passed in and it's a single tag
                            // just do a createElement and skip the rest
                            ret = rsingleTag.exec(selector);

                            if (ret) {
                                if (jQuery.isPlainObject(context)) {
                                    selector = [document.createElement(ret[1])];
                                    jQuery.fn.attr.call(selector, context, true);

                                } else {
                                    selector = [doc.createElement(ret[1])];
                                }

                            } else {
                                ret = jQuery.buildFragment([match[1]], [doc]);
                                selector = (ret.cacheable ? ret.fragment.cloneNode(true) : ret.fragment).childNodes;
                            }

                            return jQuery.merge(this, selector);

                            // HANDLE: $("#id")
                        } else {
                            elem = document.getElementById(match[2]);

                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Handle the case where IE and Opera return items
                                // by name instead of ID
                                if (elem.id !== match[2]) {
                                    return rootjQuery.find(selector);
                                }

                                // Otherwise, we inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }

                            this.context = document;
                            this.selector = selector;
                            return this;
                        }

                        // HANDLE: $("TAG")
                    } else if (!context && !rnonword.test(selector)) {
                        this.selector = selector;
                        this.context = document;
                        selector = document.getElementsByTagName(selector);
                        return jQuery.merge(this, selector);

                        // HANDLE: $(expr, $(...))
                    } else if (!context || context.jquery) {
                        return (context || rootjQuery).find(selector);

                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return jQuery(context).find(selector);
                    }

                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                    return rootjQuery.ready(selector);
                }

                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }

                return jQuery.makeArray(selector, this);
            },

            // Start with an empty selector
            selector: "",

            // The current version of jQuery being used
            jquery: "1.4.3",

            // The default length of a jQuery object is 0
            length: 0,

            // The number of elements contained in the matched element set
            size: function () {
                return this.length;
            },

            toArray: function () {
                return slice.call(this, 0);
            },

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function (num) {
                return num == null ?

                    // Return a 'clean' array
                    this.toArray() :

                    // Return just the object
                    (num < 0 ? this.slice(num)[0] : this[num]);
            },

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function (elems, name, selector) {
                // Build a new jQuery matched element set
                var ret = jQuery();

                if (jQuery.isArray(elems)) {
                    push.apply(ret, elems);

                } else {
                    jQuery.merge(ret, elems);
                }

                // Add the old object onto the stack (as a reference)
                ret.prevObject = this;

                ret.context = this.context;

                if (name === "find") {
                    ret.selector = this.selector + (this.selector ? " " : "") + selector;
                } else if (name) {
                    ret.selector = this.selector + "." + name + "(" + selector + ")";
                }

                // Return the newly-formed element set
                return ret;
            },

            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: function (callback, args) {
                return jQuery.each(this, callback, args);
            },

            ready: function (fn) {
                // Attach the listeners
                jQuery.bindReady();

                // If the DOM is already ready
                if (jQuery.isReady) {
                    // Execute the function immediately
                    fn.call(document, jQuery);

                    // Otherwise, remember the function for later
                } else if (readyList) {
                    // Add the function to the wait list
                    readyList.push(fn);
                }

                return this;
            },

            eq: function (i) {
                return i === -1 ?
                    this.slice(i) :
                    this.slice(i, +i + 1);
            },

            first: function () {
                return this.eq(0);
            },

            last: function () {
                return this.eq(-1);
            },

            slice: function () {
                return this.pushStack(slice.apply(this, arguments),
                    "slice", slice.call(arguments).join(","));
            },

            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },

            end: function () {
                return this.prevObject || jQuery(null);
            },

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: [].sort,
            splice: [].splice
        };

        // Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = function () {
            // copy reference to target object
            var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy, copyIsArray;

            // Handle a deep copy situation
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {};
            }

            // extend jQuery itself if only one argument is passed
            if (length === i) {
                target = this;
                --i;
            }

            for (; i < length; i++) {
                // Only deal with non-null/undefined values
                if ((options = arguments[i]) != null) {
                    // Extend the base object
                    for (name in options) {
                        src = target[name];
                        copy = options[name];

                        // Prevent never-ending loop
                        if (target === copy) {
                            continue;
                        }

                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];

                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }

                            // Never move original objects, clone them
                            target[name] = jQuery.extend(deep, clone, copy);

                            // Don't bring in undefined values
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }

            // Return the modified object
            return target;
        };

        jQuery.extend({
            noConflict: function (deep) {
                window.$ = _$;

                if (deep) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            },

            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Handle when the DOM is ready
            ready: function (wait) {
                // A third-party is pushing the ready event forwards
                if (wait === true) {
                    jQuery.readyWait--;
                }

                // Make sure that the DOM is not already loaded
                if (!jQuery.readyWait || (wait !== true && !jQuery.isReady)) {
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if (!document.body) {
                        return setTimeout(jQuery.ready, 1);
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    if (readyList) {
                        // Execute all of them
                        var fn, i = 0;
                        while ((fn = readyList[i++])) {
                            fn.call(document, jQuery);
                        }

                        // Reset the list of functions
                        readyList = null;
                    }

                    // Trigger any bound ready events
                    if (jQuery.fn.triggerHandler) {
                        jQuery(document).triggerHandler("ready");
                    }
                }
            },

            bindReady: function () {
                if (readyBound) {
                    return;
                }

                readyBound = true;

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if (document.readyState === "complete") {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    return setTimeout(jQuery.ready, 1);
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if (document.addEventListener) {
                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", jQuery.ready, false);

                    // If IE event model is used
                } else if (document.attachEvent) {
                    // ensure firing before onload,
                    // maybe late but safe also for iframes
                    document.attachEvent("onreadystatechange", DOMContentLoaded);

                    // A fallback to window.onload, that will always work
                    window.attachEvent("onload", jQuery.ready);

                    // If IE and not a frame
                    // continually check to see if the document is ready
                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) { }

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            },

            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function (obj) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || function (obj) {
                return jQuery.type(obj) === "array";
            },

            // A crude way of determining if an object is a window
            isWindow: function (obj) {
                return obj && typeof obj === "object" && "setInterval" in obj;
            },

            isNaN: function (obj) {
                return obj == null || !rdigit.test(obj) || isNaN(obj);
            },

            type: function (obj) {
                return obj == null ?
                    String(obj) :
                    class2type[toString.call(obj)] || "object";
            },

            isPlainObject: function (obj) {
                // Must be an Object.
                // Because of IE, we also have to check the presence of the constructor property.
                // Make sure that DOM nodes and window objects don't pass through, as well
                if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }

                // Not own constructor property must be Object
                if (obj.constructor &&
                    !hasOwn.call(obj, "constructor") &&
                    !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }

                // Own properties are enumerated firstly, so to speed up,
                // if last one is own, then all properties are own.

                var key;
                for (key in obj) { }

                return key === undefined || hasOwn.call(obj, key);
            },

            isEmptyObject: function (obj) {
                for (var name in obj) {
                    return false;
                }
                return true;
            },

            error: function (msg) {
                throw msg;
            },

            parseJSON: function (data) {
                if (typeof data !== "string" || !data) {
                    return null;
                }

                // Make sure leading/trailing whitespace is removed (IE can't handle it)
                data = jQuery.trim(data);

                // Make sure the incoming data is actual JSON
                // Logic borrowed from http://json.org/json2.js
                if (rvalidchars.test(data.replace(rvalidescape, "@")
                    .replace(rvalidtokens, "]")
                    .replace(rvalidbraces, ""))) {

                    // Try to use the native JSON parser first
                    return window.JSON && window.JSON.parse ?
                        window.JSON.parse(data) :
                        (new Function("return " + data))();

                } else {
                    jQuery.error("Invalid JSON: " + data);
                }
            },

            noop: function () { },

            // Evalulates a script in a global context
            globalEval: function (data) {
                if (data && rnotwhite.test(data)) {
                    // Inspired by code by Andrea Giammarchi
                    // http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
                    var head = document.getElementsByTagName("head")[0] || document.documentElement,
                        script = document.createElement("script");

                    script.type = "text/javascript";

                    if (jQuery.support.scriptEval) {
                        script.appendChild(document.createTextNode(data));
                    } else {
                        script.text = data;
                    }

                    // Use insertBefore instead of appendChild to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709).
                    head.insertBefore(script, head.firstChild);
                    head.removeChild(script);
                }
            },

            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
            },

            // args is for internal usage only
            each: function (object, callback, args) {
                var name, i = 0,
                    length = object.length,
                    isObj = length === undefined || jQuery.isFunction(object);

                if (args) {
                    if (isObj) {
                        for (name in object) {
                            if (callback.apply(object[name], args) === false) {
                                break;
                            }
                        }
                    } else {
                        for (; i < length;) {
                            if (callback.apply(object[i++], args) === false) {
                                break;
                            }
                        }
                    }

                    // A special, fast, case for the most common use of each
                } else {
                    if (isObj) {
                        for (name in object) {
                            if (callback.call(object[name], name, object[name]) === false) {
                                break;
                            }
                        }
                    } else {
                        for (var value = object[0];
                            i < length && callback.call(value, i, value) !== false; value = object[++i]) { }
                    }
                }

                return object;
            },

            // Use native String.trim function wherever possible
            trim: trim ?
                function (text) {
                    return text == null ?
                        "" :
                        trim.call(text);
                } :

                // Otherwise use our own trimming functionality
                function (text) {
                    return text == null ?
                        "" :
                        text.toString().replace(trimLeft, "").replace(trimRight, "");
                },

            // results is for internal usage only
            makeArray: function (array, results) {
                var ret = results || [];

                if (array != null) {
                    // The window, strings (and functions) also have 'length'
                    // The extra typeof function check is to prevent crashes
                    // in Safari 2 (See: #3039)
                    // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                    var type = jQuery.type(array);

                    if (array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(array)) {
                        push.call(ret, array);
                    } else {
                        jQuery.merge(ret, array);
                    }
                }

                return ret;
            },

            inArray: function (elem, array) {
                if (array.indexOf) {
                    return array.indexOf(elem);
                }

                for (var i = 0, length = array.length; i < length; i++) {
                    if (array[i] === elem) {
                        return i;
                    }
                }

                return -1;
            },

            merge: function (first, second) {
                var i = first.length, j = 0;

                if (typeof second.length === "number") {
                    for (var l = second.length; j < l; j++) {
                        first[i++] = second[j];
                    }

                } else {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }

                first.length = i;

                return first;
            },

            grep: function (elems, callback, inv) {
                var ret = [], retVal;
                inv = !!inv;

                // Go through the array, only saving the items
                // that pass the validator function
                for (var i = 0, length = elems.length; i < length; i++) {
                    retVal = !!callback(elems[i], i);
                    if (inv !== retVal) {
                        ret.push(elems[i]);
                    }
                }

                return ret;
            },

            // arg is for internal usage only
            map: function (elems, callback, arg) {
                var ret = [], value;

                // Go through the array, translating each of the items to their
                // new value (or values).
                for (var i = 0, length = elems.length; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret[ret.length] = value;
                    }
                }

                return ret.concat.apply([], ret);
            },

            // A global GUID counter for objects
            guid: 1,

            proxy: function (fn, proxy, thisObject) {
                if (arguments.length === 2) {
                    if (typeof proxy === "string") {
                        thisObject = fn;
                        fn = thisObject[proxy];
                        proxy = undefined;

                    } else if (proxy && !jQuery.isFunction(proxy)) {
                        thisObject = proxy;
                        proxy = undefined;
                    }
                }

                if (!proxy && fn) {
                    proxy = function () {
                        return fn.apply(thisObject || this, arguments);
                    };
                }

                // Set the guid of unique handler to the same of original handler, so it can be removed
                if (fn) {
                    proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
                }

                // So proxy can be declared as an argument
                return proxy;
            },

            // Mutifunctional method to get and set values to a collection
            // The value/s can be optionally by executed if its a function
            access: function (elems, key, value, exec, fn, pass) {
                var length = elems.length;

                // Setting many attributes
                if (typeof key === "object") {
                    for (var k in key) {
                        jQuery.access(elems, k, key[k], exec, fn, value);
                    }
                    return elems;
                }

                // Setting one attribute
                if (value !== undefined) {
                    // Optionally, function values get executed if exec is true
                    exec = !pass && exec && jQuery.isFunction(value);

                    for (var i = 0; i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }

                    return elems;
                }

                // Getting an attribute
                return length ? fn(elems[0], key) : undefined;
            },

            now: function () {
                return (new Date()).getTime();
            },

            // Use of jQuery.browser is frowned upon.
            // More details: http://docs.jquery.com/Utilities/jQuery.browser
            uaMatch: function (ua) {
                ua = ua.toLowerCase();

                var match = rwebkit.exec(ua) ||
                    ropera.exec(ua) ||
                    rmsie.exec(ua) ||
                    ua.indexOf("compatible") < 0 && rmozilla.exec(ua) ||
                    [];

                return { browser: match[1] || "", version: match[2] || "0" };
            },

            browser: {}
        });

        // Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

        browserMatch = jQuery.uaMatch(userAgent);
        if (browserMatch.browser) {
            jQuery.browser[browserMatch.browser] = true;
            jQuery.browser.version = browserMatch.version;
        }

        // Deprecated, use jQuery.browser.webkit instead
        if (jQuery.browser.webkit) {
            jQuery.browser.safari = true;
        }

        if (indexOf) {
            jQuery.inArray = function (elem, array) {
                return indexOf.call(array, elem);
            };
        }

        // Verify that \s matches non-breaking spaces
        // (IE fails on this test)
        if (!rwhite.test("\xA0")) {
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

        // All jQuery objects should point back to these
        rootjQuery = jQuery(document);

        // Cleanup functions for the document ready method
        if (document.addEventListener) {
            DOMContentLoaded = function () {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready();
            };

        } else if (document.attachEvent) {
            DOMContentLoaded = function () {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (document.readyState === "complete") {
                    document.detachEvent("onreadystatechange", DOMContentLoaded);
                    jQuery.ready();
                }
            };
        }

        // The DOM ready check for Internet Explorer
        function doScrollCheck() {
            if (jQuery.isReady) {
                return;
            }

            try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
            } catch (e) {
                setTimeout(doScrollCheck, 1);
                return;
            }

            // and execute any waiting functions
            jQuery.ready();
        }

        // Expose jQuery to the global object
        return (window.jQuery = window.$ = jQuery);

    })();


    (function () {

        jQuery.support = {};

        var root = document.documentElement,
            script = document.createElement("script"),
            div = document.createElement("div"),
            id = "script" + jQuery.now();

        div.style.display = "none";
        div.innerHTML = "   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

        var all = div.getElementsByTagName("*"),
            a = div.getElementsByTagName("a")[0],
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));

        // Can't get basic test support
        if (!all || !all.length || !a) {
            return;
        }

        jQuery.support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: div.firstChild.nodeType === 3,

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText insted)
            style: /red/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: a.getAttribute("href") === "/a",

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55$/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: div.getElementsByTagName("input")[0].value === "on",

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Will be defined later
            optDisabled: false,
            checkClone: false,
            scriptEval: false,
            noCloneEvent: true,
            boxModel: null,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableHiddenOffsets: true
        };

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as diabled)
        select.disabled = true;
        jQuery.support.optDisabled = !opt.disabled;

        script.type = "text/javascript";
        try {
            script.appendChild(document.createTextNode("window." + id + "=1;"));
        } catch (e) { }

        root.insertBefore(script, root.firstChild);

        // Make sure that the execution of code works by injecting a script
        // tag with appendChild/createTextNode
        // (IE doesn't support this, fails, and uses .text instead)
        if (window[id]) {
            jQuery.support.scriptEval = true;
            delete window[id];
        }

        root.removeChild(script);

        if (div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", function click() {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                jQuery.support.noCloneEvent = false;
                div.detachEvent("onclick", click);
            });
            div.cloneNode(true).fireEvent("onclick");
        }

        div = document.createElement("div");
        div.innerHTML = "<input type='radio' name='radiotest' checked='checked'/>";

        var fragment = document.createDocumentFragment();
        fragment.appendChild(div.firstChild);

        // WebKit doesn't clone checked state correctly in fragments
        jQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        // Figure out if the W3C box model works as expected
        // document.body must exist before we can do this
        jQuery(function () {
            var div = document.createElement("div");
            div.style.width = div.style.paddingLeft = "1px";

            document.body.appendChild(div);
            jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2;

            if ("zoom" in div.style) {
                // Check if natively block-level elements act like inline-block
                // elements when setting their display to 'inline' and giving
                // them layout
                // (IE < 8 does this)
                div.style.display = "inline";
                div.style.zoom = 1;
                jQuery.support.inlineBlockNeedsLayout = div.offsetWidth === 2;

                // Check if elements with layout shrink-wrap their children
                // (IE 6 does this)
                div.style.display = "";
                div.innerHTML = "<div style='width:4px;'></div>";
                jQuery.support.shrinkWrapBlocks = div.offsetWidth !== 2;
            }

            div.innerHTML = "<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";
            var tds = div.getElementsByTagName("td");

            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            // (only IE 8 fails this test)
            jQuery.support.reliableHiddenOffsets = tds[0].offsetHeight === 0;

            tds[0].style.display = "";
            tds[1].style.display = "none";

            // Check if empty table cells still have offsetWidth/Height
            // (IE < 8 fail this test)
            jQuery.support.reliableHiddenOffsets = jQuery.support.reliableHiddenOffsets && tds[0].offsetHeight === 0;
            div.innerHTML = "";

            document.body.removeChild(div).style.display = "none";
            div = tds = null;
        });

        // Technique from Juriy Zaytsev
        // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
        var eventSupported = function (eventName) {
            var el = document.createElement("div");
            eventName = "on" + eventName;

            var isSupported = (eventName in el);
            if (!isSupported) {
                el.setAttribute(eventName, "return;");
                isSupported = typeof el[eventName] === "function";
            }
            el = null;

            return isSupported;
        };

        jQuery.support.submitBubbles = eventSupported("submit");
        jQuery.support.changeBubbles = eventSupported("change");

        // release memory in IE
        root = script = div = all = a = null;
    })();

    jQuery.props = {
        "for": "htmlFor",
        "class": "className",
        readonly: "readOnly",
        maxlength: "maxLength",
        cellspacing: "cellSpacing",
        rowspan: "rowSpan",
        colspan: "colSpan",
        tabindex: "tabIndex",
        usemap: "useMap",
        frameborder: "frameBorder"
    };




    var windowData = {},
        rbrace = /^(?:\{.*\}|\[.*\])$/;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page	
        expando: "jQuery" + jQuery.now(),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        data: function (elem, name, data) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            elem = elem == window ?
                windowData :
                elem;

            var isNode = elem.nodeType,
                id = isNode ? elem[jQuery.expando] : null,
                cache = jQuery.cache, thisCache;

            if (isNode && !id && typeof name === "string" && data === undefined) {
                return;
            }

            // Get the data from the object directly
            if (!isNode) {
                cache = elem;

                // Compute a unique ID for the element
            } else if (!id) {
                elem[jQuery.expando] = id = ++jQuery.uuid;
            }

            // Avoid generating a new cache unless none exists and we
            // want to manipulate it.
            if (typeof name === "object") {
                if (isNode) {
                    cache[id] = jQuery.extend(cache[id], name);

                } else {
                    jQuery.extend(cache, name);
                }

            } else if (isNode && !cache[id]) {
                cache[id] = {};
            }

            thisCache = isNode ? cache[id] : cache;

            // Prevent overriding the named cache with undefined values
            if (data !== undefined) {
                thisCache[name] = data;
            }

            return typeof name === "string" ? thisCache[name] : thisCache;
        },

        removeData: function (elem, name) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            elem = elem == window ?
                windowData :
                elem;

            var isNode = elem.nodeType,
                id = isNode ? elem[jQuery.expando] : elem,
                cache = jQuery.cache,
                thisCache = isNode ? cache[id] : id;

            // If we want to remove a specific section of the element's data
            if (name) {
                if (thisCache) {
                    // Remove the section of cache data
                    delete thisCache[name];

                    // If we've removed all the data, remove the element's cache
                    if (isNode && jQuery.isEmptyObject(thisCache)) {
                        jQuery.removeData(elem);
                    }
                }

                // Otherwise, we want to remove all of the element's data
            } else {
                if (isNode && jQuery.support.deleteExpando) {
                    delete elem[jQuery.expando];

                } else if (elem.removeAttribute) {
                    elem.removeAttribute(jQuery.expando);

                    // Completely remove the data cache
                } else if (isNode) {
                    delete cache[id];

                    // Remove all fields from the object
                } else {
                    for (var n in elem) {
                        delete elem[n];
                    }
                }
            }
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function (elem) {
            if (elem.nodeName) {
                var match = jQuery.noData[elem.nodeName.toLowerCase()];

                if (match) {
                    return !(match === true || elem.getAttribute("classid") !== match);
                }
            }

            return true;
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            if (typeof key === "undefined") {
                return this.length ? jQuery.data(this[0]) : null;

            } else if (typeof key === "object") {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            var parts = key.split(".");
            parts[1] = parts[1] ? "." + parts[1] : "";

            if (value === undefined) {
                var data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if (data === undefined && this.length) {
                    data = jQuery.data(this[0], key);

                    // If nothing was found internally, try to fetch any
                    // data from the HTML5 data-* attribute
                    if (data === undefined && this[0].nodeType === 1) {
                        data = this[0].getAttribute("data-" + key);

                        if (typeof data === "string") {
                            try {
                                data = data === "true" ? true :
                                    data === "false" ? false :
                                        data === "null" ? null :
                                            !jQuery.isNaN(data) ? parseFloat(data) :
                                                rbrace.test(data) ? jQuery.parseJSON(data) :
                                                    data;
                            } catch (e) { }

                        } else {
                            data = undefined;
                        }
                    }
                }

                return data === undefined && parts[1] ?
                    this.data(parts[0]) :
                    data;

            } else {
                return this.each(function () {
                    var $this = jQuery(this), args = [parts[0], value];

                    $this.triggerHandler("setData" + parts[1] + "!", args);
                    jQuery.data(this, key, value);
                    $this.triggerHandler("changeData" + parts[1] + "!", args);
                });
            }
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });




    jQuery.extend({
        queue: function (elem, type, data) {
            if (!elem) {
                return;
            }

            type = (type || "fx") + "queue";
            var q = jQuery.data(elem, type);

            // Speed up dequeue by getting out quickly if this is just a lookup
            if (!data) {
                return q || [];
            }

            if (!q || jQuery.isArray(data)) {
                q = jQuery.data(elem, type, jQuery.makeArray(data));

            } else {
                q.push(data);
            }

            return q;
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type), fn = queue.shift();

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
            }

            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                fn.call(elem, function () {
                    jQuery.dequeue(elem, type);
                });
            }
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            if (typeof type !== "string") {
                data = type;
                type = "fx";
            }

            if (data === undefined) {
                return jQuery.queue(this[0], type);
            }
            return this.each(function (i) {
                var queue = jQuery.queue(this, type, data);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },

        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue(type, function () {
                var elem = this;
                setTimeout(function () {
                    jQuery.dequeue(elem, type);
                }, time);
            });
        },

        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        }
    });




    var rclass = /[\n\t]/g,
        rspaces = /\s+/,
        rreturn = /\r/g,
        rspecialurl = /^(?:href|src|style)$/,
        rtype = /^(?:button|input)$/i,
        rfocusable = /^(?:button|input|object|select|textarea)$/i,
        rclickable = /^a(?:rea)?$/i,
        rradiocheck = /^(?:radio|checkbox)$/i;

    jQuery.fn.extend({
        attr: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.attr);
        },

        removeAttr: function (name, fn) {
            return this.each(function () {
                jQuery.attr(this, name, "");
                if (this.nodeType === 1) {
                    this.removeAttribute(name);
                }
            });
        },

        addClass: function (value) {
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self.addClass(value.call(this, i, self.attr("class")));
                });
            }

            if (value && typeof value === "string") {
                var classNames = (value || "").split(rspaces);

                for (var i = 0, l = this.length; i < l; i++) {
                    var elem = this[i];

                    if (elem.nodeType === 1) {
                        if (!elem.className) {
                            elem.className = value;

                        } else {
                            var className = " " + elem.className + " ", setClass = elem.className;
                            for (var c = 0, cl = classNames.length; c < cl; c++) {
                                if (className.indexOf(" " + classNames[c] + " ") < 0) {
                                    setClass += " " + classNames[c];
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self.removeClass(value.call(this, i, self.attr("class")));
                });
            }

            if ((value && typeof value === "string") || value === undefined) {
                var classNames = (value || "").split(rspaces);

                for (var i = 0, l = this.length; i < l; i++) {
                    var elem = this[i];

                    if (elem.nodeType === 1 && elem.className) {
                        if (value) {
                            var className = (" " + elem.className + " ").replace(rclass, " ");
                            for (var c = 0, cl = classNames.length; c < cl; c++) {
                                className = className.replace(" " + classNames[c] + " ", " ");
                            }
                            elem.className = jQuery.trim(className);

                        } else {
                            elem.className = "";
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value, isBool = typeof stateVal === "boolean";

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self.toggleClass(value.call(this, i, self.attr("class"), stateVal), stateVal);
                });
            }

            return this.each(function () {
                if (type === "string") {
                    // toggle individual class names
                    var className, i = 0, self = jQuery(this),
                        state = stateVal,
                        classNames = value.split(rspaces);

                    while ((className = classNames[i++])) {
                        // check each className given, space seperated list
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }

                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery.data(this, "__className__", this.className);
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery.data(this, "__className__") || "";
                }
            });
        },

        hasClass: function (selector) {
            var className = " " + selector + " ";
            for (var i = 0, l = this.length; i < l; i++) {
                if ((" " + this[i].className + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        },

        val: function (value) {
            if (!arguments.length) {
                var elem = this[0];

                if (elem) {
                    if (jQuery.nodeName(elem, "option")) {
                        // attributes.value is undefined in Blackberry 4.7 but
                        // uses .value. See #6932
                        var val = elem.attributes.value;
                        return !val || val.specified ? elem.value : elem.text;
                    }

                    // We need to handle select boxes special
                    if (jQuery.nodeName(elem, "select")) {
                        var index = elem.selectedIndex,
                            values = [],
                            options = elem.options,
                            one = elem.type === "select-one";

                        // Nothing was selected
                        if (index < 0) {
                            return null;
                        }

                        // Loop through all the selected options
                        for (var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++) {
                            var option = options[i];

                            // Don't return options that are disabled or in a disabled optgroup
                            if (option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                                (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                                // Get the specific value for the option
                                value = jQuery(option).val();

                                // We don't need an array for one selects
                                if (one) {
                                    return value;
                                }

                                // Multi-Selects return an array
                                values.push(value);
                            }
                        }

                        return values;
                    }

                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    if (rradiocheck.test(elem.type) && !jQuery.support.checkOn) {
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    }


                    // Everything else, we just grab the value
                    return (elem.value || "").replace(rreturn, "");

                }

                return undefined;
            }

            var isFunction = jQuery.isFunction(value);

            return this.each(function (i) {
                var self = jQuery(this), val = value;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, self.val());
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                if (jQuery.isArray(val) && rradiocheck.test(this.type)) {
                    this.checked = jQuery.inArray(self.val(), val) >= 0;

                } else if (jQuery.nodeName(this, "select")) {
                    var values = jQuery.makeArray(val);

                    jQuery("option", this).each(function () {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });

                    if (!values.length) {
                        this.selectedIndex = -1;
                    }

                } else {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attr: function (elem, name, value, pass) {
            // don't set attributes on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8) {
                return undefined;
            }

            if (pass && name in jQuery.attrFn) {
                return jQuery(elem)[name](value);
            }

            var notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc(elem),
                // Whether we are setting (or getting)
                set = value !== undefined;

            // Try to normalize/fix the name
            name = notxml && jQuery.props[name] || name;

            // Only do all the following if this is a node (faster for style)
            if (elem.nodeType === 1) {
                // These attributes require special treatment
                var special = rspecialurl.test(name);

                // Safari mis-reports the default selected property of an option
                // Accessing the parent's selectedIndex property fixes it
                if (name === "selected" && !jQuery.support.optSelected) {
                    var parent = elem.parentNode;
                    if (parent) {
                        parent.selectedIndex;

                        // Make sure that it also works with optgroups, see #5701
                        if (parent.parentNode) {
                            parent.parentNode.selectedIndex;
                        }
                    }
                }

                // If applicable, access the attribute via the DOM 0 way
                // 'in' checks fail in Blackberry 4.7 #6931
                if ((name in elem || elem[name] !== undefined) && notxml && !special) {
                    if (set) {
                        // We can't allow the type property to be changed (since it causes problems in IE)
                        if (name === "type" && rtype.test(elem.nodeName) && elem.parentNode) {
                            jQuery.error("type property can't be changed");
                        }

                        if (value === null) {
                            if (elem.nodeType === 1) {
                                elem.removeAttribute(name);
                            }

                        } else {
                            elem[name] = value;
                        }
                    }

                    // browsers index elements by id/name on forms, give priority to attributes.
                    if (jQuery.nodeName(elem, "form") && elem.getAttributeNode(name)) {
                        return elem.getAttributeNode(name).nodeValue;
                    }

                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    if (name === "tabIndex") {
                        var attributeNode = elem.getAttributeNode("tabIndex");

                        return attributeNode && attributeNode.specified ?
                            attributeNode.value :
                            rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
                                0 :
                                undefined;
                    }

                    return elem[name];
                }

                if (!jQuery.support.style && notxml && name === "style") {
                    if (set) {
                        elem.style.cssText = "" + value;
                    }

                    return elem.style.cssText;
                }

                if (set) {
                    // convert the value to a string (all browsers do this but IE) see #1070
                    elem.setAttribute(name, "" + value);
                }

                // Ensure that missing attributes return undefined
                // Blackberry 4.7 returns "" from getAttribute #6938
                if (!elem.attributes[name] && (elem.hasAttribute && !elem.hasAttribute(name))) {
                    return undefined;
                }

                var attr = !jQuery.support.hrefNormalized && notxml && special ?
                    // Some attributes require a special call on IE
                    elem.getAttribute(name, 2) :
                    elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return attr === null ? undefined : attr;
            }
        }
    });




    var rnamespaces = /\.(.*)$/,
        rformElems = /^(?:textarea|input|select)$/i,
        rperiod = /\./g,
        rspace = / /g,
        rescape = /[^\w\s.|`]/g,
        fcleanup = function (nm) {
            return nm.replace(rescape, "\\$&");
        },
        focusCounts = { focusin: 0, focusout: 0 };

    /*
     * A number of helper functions used for managing events.
     * Many of the ideas behind this code originated from
     * Dean Edwards' addEvent library.
     */
    jQuery.event = {

        // Bind an event to an element
        // Original by Dean Edwards
        add: function (elem, types, handler, data) {
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // For whatever reason, IE has trouble passing the window object
            // around, causing it to be cloned in the process
            if (jQuery.isWindow(elem) && (elem !== window && !elem.frameElement)) {
                elem = window;
            }

            if (handler === false) {
                handler = returnFalse;
            }

            var handleObjIn, handleObj;

            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
            }

            // Make sure that the function being executed has a unique ID
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure
            var elemData = jQuery.data(elem);

            // If no elemData is found then we must be trying to bind to one of the
            // banned noData elements
            if (!elemData) {
                return;
            }

            // Use a key less likely to result in collisions for plain JS objects.
            // Fixes bug #7150.
            var eventKey = elem.nodeType ? "events" : "__events__",
                events = elemData[eventKey],
                eventHandle = elemData.handle;

            if (typeof events === "function") {
                // On plain objects events is a fn that holds the the data
                // which prevents this data from being JSON serialized
                // the function does not need to be called, it just contains the data
                eventHandle = events.handle;
                events = events.events;

            } else if (!events) {
                if (!elem.nodeType) {
                    // On plain objects, create a fn that acts as the holder
                    // of the values to avoid JSON serialization of event data
                    elemData[eventKey] = elemData = function () { };
                }

                elemData.events = events = {};
            }

            if (!eventHandle) {
                elemData.handle = eventHandle = function () {
                    // Handle the second event of a trigger and when
                    // an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && !jQuery.event.triggered ?
                        jQuery.event.handle.apply(eventHandle.elem, arguments) :
                        undefined;
                };
            }

            // Add elem as a property of the handle function
            // This is to prevent a memory leak with non-native events in IE.
            eventHandle.elem = elem;

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = types.split(" ");

            var type, i = 0, namespaces;

            while ((type = types[i++])) {
                handleObj = handleObjIn ?
                    jQuery.extend({}, handleObjIn) :
                    { handler: handler, data: data };

                // Namespaced event handlers
                if (type.indexOf(".") > -1) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    handleObj.namespace = namespaces.slice(0).sort().join(".");

                } else {
                    namespaces = [];
                    handleObj.namespace = "";
                }

                handleObj.type = type;
                if (!handleObj.guid) {
                    handleObj.guid = handler.guid;
                }

                // Get the current list of functions bound to this event
                var handlers = events[type],
                    special = jQuery.event.special[type] || {};

                // Init the event handler queue
                if (!handlers) {
                    handlers = events[type] = [];

                    // Check for a special event handler
                    // Only use addEventListener/attachEvent if the special
                    // events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add the function to the element's handler list
                handlers.push(handleObj);

                // Keep track of which events have been used, for global triggering
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, pos) {
            // don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            }

            var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
                eventKey = elem.nodeType ? "events" : "__events__",
                elemData = jQuery.data(elem),
                events = elemData && elemData[eventKey];

            if (!elemData || !events) {
                return;
            }

            if (typeof events === "function") {
                elemData = events;
                events = events.events;
            }

            // types is actually an event object here
            if (types && types.type) {
                handler = types.handler;
                types = types.type;
            }

            // Unbind all events for the element
            if (!types || typeof types === "string" && types.charAt(0) === ".") {
                types = types || "";

                for (type in events) {
                    jQuery.event.remove(elem, type + types);
                }

                return;
            }

            // Handle multiple events separated by a space
            // jQuery(...).unbind("mouseover mouseout", fn);
            types = types.split(" ");

            while ((type = types[i++])) {
                origType = type;
                handleObj = null;
                all = type.indexOf(".") < 0;
                namespaces = [];

                if (!all) {
                    // Namespaced event handlers
                    namespaces = type.split(".");
                    type = namespaces.shift();

                    namespace = new RegExp("(^|\\.)" +
                        jQuery.map(namespaces.slice(0).sort(), fcleanup).join("\\.(?:.*\\.)?") + "(\\.|$)");
                }

                eventType = events[type];

                if (!eventType) {
                    continue;
                }

                if (!handler) {
                    for (j = 0; j < eventType.length; j++) {
                        handleObj = eventType[j];

                        if (all || namespace.test(handleObj.namespace)) {
                            jQuery.event.remove(elem, origType, handleObj.handler, j);
                            eventType.splice(j--, 1);
                        }
                    }

                    continue;
                }

                special = jQuery.event.special[type] || {};

                for (j = pos || 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if (handler.guid === handleObj.guid) {
                        // remove the given handler for the given type
                        if (all || namespace.test(handleObj.namespace)) {
                            if (pos == null) {
                                eventType.splice(j--, 1);
                            }

                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }

                        if (pos != null) {
                            break;
                        }
                    }
                }

                // remove generic event handler if no more handlers exist
                if (eventType.length === 0 || pos != null && eventType.length === 1) {
                    if (!special.teardown || special.teardown.call(elem, namespaces) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    ret = null;
                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                var handle = elemData.handle;
                if (handle) {
                    handle.elem = null;
                }

                delete elemData.events;
                delete elemData.handle;

                if (typeof elemData === "function") {
                    jQuery.removeData(elem, eventKey);

                } else if (jQuery.isEmptyObject(elemData)) {
                    jQuery.removeData(elem);
                }
            }
        },

        // bubbling is internal
        trigger: function (event, data, elem /*, bubbling */) {
            // Event object or event type
            var type = event.type || event,
                bubbling = arguments[3];

            if (!bubbling) {
                event = typeof event === "object" ?
                    // jQuery.Event object
                    event[jQuery.expando] ? event :
                        // Object literal
                        jQuery.extend(jQuery.Event(type), event) :
                    // Just the event type (string)
                    jQuery.Event(type);

                if (type.indexOf("!") >= 0) {
                    event.type = type = type.slice(0, -1);
                    event.exclusive = true;
                }

                // Handle a global trigger
                if (!elem) {
                    // Don't bubble custom events when global (to avoid too much overhead)
                    event.stopPropagation();

                    // Only trigger if we've ever bound an event for it
                    if (jQuery.event.global[type]) {
                        jQuery.each(jQuery.cache, function () {
                            if (this.events && this.events[type]) {
                                jQuery.event.trigger(event, data, this.handle.elem);
                            }
                        });
                    }
                }

                // Handle triggering a single element

                // don't do events on text and comment nodes
                if (!elem || elem.nodeType === 3 || elem.nodeType === 8) {
                    return undefined;
                }

                // Clean up in case it is reused
                event.result = undefined;
                event.target = elem;

                // Clone the incoming data, if any
                data = jQuery.makeArray(data);
                data.unshift(event);
            }

            event.currentTarget = elem;

            // Trigger the event, it is assumed that "handle" is a function
            var handle = elem.nodeType ?
                jQuery.data(elem, "handle") :
                (jQuery.data(elem, "__events__") || {}).handle;

            if (handle) {
                handle.apply(elem, data);
            }

            var parent = elem.parentNode || elem.ownerDocument;

            // Trigger an inline bound script
            try {
                if (!(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()])) {
                    if (elem["on" + type] && elem["on" + type].apply(elem, data) === false) {
                        event.result = false;
                        event.preventDefault();
                    }
                }

                // prevent IE from throwing an error for some elements with some event types, see #3533
            } catch (inlineError) { }

            if (!event.isPropagationStopped() && parent) {
                jQuery.event.trigger(event, data, parent, true);

            } else if (!event.isDefaultPrevented()) {
                var target = event.target, old, targetType = type.replace(rnamespaces, ""),
                    isClick = jQuery.nodeName(target, "a") && targetType === "click",
                    special = jQuery.event.special[targetType] || {};

                if ((!special._default || special._default.call(elem, event) === false) &&
                    !isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()])) {

                    try {
                        if (target[targetType]) {
                            // Make sure that we don't accidentally re-trigger the onFOO events
                            old = target["on" + targetType];

                            if (old) {
                                target["on" + targetType] = null;
                            }

                            jQuery.event.triggered = true;
                            target[targetType]();
                        }

                        // prevent IE from throwing an error for some elements with some event types, see #3533
                    } catch (triggerError) { }

                    if (old) {
                        target["on" + targetType] = old;
                    }

                    jQuery.event.triggered = false;
                }
            }
        },

        handle: function (event) {
            var all, handlers, namespaces, namespace_sort = [], namespace_re, events, args = jQuery.makeArray(arguments);

            event = args[0] = jQuery.event.fix(event || window.event);
            event.currentTarget = this;

            // Namespaced event handlers
            all = event.type.indexOf(".") < 0 && !event.exclusive;

            if (!all) {
                namespaces = event.type.split(".");
                event.type = namespaces.shift();
                namespace_sort = namespaces.slice(0).sort();
                namespace_re = new RegExp("(^|\\.)" + namespace_sort.join("\\.(?:.*\\.)?") + "(\\.|$)");
            }

            event.namespace = event.namespace || namespace_sort.join(".");

            events = jQuery.data(this, this.nodeType ? "events" : "__events__");

            if (typeof events === "function") {
                events = events.events;
            }

            handlers = (events || {})[event.type];

            if (events && handlers) {
                // Clone the handlers to prevent manipulation
                handlers = handlers.slice(0);

                for (var j = 0, l = handlers.length; j < l; j++) {
                    var handleObj = handlers[j];

                    // Filter the functions by class
                    if (all || namespace_re.test(handleObj.namespace)) {
                        // Pass in a reference to the handler function itself
                        // So that we can later remove it
                        event.handler = handleObj.handler;
                        event.data = handleObj.data;
                        event.handleObj = handleObj;

                        var ret = handleObj.handler.apply(this, args);

                        if (ret !== undefined) {
                            event.result = ret;
                            if (ret === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }

                        if (event.isImmediatePropagationStopped()) {
                            break;
                        }
                    }
                }
            }

            return event.result;
        },

        props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // store a copy of the original event object
            // and "clone" to set read-only properties
            var originalEvent = event;
            event = jQuery.Event(originalEvent);

            for (var i = this.props.length, prop; i;) {
                prop = this.props[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary
            if (!event.target) {
                event.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either
            }

            // check if target is a textnode (safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // Add relatedTarget, if necessary
            if (!event.relatedTarget && event.fromElement) {
                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
            }

            // Calculate pageX/Y if missing and clientX/Y available
            if (event.pageX == null && event.clientX != null) {
                var doc = document.documentElement, body = document.body;
                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }

            // Add which for key events
            if (event.which == null && (event.charCode != null || event.keyCode != null)) {
                event.which = event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
            if (!event.metaKey && event.ctrlKey) {
                event.metaKey = event.ctrlKey;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if (!event.which && event.button !== undefined) {
                event.which = (event.button & 1 ? 1 : (event.button & 2 ? 3 : (event.button & 4 ? 2 : 0)));
            }

            return event;
        },

        // Deprecated, use jQuery.guid instead
        guid: 1E8,

        // Deprecated, use jQuery.proxy instead
        proxy: jQuery.proxy,

        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady,
                teardown: jQuery.noop
            },

            live: {
                add: function (handleObj) {
                    jQuery.event.add(this,
                        liveConvert(handleObj.origType, handleObj.selector),
                        jQuery.extend({}, handleObj, { handler: liveHandler, guid: handleObj.handler.guid }));
                },

                remove: function (handleObj) {
                    jQuery.event.remove(this, liveConvert(handleObj.origType, handleObj.selector), handleObj);
                }
            },

            beforeunload: {
                setup: function (data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function (namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = document.removeEventListener ?
        function (elem, type, handle) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, handle, false);
            }
        } :
        function (elem, type, handle) {
            if (elem.detachEvent) {
                elem.detachEvent("on" + type, handle);
            }
        };

    jQuery.Event = function (src) {
        // Allow instantiation without the 'new' keyword
        if (!this.preventDefault) {
            return new jQuery.Event(src);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            // Event type
        } else {
            this.type = src;
        }

        // timeStamp is buggy for some events on Firefox(#3843)
        // So we won't rely on the native value
        this.timeStamp = jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }
    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function () {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }

            // if preventDefault exists run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Checks if an event happened on an element within another element
    // Used in jQuery.event.special.mouseenter and mouseleave handlers
    var withinElement = function (event) {
        // Check if mouse(over|out) are still within the same parent element
        var parent = event.relatedTarget;

        // Firefox sometimes assigns relatedTarget a XUL element
        // which we cannot access the parentNode property of
        try {
            // Traverse up the tree
            while (parent && parent !== this) {
                parent = parent.parentNode;
            }

            if (parent !== this) {
                // set the correct event type
                event.type = event.data;

                // handle event if we actually just moused on to a non sub-element
                jQuery.event.handle.apply(this, arguments);
            }

            // assuming we've left the element since we most likely mousedover a xul element
        } catch (e) { }
    },

        // In case of event delegation, we only need to rename the event.type,
        // liveHandler will take care of the rest.
        delegate = function (event) {
            event.type = event.data;
            jQuery.event.handle.apply(this, arguments);
        };

    // Create mouseenter and mouseleave events
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            setup: function (data) {
                jQuery.event.add(this, fix, data && data.selector ? delegate : withinElement, orig);
            },
            teardown: function (data) {
                jQuery.event.remove(this, fix, data && data.selector ? delegate : withinElement);
            }
        };
    });

    // submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function (data, namespaces) {
                if (this.nodeName.toLowerCase() !== "form") {
                    jQuery.event.add(this, "click.specialSubmit", function (e) {
                        var elem = e.target, type = elem.type;

                        if ((type === "submit" || type === "image") && jQuery(elem).closest("form").length) {
                            e.liveFired = undefined;
                            return trigger("submit", this, arguments);
                        }
                    });

                    jQuery.event.add(this, "keypress.specialSubmit", function (e) {
                        var elem = e.target, type = elem.type;

                        if ((type === "text" || type === "password") && jQuery(elem).closest("form").length && e.keyCode === 13) {
                            e.liveFired = undefined;
                            return trigger("submit", this, arguments);
                        }
                    });

                } else {
                    return false;
                }
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialSubmit");
            }
        };

    }

    // change delegation, happens here so we have bind.
    if (!jQuery.support.changeBubbles) {

        var changeFilters,

            getVal = function (elem) {
                var type = elem.type, val = elem.value;

                if (type === "radio" || type === "checkbox") {
                    val = elem.checked;

                } else if (type === "select-multiple") {
                    val = elem.selectedIndex > -1 ?
                        jQuery.map(elem.options, function (elem) {
                            return elem.selected;
                        }).join("-") :
                        "";

                } else if (elem.nodeName.toLowerCase() === "select") {
                    val = elem.selectedIndex;
                }

                return val;
            },

            testChange = function testChange(e) {
                var elem = e.target, data, val;

                if (!rformElems.test(elem.nodeName) || elem.readOnly) {
                    return;
                }

                data = jQuery.data(elem, "_change_data");
                val = getVal(elem);

                // the current data will be also retrieved by beforeactivate
                if (e.type !== "focusout" || elem.type !== "radio") {
                    jQuery.data(elem, "_change_data", val);
                }

                if (data === undefined || val === data) {
                    return;
                }

                if (data != null || val) {
                    e.type = "change";
                    e.liveFired = undefined;
                    return jQuery.event.trigger(e, arguments[1], elem);
                }
            };

        jQuery.event.special.change = {
            filters: {
                focusout: testChange,

                beforedeactivate: testChange,

                click: function (e) {
                    var elem = e.target, type = elem.type;

                    if (type === "radio" || type === "checkbox" || elem.nodeName.toLowerCase() === "select") {
                        return testChange.call(this, e);
                    }
                },

                // Change has to be called before submit
                // Keydown will be called before keypress, which is used in submit-event delegation
                keydown: function (e) {
                    var elem = e.target, type = elem.type;

                    if ((e.keyCode === 13 && elem.nodeName.toLowerCase() !== "textarea") ||
                        (e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
                        type === "select-multiple") {
                        return testChange.call(this, e);
                    }
                },

                // Beforeactivate happens also before the previous element is blurred
                // with this event you can't trigger a change event, but you can store
                // information
                beforeactivate: function (e) {
                    var elem = e.target;
                    jQuery.data(elem, "_change_data", getVal(elem));
                }
            },

            setup: function (data, namespaces) {
                if (this.type === "file") {
                    return false;
                }

                for (var type in changeFilters) {
                    jQuery.event.add(this, type + ".specialChange", changeFilters[type]);
                }

                return rformElems.test(this.nodeName);
            },

            teardown: function (namespaces) {
                jQuery.event.remove(this, ".specialChange");

                return rformElems.test(this.nodeName);
            }
        };

        changeFilters = jQuery.event.special.change.filters;

        // Handle when the input is .focus()'d
        changeFilters.focus = changeFilters.beforeactivate;
    }

    function trigger(type, elem, args) {
        args[0].type = type;
        return jQuery.event.handle.apply(elem, args);
    }

    // Create "bubbling" focus and blur events
    if (document.addEventListener) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {
            jQuery.event.special[fix] = {
                setup: function () {
                    if (focusCounts[fix]++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function () {
                    if (--focusCounts[fix] === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };

            function handler(e) {
                e = jQuery.event.fix(e);
                e.type = fix;
                return jQuery.event.trigger(e, null, e.target);
            }
        });
    }

    jQuery.each(["bind", "one"], function (i, name) {
        jQuery.fn[name] = function (type, data, fn) {
            // Handle object literals
            if (typeof type === "object") {
                for (var key in type) {
                    this[name](key, data, type[key], fn);
                }
                return this;
            }

            if (jQuery.isFunction(data) || data === false) {
                fn = data;
                data = undefined;
            }

            var handler = name === "one" ? jQuery.proxy(fn, function (event) {
                jQuery(this).unbind(event, handler);
                return fn.apply(this, arguments);
            }) : fn;

            if (type === "unload" && name !== "one") {
                this.one(type, data, fn);

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.add(this[i], type, handler, data);
                }
            }

            return this;
        };
    });

    jQuery.fn.extend({
        unbind: function (type, fn) {
            // Handle object literals
            if (typeof type === "object" && !type.preventDefault) {
                for (var key in type) {
                    this.unbind(key, type[key]);
                }

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.remove(this[i], type, fn);
                }
            }

            return this;
        },

        delegate: function (selector, types, data, fn) {
            return this.live(types, data, fn, selector);
        },

        undelegate: function (selector, types, fn) {
            if (arguments.length === 0) {
                return this.unbind("live");

            } else {
                return this.die(types, null, fn, selector);
            }
        },

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },

        triggerHandler: function (type, data) {
            if (this[0]) {
                var event = jQuery.Event(type);
                event.preventDefault();
                event.stopPropagation();
                jQuery.event.trigger(event, data, this[0]);
                return event.result;
            }
        },

        toggle: function (fn) {
            // Save reference to arguments for access in closure
            var args = arguments, i = 1;

            // link all the functions, so any of them can unbind this click handler
            while (i < args.length) {
                jQuery.proxy(fn, args[i++]);
            }

            return this.click(jQuery.proxy(fn, function (event) {
                // Figure out which function to execute
                var lastToggle = (jQuery.data(this, "lastToggle" + fn.guid) || 0) % i;
                jQuery.data(this, "lastToggle" + fn.guid, lastToggle + 1);

                // Make sure that clicks stop
                event.preventDefault();

                // and execute the function
                return args[lastToggle].apply(this, arguments) || false;
            }));
        },

        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    var liveMap = {
        focus: "focusin",
        blur: "focusout",
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };

    jQuery.each(["live", "die"], function (i, name) {
        jQuery.fn[name] = function (types, data, fn, origSelector /* Internal Use Only */) {
            var type, i = 0, match, namespaces, preType,
                selector = origSelector || this.selector,
                context = origSelector ? this : jQuery(this.context);

            if (typeof types === "object" && !types.preventDefault) {
                for (var key in types) {
                    context[name](key, data, types[key], selector);
                }

                return this;
            }

            if (jQuery.isFunction(data)) {
                fn = data;
                data = undefined;
            }

            types = (types || "").split(" ");

            while ((type = types[i++]) != null) {
                match = rnamespaces.exec(type);
                namespaces = "";

                if (match) {
                    namespaces = match[0];
                    type = type.replace(rnamespaces, "");
                }

                if (type === "hover") {
                    types.push("mouseenter" + namespaces, "mouseleave" + namespaces);
                    continue;
                }

                preType = type;

                if (type === "focus" || type === "blur") {
                    types.push(liveMap[type] + namespaces);
                    type = type + namespaces;

                } else {
                    type = (liveMap[type] || type) + namespaces;
                }

                if (name === "live") {
                    // bind live handler
                    for (var j = 0, l = context.length; j < l; j++) {
                        jQuery.event.add(context[j], "live." + liveConvert(type, selector),
                            { data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType });
                    }

                } else {
                    // unbind live handler
                    context.unbind("live." + liveConvert(type, selector), fn);
                }
            }

            return this;
        };
    });

    function liveHandler(event) {
        var stop, maxLevel, elems = [], selectors = [],
            related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
            events = jQuery.data(this, this.nodeType ? "events" : "__events__");

        if (typeof events === "function") {
            events = events.events;
        }

        // Make sure we avoid non-left-click bubbling in Firefox (#3861)
        if (event.liveFired === this || !events || !events.live || event.button && event.type === "click") {
            return;
        }

        if (event.namespace) {
            namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
        }

        event.liveFired = this;

        var live = events.live.slice(0);

        for (j = 0; j < live.length; j++) {
            handleObj = live[j];

            if (handleObj.origType.replace(rnamespaces, "") === event.type) {
                selectors.push(handleObj.selector);

            } else {
                live.splice(j--, 1);
            }
        }

        match = jQuery(event.target).closest(selectors, event.currentTarget);

        for (i = 0, l = match.length; i < l; i++) {
            close = match[i];

            for (j = 0; j < live.length; j++) {
                handleObj = live[j];

                if (close.selector === handleObj.selector && (!namespace || namespace.test(handleObj.namespace))) {
                    elem = close.elem;
                    related = null;

                    // Those two events require additional checking
                    if (handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave") {
                        event.type = handleObj.preType;
                        related = jQuery(event.relatedTarget).closest(handleObj.selector)[0];
                    }

                    if (!related || related !== elem) {
                        elems.push({ elem: elem, handleObj: handleObj, level: close.level });
                    }
                }
            }
        }

        for (i = 0, l = elems.length; i < l; i++) {
            match = elems[i];

            if (maxLevel && match.level > maxLevel) {
                break;
            }

            event.currentTarget = match.elem;
            event.data = match.handleObj.data;
            event.handleObj = match.handleObj;

            ret = match.handleObj.origHandler.apply(match.elem, arguments);

            if (ret === false || event.isPropagationStopped()) {
                maxLevel = match.level;

                if (ret === false) {
                    stop = false;
                }
            }
        }

        return stop;
    }

    function liveConvert(type, selector) {
        return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspace, "&");
    }

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error").split(" "), function (i, name) {

            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
                if (fn == null) {
                    fn = data;
                    data = null;
                }

                return arguments.length > 0 ?
                    this.bind(name, data, fn) :
                    this.trigger(name);
            };

            if (jQuery.attrFn) {
                jQuery.attrFn[name] = true;
            }
        });

    // Prevent memory leaks in IE
    // Window isn't included so as not to unbind existing unload events
    // More info:
    //  - http://isaacschlueter.com/2006/10/msie-memory-leaks/
    if (window.attachEvent && !window.addEventListener) {
        jQuery(window).bind("unload", function () {
            for (var id in jQuery.cache) {
                if (jQuery.cache[id].handle) {
                    // Try/Catch is to handle iframes being unloaded, see #4280
                    try {
                        jQuery.event.remove(jQuery.cache[id].handle.elem);
                    } catch (e) { }
                }
            }
        });
    }


    /*!
     * Sizzle CSS Selector Engine - v1.0
     *  Copyright 2009, The Dojo Foundation
     *  Released under the MIT, BSD, and GPL Licenses.
     *  More information: http://sizzlejs.com/
     */
    (function () {

        var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
            done = 0,
            toString = Object.prototype.toString,
            hasDuplicate = false,
            baseHasDuplicate = true;

        // Here we check if the JavaScript engine is using some sort of
        // optimization where it does not always call our comparision
        // function. If that is the case, discard the hasDuplicate value.
        //   Thus far that includes Google Chrome.
        [0, 0].sort(function () {
            baseHasDuplicate = false;
            return 0;
        });

        var Sizzle = function (selector, context, results, seed) {
            results = results || [];
            context = context || document;

            var origContext = context;

            if (context.nodeType !== 1 && context.nodeType !== 9) {
                return [];
            }

            if (!selector || typeof selector !== "string") {
                return results;
            }

            var parts = [], m, set, checkSet, extra, prune = true, contextXML = Sizzle.isXML(context),
                soFar = selector, ret, cur, pop, i;

            // Reset the position of the chunker regexp (start from head)
            do {
                chunker.exec("");
                m = chunker.exec(soFar);

                if (m) {
                    soFar = m[3];

                    parts.push(m[1]);

                    if (m[2]) {
                        extra = m[3];
                        break;
                    }
                }
            } while (m);

            if (parts.length > 1 && origPOS.exec(selector)) {
                if (parts.length === 2 && Expr.relative[parts[0]]) {
                    set = posProcess(parts[0] + parts[1], context);
                } else {
                    set = Expr.relative[parts[0]] ?
                        [context] :
                        Sizzle(parts.shift(), context);

                    while (parts.length) {
                        selector = parts.shift();

                        if (Expr.relative[selector]) {
                            selector += parts.shift();
                        }

                        set = posProcess(selector, set);
                    }
                }
            } else {
                // Take a shortcut and set the context if the root selector is an ID
                // (but not if it'll be faster if the inner selector is an ID)
                if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
                    Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {
                    ret = Sizzle.find(parts.shift(), context, contextXML);
                    context = ret.expr ? Sizzle.filter(ret.expr, ret.set)[0] : ret.set[0];
                }

                if (context) {
                    ret = seed ?
                        { expr: parts.pop(), set: makeArray(seed) } :
                        Sizzle.find(parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML);
                    set = ret.expr ? Sizzle.filter(ret.expr, ret.set) : ret.set;

                    if (parts.length > 0) {
                        checkSet = makeArray(set);
                    } else {
                        prune = false;
                    }

                    while (parts.length) {
                        cur = parts.pop();
                        pop = cur;

                        if (!Expr.relative[cur]) {
                            cur = "";
                        } else {
                            pop = parts.pop();
                        }

                        if (pop == null) {
                            pop = context;
                        }

                        Expr.relative[cur](checkSet, pop, contextXML);
                    }
                } else {
                    checkSet = parts = [];
                }
            }

            if (!checkSet) {
                checkSet = set;
            }

            if (!checkSet) {
                Sizzle.error(cur || selector);
            }

            if (toString.call(checkSet) === "[object Array]") {
                if (!prune) {
                    results.push.apply(results, checkSet);
                } else if (context && context.nodeType === 1) {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i]))) {
                            results.push(set[i]);
                        }
                    }
                } else {
                    for (i = 0; checkSet[i] != null; i++) {
                        if (checkSet[i] && checkSet[i].nodeType === 1) {
                            results.push(set[i]);
                        }
                    }
                }
            } else {
                makeArray(checkSet, results);
            }

            if (extra) {
                Sizzle(extra, origContext, results, seed);
                Sizzle.uniqueSort(results);
            }

            return results;
        };

        Sizzle.uniqueSort = function (results) {
            if (sortOrder) {
                hasDuplicate = baseHasDuplicate;
                results.sort(sortOrder);

                if (hasDuplicate) {
                    for (var i = 1; i < results.length; i++) {
                        if (results[i] === results[i - 1]) {
                            results.splice(i--, 1);
                        }
                    }
                }
            }

            return results;
        };

        Sizzle.matches = function (expr, set) {
            return Sizzle(expr, null, null, set);
        };

        Sizzle.matchesSelector = function (node, expr) {
            return Sizzle(expr, null, null, [node]).length > 0;
        };

        Sizzle.find = function (expr, context, isXML) {
            var set;

            if (!expr) {
                return [];
            }

            for (var i = 0, l = Expr.order.length; i < l; i++) {
                var type = Expr.order[i], match;

                if ((match = Expr.leftMatch[type].exec(expr))) {
                    var left = match[1];
                    match.splice(1, 1);

                    if (left.substr(left.length - 1) !== "\\") {
                        match[1] = (match[1] || "").replace(/\\/g, "");
                        set = Expr.find[type](match, context, isXML);
                        if (set != null) {
                            expr = expr.replace(Expr.match[type], "");
                            break;
                        }
                    }
                }
            }

            if (!set) {
                set = context.getElementsByTagName("*");
            }

            return { set: set, expr: expr };
        };

        Sizzle.filter = function (expr, set, inplace, not) {
            var old = expr, result = [], curLoop = set, match, anyFound,
                isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);

            while (expr && set.length) {
                for (var type in Expr.filter) {
                    if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {
                        var filter = Expr.filter[type], found, item, left = match[1];
                        anyFound = false;

                        match.splice(1, 1);

                        if (left.substr(left.length - 1) === "\\") {
                            continue;
                        }

                        if (curLoop === result) {
                            result = [];
                        }

                        if (Expr.preFilter[type]) {
                            match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);

                            if (!match) {
                                anyFound = found = true;
                            } else if (match === true) {
                                continue;
                            }
                        }

                        if (match) {
                            for (var i = 0; (item = curLoop[i]) != null; i++) {
                                if (item) {
                                    found = filter(item, match, i, curLoop);
                                    var pass = not ^ !!found;

                                    if (inplace && found != null) {
                                        if (pass) {
                                            anyFound = true;
                                        } else {
                                            curLoop[i] = false;
                                        }
                                    } else if (pass) {
                                        result.push(item);
                                        anyFound = true;
                                    }
                                }
                            }
                        }

                        if (found !== undefined) {
                            if (!inplace) {
                                curLoop = result;
                            }

                            expr = expr.replace(Expr.match[type], "");

                            if (!anyFound) {
                                return [];
                            }

                            break;
                        }
                    }
                }

                // Improper expression
                if (expr === old) {
                    if (anyFound == null) {
                        Sizzle.error(expr);
                    } else {
                        break;
                    }
                }

                old = expr;
            }

            return curLoop;
        };

        Sizzle.error = function (msg) {
            throw "Syntax error, unrecognized expression: " + msg;
        };

        var Expr = Sizzle.selectors = {
            order: ["ID", "NAME", "TAG"],
            match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            },
            leftMatch: {},
            attrMap: {
                "class": "className",
                "for": "htmlFor"
            },
            attrHandle: {
                href: function (elem) {
                    return elem.getAttribute("href");
                }
            },
            relative: {
                "+": function (checkSet, part) {
                    var isPartStr = typeof part === "string",
                        isTag = isPartStr && !/\W/.test(part),
                        isPartStrNotTag = isPartStr && !isTag;

                    if (isTag) {
                        part = part.toLowerCase();
                    }

                    for (var i = 0, l = checkSet.length, elem; i < l; i++) {
                        if ((elem = checkSet[i])) {
                            while ((elem = elem.previousSibling) && elem.nodeType !== 1) { }

                            checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
                                elem || false :
                                elem === part;
                        }
                    }

                    if (isPartStrNotTag) {
                        Sizzle.filter(part, checkSet, true);
                    }
                },
                ">": function (checkSet, part) {
                    var isPartStr = typeof part === "string",
                        elem, i = 0, l = checkSet.length;

                    if (isPartStr && !/\W/.test(part)) {
                        part = part.toLowerCase();

                        for (; i < l; i++) {
                            elem = checkSet[i];
                            if (elem) {
                                var parent = elem.parentNode;
                                checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                            }
                        }
                    } else {
                        for (; i < l; i++) {
                            elem = checkSet[i];
                            if (elem) {
                                checkSet[i] = isPartStr ?
                                    elem.parentNode :
                                    elem.parentNode === part;
                            }
                        }

                        if (isPartStr) {
                            Sizzle.filter(part, checkSet, true);
                        }
                    }
                },
                "": function (checkSet, part, isXML) {
                    var doneName = done++, checkFn = dirCheck, nodeCheck;

                    if (typeof part === "string" && !/\W/.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
                },
                "~": function (checkSet, part, isXML) {
                    var doneName = done++, checkFn = dirCheck, nodeCheck;

                    if (typeof part === "string" && !/\W/.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("previousSibling", part, doneName, checkSet, nodeCheck, isXML);
                }
            },
            find: {
                ID: function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);
                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        return m && m.parentNode ? [m] : [];
                    }
                },
                NAME: function (match, context) {
                    if (typeof context.getElementsByName !== "undefined") {
                        var ret = [], results = context.getElementsByName(match[1]);

                        for (var i = 0, l = results.length; i < l; i++) {
                            if (results[i].getAttribute("name") === match[1]) {
                                ret.push(results[i]);
                            }
                        }

                        return ret.length === 0 ? null : ret;
                    }
                },
                TAG: function (match, context) {
                    return context.getElementsByTagName(match[1]);
                }
            },
            preFilter: {
                CLASS: function (match, curLoop, inplace, result, not, isXML) {
                    match = " " + match[1].replace(/\\/g, "") + " ";

                    if (isXML) {
                        return match;
                    }

                    for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {
                        if (elem) {
                            if (not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n]/g, " ").indexOf(match) >= 0)) {
                                if (!inplace) {
                                    result.push(elem);
                                }
                            } else if (inplace) {
                                curLoop[i] = false;
                            }
                        }
                    }

                    return false;
                },
                ID: function (match) {
                    return match[1].replace(/\\/g, "");
                },
                TAG: function (match, curLoop) {
                    return match[1].toLowerCase();
                },
                CHILD: function (match) {
                    if (match[1] === "nth") {
                        // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                        var test = /(-?)(\d*)n((?:\+|-)?\d*)/.exec(
                            match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
                            !/\D/.test(match[2]) && "0n+" + match[2] || match[2]);

                        // calculate the numbers (first)n+(last) including if they are negative
                        match[2] = (test[1] + (test[2] || 1)) - 0;
                        match[3] = test[3] - 0;
                    }

                    // TODO: Move to normal caching system
                    match[0] = done++;

                    return match;
                },
                ATTR: function (match, curLoop, inplace, result, not, isXML) {
                    var name = match[1].replace(/\\/g, "");

                    if (!isXML && Expr.attrMap[name]) {
                        match[1] = Expr.attrMap[name];
                    }

                    if (match[2] === "~=") {
                        match[4] = " " + match[4] + " ";
                    }

                    return match;
                },
                PSEUDO: function (match, curLoop, inplace, result, not) {
                    if (match[1] === "not") {
                        // If we're dealing with a complex expression, or a simple one
                        if ((chunker.exec(match[3]) || "").length > 1 || /^\w/.test(match[3])) {
                            match[3] = Sizzle(match[3], null, null, curLoop);
                        } else {
                            var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
                            if (!inplace) {
                                result.push.apply(result, ret);
                            }
                            return false;
                        }
                    } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {
                        return true;
                    }

                    return match;
                },
                POS: function (match) {
                    match.unshift(true);
                    return match;
                }
            },
            filters: {
                enabled: function (elem) {
                    return elem.disabled === false && elem.type !== "hidden";
                },
                disabled: function (elem) {
                    return elem.disabled === true;
                },
                checked: function (elem) {
                    return elem.checked === true;
                },
                selected: function (elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    elem.parentNode.selectedIndex;
                    return elem.selected === true;
                },
                parent: function (elem) {
                    return !!elem.firstChild;
                },
                empty: function (elem) {
                    return !elem.firstChild;
                },
                has: function (elem, i, match) {
                    return !!Sizzle(match[3], elem).length;
                },
                header: function (elem) {
                    return (/h\d/i).test(elem.nodeName);
                },
                text: function (elem) {
                    return "text" === elem.type;
                },
                radio: function (elem) {
                    return "radio" === elem.type;
                },
                checkbox: function (elem) {
                    return "checkbox" === elem.type;
                },
                file: function (elem) {
                    return "file" === elem.type;
                },
                password: function (elem) {
                    return "password" === elem.type;
                },
                submit: function (elem) {
                    return "submit" === elem.type;
                },
                image: function (elem) {
                    return "image" === elem.type;
                },
                reset: function (elem) {
                    return "reset" === elem.type;
                },
                button: function (elem) {
                    return "button" === elem.type || elem.nodeName.toLowerCase() === "button";
                },
                input: function (elem) {
                    return (/input|select|textarea|button/i).test(elem.nodeName);
                }
            },
            setFilters: {
                first: function (elem, i) {
                    return i === 0;
                },
                last: function (elem, i, match, array) {
                    return i === array.length - 1;
                },
                even: function (elem, i) {
                    return i % 2 === 0;
                },
                odd: function (elem, i) {
                    return i % 2 === 1;
                },
                lt: function (elem, i, match) {
                    return i < match[3] - 0;
                },
                gt: function (elem, i, match) {
                    return i > match[3] - 0;
                },
                nth: function (elem, i, match) {
                    return match[3] - 0 === i;
                },
                eq: function (elem, i, match) {
                    return match[3] - 0 === i;
                }
            },
            filter: {
                PSEUDO: function (elem, match, i, array) {
                    var name = match[1], filter = Expr.filters[name];

                    if (filter) {
                        return filter(elem, i, match, array);
                    } else if (name === "contains") {
                        return (elem.textContent || elem.innerText || Sizzle.getText([elem]) || "").indexOf(match[3]) >= 0;
                    } else if (name === "not") {
                        var not = match[3];

                        for (var j = 0, l = not.length; j < l; j++) {
                            if (not[j] === elem) {
                                return false;
                            }
                        }

                        return true;
                    } else {
                        Sizzle.error("Syntax error, unrecognized expression: " + name);
                    }
                },
                CHILD: function (elem, match) {
                    var type = match[1], node = elem;
                    switch (type) {
                        case 'only':
                        case 'first':
                            while ((node = node.previousSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }
                            if (type === "first") {
                                return true;
                            }
                            node = elem;
                        case 'last':
                            while ((node = node.nextSibling)) {
                                if (node.nodeType === 1) {
                                    return false;
                                }
                            }
                            return true;
                        case 'nth':
                            var first = match[2], last = match[3];

                            if (first === 1 && last === 0) {
                                return true;
                            }

                            var doneName = match[0],
                                parent = elem.parentNode;

                            if (parent && (parent.sizcache !== doneName || !elem.nodeIndex)) {
                                var count = 0;
                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        node.nodeIndex = ++count;
                                    }
                                }
                                parent.sizcache = doneName;
                            }

                            var diff = elem.nodeIndex - last;
                            if (first === 0) {
                                return diff === 0;
                            } else {
                                return (diff % first === 0 && diff / first >= 0);
                            }
                    }
                },
                ID: function (elem, match) {
                    return elem.nodeType === 1 && elem.getAttribute("id") === match;
                },
                TAG: function (elem, match) {
                    return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
                },
                CLASS: function (elem, match) {
                    return (" " + (elem.className || elem.getAttribute("class")) + " ")
                        .indexOf(match) > -1;
                },
                ATTR: function (elem, match) {
                    var name = match[1],
                        result = Expr.attrHandle[name] ?
                            Expr.attrHandle[name](elem) :
                            elem[name] != null ?
                                elem[name] :
                                elem.getAttribute(name),
                        value = result + "",
                        type = match[2],
                        check = match[4];

                    return result == null ?
                        type === "!=" :
                        type === "=" ?
                            value === check :
                            type === "*=" ?
                                value.indexOf(check) >= 0 :
                                type === "~=" ?
                                    (" " + value + " ").indexOf(check) >= 0 :
                                    !check ?
                                        value && result !== false :
                                        type === "!=" ?
                                            value !== check :
                                            type === "^=" ?
                                                value.indexOf(check) === 0 :
                                                type === "$=" ?
                                                    value.substr(value.length - check.length) === check :
                                                    type === "|=" ?
                                                        value === check || value.substr(0, check.length + 1) === check + "-" :
                                                        false;
                },
                POS: function (elem, match, i, array) {
                    var name = match[2], filter = Expr.setFilters[name];

                    if (filter) {
                        return filter(elem, i, match, array);
                    }
                }
            }
        };

        var origPOS = Expr.match.POS,
            fescape = function (all, num) {
                return "\\" + (num - 0 + 1);
            };

        for (var type in Expr.match) {
            Expr.match[type] = new RegExp(Expr.match[type].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
            Expr.leftMatch[type] = new RegExp(/(^(?:.|\r|\n)*?)/.source + Expr.match[type].source.replace(/\\(\d+)/g, fescape));
        }

        var makeArray = function (array, results) {
            array = Array.prototype.slice.call(array, 0);

            if (results) {
                results.push.apply(results, array);
                return results;
            }

            return array;
        };

        // Perform a simple check to determine if the browser is capable of
        // converting a NodeList to an array using builtin methods.
        // Also verifies that the returned array holds DOM nodes
        // (which is not the case in the Blackberry browser)
        try {
            Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;

            // Provide a fallback method if it does not work
        } catch (e) {
            makeArray = function (array, results) {
                var ret = results || [], i = 0;

                if (toString.call(array) === "[object Array]") {
                    Array.prototype.push.apply(ret, array);
                } else {
                    if (typeof array.length === "number") {
                        for (var l = array.length; i < l; i++) {
                            ret.push(array[i]);
                        }
                    } else {
                        for (; array[i]; i++) {
                            ret.push(array[i]);
                        }
                    }
                }

                return ret;
            };
        }

        var sortOrder, siblingCheck;

        if (document.documentElement.compareDocumentPosition) {
            sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
                    return a.compareDocumentPosition ? -1 : 1;
                }

                return a.compareDocumentPosition(b) & 4 ? -1 : 1;
            };
        } else {
            sortOrder = function (a, b) {
                var ap = [], bp = [], aup = a.parentNode, bup = b.parentNode,
                    cur = aup, al, bl;

                // The nodes are identical, we can exit early
                if (a === b) {
                    hasDuplicate = true;
                    return 0;

                    // If the nodes are siblings (or identical) we can do a quick check
                } else if (aup === bup) {
                    return siblingCheck(a, b);

                    // If no parents were found then the nodes are disconnected
                } else if (!aup) {
                    return -1;

                } else if (!bup) {
                    return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while (cur) {
                    ap.unshift(cur);
                    cur = cur.parentNode;
                }

                cur = bup;

                while (cur) {
                    bp.unshift(cur);
                    cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for (var i = 0; i < al && i < bl; i++) {
                    if (ap[i] !== bp[i]) {
                        return siblingCheck(ap[i], bp[i]);
                    }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
                    siblingCheck(a, bp[i], -1) :
                    siblingCheck(ap[i], b, 1);
            };

            siblingCheck = function (a, b, ret) {
                if (a === b) {
                    return ret;
                }

                var cur = a.nextSibling;

                while (cur) {
                    if (cur === b) {
                        return -1;
                    }

                    cur = cur.nextSibling;
                }

                return 1;
            };
        }

        // Utility function for retreiving the text value of an array of DOM nodes
        Sizzle.getText = function (elems) {
            var ret = "", elem;

            for (var i = 0; elems[i]; i++) {
                elem = elems[i];

                // Get the text from text nodes and CDATA nodes
                if (elem.nodeType === 3 || elem.nodeType === 4) {
                    ret += elem.nodeValue;

                    // Traverse everything else, except comment nodes
                } else if (elem.nodeType !== 8) {
                    ret += Sizzle.getText(elem.childNodes);
                }
            }

            return ret;
        };

        // Check to see if the browser returns elements by name when
        // querying by getElementById (and provide a workaround)
        (function () {
            // We're going to inject a fake input element with a specified name
            var form = document.createElement("div"),
                id = "script" + (new Date()).getTime();
            form.innerHTML = "<a name='" + id + "'/>";

            // Inject it into the root element, check its status, and remove it quickly
            var root = document.documentElement;
            root.insertBefore(form, root.firstChild);

            // The workaround has to do additional checks after a getElementById
            // Which slows things down for other browsers (hence the branching)
            if (document.getElementById(id)) {
                Expr.find.ID = function (match, context, isXML) {
                    if (typeof context.getElementById !== "undefined" && !isXML) {
                        var m = context.getElementById(match[1]);
                        return m ? m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ? [m] : undefined : [];
                    }
                };

                Expr.filter.ID = function (elem, match) {
                    var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                    return elem.nodeType === 1 && node && node.nodeValue === match;
                };
            }

            root.removeChild(form);
            root = form = null; // release memory in IE
        })();

        (function () {
            // Check to see if the browser returns only elements
            // when doing getElementsByTagName("*")

            // Create a fake element
            var div = document.createElement("div");
            div.appendChild(document.createComment(""));

            // Make sure no comments are found
            if (div.getElementsByTagName("*").length > 0) {
                Expr.find.TAG = function (match, context) {
                    var results = context.getElementsByTagName(match[1]);

                    // Filter out possible comments
                    if (match[1] === "*") {
                        var tmp = [];

                        for (var i = 0; results[i]; i++) {
                            if (results[i].nodeType === 1) {
                                tmp.push(results[i]);
                            }
                        }

                        results = tmp;
                    }

                    return results;
                };
            }

            // Check to see if an attribute returns normalized href attributes
            div.innerHTML = "<a href='#'></a>";
            if (div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
                div.firstChild.getAttribute("href") !== "#") {
                Expr.attrHandle.href = function (elem) {
                    return elem.getAttribute("href", 2);
                };
            }

            div = null; // release memory in IE
        })();

        if (document.querySelectorAll) {
            (function () {
                var oldSizzle = Sizzle, div = document.createElement("div");
                div.innerHTML = "<p class='TEST'></p>";

                // Safari can't handle uppercase or unicode characters when
                // in quirks mode.
                if (div.querySelectorAll && div.querySelectorAll(".TEST").length === 0) {
                    return;
                }

                Sizzle = function (query, context, extra, seed) {
                    context = context || document;

                    // Only use querySelectorAll on non-XML documents
                    // (ID selectors don't work in non-HTML documents)
                    if (!seed && !Sizzle.isXML(context)) {
                        if (context.nodeType === 9) {
                            try {
                                return makeArray(context.querySelectorAll(query), extra);
                            } catch (qsaError) { }

                            // qSA works strangely on Element-rooted queries
                            // We can work around this by specifying an extra ID on the root
                            // and working up from there (Thanks to Andrew Dupont for the technique)
                            // IE 8 doesn't work on object elements
                        } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            var old = context.id, id = context.id = "__sizzle__";

                            try {
                                return makeArray(context.querySelectorAll("#" + id + " " + query), extra);

                            } catch (pseudoError) {
                            } finally {
                                if (old) {
                                    context.id = old;

                                } else {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }

                    return oldSizzle(query, context, extra, seed);
                };

                for (var prop in oldSizzle) {
                    Sizzle[prop] = oldSizzle[prop];
                }

                div = null; // release memory in IE
            })();
        }

        (function () {
            var html = document.documentElement,
                matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector,
                pseudoWorks = false;

            try {
                // This should fail with an exception
                // Gecko does not error, returns false instead
                matches.call(document.documentElement, ":sizzle");

            } catch (pseudoError) {
                pseudoWorks = true;
            }

            if (matches) {
                Sizzle.matchesSelector = function (node, expr) {
                    try {
                        if (pseudoWorks || !Expr.match.PSEUDO.test(expr)) {
                            return matches.call(node, expr);
                        }
                    } catch (e) { }

                    return Sizzle(expr, null, null, [node]).length > 0;
                };
            }
        })();

        (function () {
            var div = document.createElement("div");

            div.innerHTML = "<div class='test e'></div><div class='test'></div>";

            // Opera can't find a second classname (in 9.6)
            // Also, make sure that getElementsByClassName actually exists
            if (!div.getElementsByClassName || div.getElementsByClassName("e").length === 0) {
                return;
            }

            // Safari caches class attributes, doesn't catch changes (in 3.2)
            div.lastChild.className = "e";

            if (div.getElementsByClassName("e").length === 1) {
                return;
            }

            Expr.order.splice(1, 0, "CLASS");
            Expr.find.CLASS = function (match, context, isXML) {
                if (typeof context.getElementsByClassName !== "undefined" && !isXML) {
                    return context.getElementsByClassName(match[1]);
                }
            };

            div = null; // release memory in IE
        })();

        function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];
                if (elem) {
                    elem = elem[dir];
                    var match = false;

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1 && !isXML) {
                            elem.sizcache = doneName;
                            elem.sizset = i;
                        }

                        if (elem.nodeName.toLowerCase() === cur) {
                            match = elem;
                            break;
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {
            for (var i = 0, l = checkSet.length; i < l; i++) {
                var elem = checkSet[i];
                if (elem) {
                    elem = elem[dir];
                    var match = false;

                    while (elem) {
                        if (elem.sizcache === doneName) {
                            match = checkSet[elem.sizset];
                            break;
                        }

                        if (elem.nodeType === 1) {
                            if (!isXML) {
                                elem.sizcache = doneName;
                                elem.sizset = i;
                            }
                            if (typeof cur !== "string") {
                                if (elem === cur) {
                                    match = true;
                                    break;
                                }

                            } else if (Sizzle.filter(cur, [elem]).length > 0) {
                                match = elem;
                                break;
                            }
                        }

                        elem = elem[dir];
                    }

                    checkSet[i] = match;
                }
            }
        }

        Sizzle.contains = document.documentElement.contains ? function (a, b) {
            return a !== b && (a.contains ? a.contains(b) : true);
        } : function (a, b) {
            return !!(a.compareDocumentPosition(b) & 16);
        };

        Sizzle.isXML = function (elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833) 
            var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        var posProcess = function (selector, context) {
            var tmpSet = [], later = "", match,
                root = context.nodeType ? [context] : context;

            // Position selectors must be done after the filter
            // And so must :not(positional) so we move all PSEUDOs to the end
            while ((match = Expr.match.PSEUDO.exec(selector))) {
                later += match[0];
                selector = selector.replace(Expr.match.PSEUDO, "");
            }

            selector = Expr.relative[selector] ? selector + "*" : selector;

            for (var i = 0, l = root.length; i < l; i++) {
                Sizzle(selector, root[i], tmpSet);
            }

            return Sizzle.filter(later, tmpSet);
        };

        // EXPOSE
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.filters;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
        rparentsprev = /^(?:parents|prevUntil|prevAll)/,
        // Note: This RegExp should be improved, or likely pulled from Sizzle
        rmultiselector = /,/,
        isSimple = /^.[^:#\[\.,]*$/,
        slice = Array.prototype.slice,
        POS = jQuery.expr.match.POS;

    jQuery.fn.extend({
        find: function (selector) {
            var ret = this.pushStack("", "find", selector), length = 0;

            for (var i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                    // Make sure that the results are unique
                    for (var n = length; n < ret.length; n++) {
                        for (var r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function (target) {
            var targets = jQuery(target);
            return this.filter(function () {
                for (var i = 0, l = targets.length; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        not: function (selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: function (selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },

        is: function (selector) {
            return !!selector && jQuery.filter(selector, this).length > 0;
        },

        closest: function (selectors, context) {
            var ret = [], i, l, cur = this[0];

            if (jQuery.isArray(selectors)) {
                var match, matches = {}, selector, level = 1;

                if (cur && selectors.length) {
                    for (i = 0, l = selectors.length; i < l; i++) {
                        selector = selectors[i];

                        if (!matches[selector]) {
                            matches[selector] = jQuery.expr.match.POS.test(selector) ?
                                jQuery(selector, context || this.context) :
                                selector;
                        }
                    }

                    while (cur && cur.ownerDocument && cur !== context) {
                        for (selector in matches) {
                            match = matches[selector];

                            if (match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match)) {
                                ret.push({ selector: selector, elem: cur, level: level });
                            }
                        }

                        cur = cur.parentNode;
                        level++;
                    }
                }

                return ret;
            }

            var pos = POS.test(selectors) ?
                jQuery(selectors, context || this.context) : null;

            for (i = 0, l = this.length; i < l; i++) {
                cur = this[i];

                while (cur) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;

                    } else {
                        cur = cur.parentNode;
                        if (!cur || !cur.ownerDocument || cur === context) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function (elem) {
            if (!elem || typeof elem === "string") {
                return jQuery.inArray(this[0],
                    // If it receives a string, the selector is used
                    // If it receives nothing, the siblings are used
                    elem ? jQuery(elem) : this.parent().children());
            }
            // Locate the position of the desired element
            return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this);
        },

        add: function (selector, context) {
            var set = typeof selector === "string" ?
                jQuery(selector, context || this.context) :
                jQuery.makeArray(selector),
                all = jQuery.merge(this.get(), set);

            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
                all :
                jQuery.unique(all));
        },

        andSelf: function () {
            return this.add(this.prevObject);
        }
    });

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return jQuery.nth(elem, 2, "nextSibling");
        },
        prev: function (elem) {
            return jQuery.nth(elem, 2, "previousSibling");
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return jQuery.sibling(elem.parentNode.firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, "iframe") ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.makeArray(elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until);

            if (!runtil.test(name)) {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }

            ret = this.length > 1 ? jQuery.unique(ret) : ret;

            if ((this.length > 1 || rmultiselector.test(selector)) && rparentsprev.test(name)) {
                ret = ret.reverse();
            }

            return this.pushStack(ret, name, slice.call(arguments).join(","));
        };
    });

    jQuery.extend({
        filter: function (expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
                jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
                jQuery.find.matches(expr, elems);
        },

        dir: function (elem, dir, until) {
            var matched = [], cur = elem[dir];
            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        nth: function (cur, result, dir, elem) {
            result = result || 1;
            var num = 0;

            for (; cur; cur = cur[dir]) {
                if (cur.nodeType === 1 && ++num === result) {
                    break;
                }
            }

            return cur;
        },

        sibling: function (n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, keep) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });

        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem, i) {
                return (elem === qualifier) === keep;
            });

        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function (elem) {
                return elem.nodeType === 1;
            });

            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }

        return jQuery.grep(elements, function (elem, i) {
            return (jQuery.inArray(elem, qualifier) >= 0) === keep;
        });
    }




    var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnocache = /<(?:script|object|embed|option|style)/i,
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,  // checked="checked" or checked (html5)
        raction = /\=([^="'>\s]+\/)>/g,
        wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            area: [1, "<map>", "</map>"],
            _default: [0, "", ""]
        };

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE can't serialize <link> and <script> tags normally
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "div<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: function (text) {
            if (jQuery.isFunction(text)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self.text(text.call(this, i, self.text()));
                });
            }

            if (typeof text !== "object" && text !== undefined) {
                return this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(text));
            }

            return jQuery.text(this);
        },

        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this), contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            return this.each(function () {
                jQuery(this).wrapAll(html);
            });
        },

        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },

        append: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return this.domManip(arguments, true, function (elem) {
                if (this.nodeType === 1) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },

        before: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            } else if (arguments.length) {
                var set = jQuery(arguments[0]);
                set.push.apply(set, this.toArray());
                return this.pushStack(set, "before", arguments);
            }
        },

        after: function () {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function (elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            } else if (arguments.length) {
                var set = this.pushStack(this, "after", arguments);
                set.push.apply(set, jQuery(arguments[0]).toArray());
                return set;
            }
        },

        // keepData is for internal use only--do not document
        remove: function (selector, keepData) {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]);
                    }

                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }

            return this;
        },

        empty: function () {
            for (var i = 0, elem; (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }

            return this;
        },

        clone: function (events) {
            // Do the clone
            var ret = this.map(function () {
                if (!jQuery.support.noCloneEvent && !jQuery.isXMLDoc(this)) {
                    // IE copies events bound via attachEvent when
                    // using cloneNode. Calling detachEvent on the
                    // clone will also remove the events from the orignal
                    // In order to get around this, we use innerHTML.
                    // Unfortunately, this means some modifications to
                    // attributes in IE that are actually only stored
                    // as properties will not be copied (such as the
                    // the name attribute on an input).
                    var html = this.outerHTML, ownerDocument = this.ownerDocument;
                    if (!html) {
                        var div = ownerDocument.createElement("div");
                        div.appendChild(this.cloneNode(true));
                        html = div.innerHTML;
                    }

                    return jQuery.clean([html.replace(rinlinejQuery, "")
                        // Handle the case in IE 8 where action=/test/> self-closes a tag
                        .replace(raction, '="$1">')
                        .replace(rleadingWhitespace, "")], ownerDocument)[0];
                } else {
                    return this.cloneNode(true);
                }
            });

            // Copy the events from the original to the clone
            if (events === true) {
                cloneCopyEvent(this, ret);
                cloneCopyEvent(this.find("*"), ret.find("*"));
            }

            // Return the cloned set
            return ret;
        },

        html: function (value) {
            if (value === undefined) {
                return this[0] && this[0].nodeType === 1 ?
                    this[0].innerHTML.replace(rinlinejQuery, "") :
                    null;

                // See if we can take a shortcut and just use innerHTML
            } else if (typeof value === "string" && !rnocache.test(value) &&
                (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
                !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                value = value.replace(rxhtmlTag, "<$1></$2>");

                try {
                    for (var i = 0, l = this.length; i < l; i++) {
                        // Remove element nodes and prevent memory leaks
                        if (this[i].nodeType === 1) {
                            jQuery.cleanData(this[i].getElementsByTagName("*"));
                            this[i].innerHTML = value;
                        }
                    }

                    // If using innerHTML throws an exception, use the fallback method
                } catch (e) {
                    this.empty().append(value);
                }

            } else if (jQuery.isFunction(value)) {
                this.each(function (i) {
                    var self = jQuery(this);
                    self.html(value.call(this, i, self.html()));
                });

            } else {
                this.empty().append(value);
            }

            return this;
        },

        replaceWith: function (value) {
            if (this[0] && this[0].parentNode) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        var self = jQuery(this), old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }

                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }

                return this.each(function () {
                    var next = this.nextSibling, parent = this.parentNode;

                    jQuery(this).remove();

                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            } else {
                return this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value);
            }
        },

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip: function (args, table, callback) {
            var results, first, value = args[0], scripts = [], fragment, parent;

            // We can't cloneNode fragments that contain checked, in WebKit
            if (!jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function () {
                    jQuery(this).domManip(args, table, callback, true);
                });
            }

            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }

            if (this[0]) {
                parent = value && value.parentNode;

                // If we're in a fragment, just use that instead of building a new one
                if (jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length) {
                    results = { fragment: parent };

                } else {
                    results = jQuery.buildFragment(args, this, scripts);
                }

                fragment = results.fragment;

                if (fragment.childNodes.length === 1) {
                    first = fragment = fragment.firstChild;
                } else {
                    first = fragment.firstChild;
                }

                if (first) {
                    table = table && jQuery.nodeName(first, "tr");

                    for (var i = 0, l = this.length; i < l; i++) {
                        callback.call(
                            table ?
                                root(this[i], first) :
                                this[i],
                            i > 0 || results.cacheable || this.length > 1 ?
                                fragment.cloneNode(true) :
                                fragment
                        );
                    }
                }

                if (scripts.length) {
                    jQuery.each(scripts, evalScript);
                }
            }

            return this;
        }
    });

    function root(elem, cur) {
        return jQuery.nodeName(elem, "table") ?
            (elem.getElementsByTagName("tbody")[0] ||
                elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
            elem;
    }

    function cloneCopyEvent(orig, ret) {
        var i = 0;

        ret.each(function () {
            if (this.nodeName !== (orig[i] && orig[i].nodeName)) {
                return;
            }

            var oldData = jQuery.data(orig[i++]), curData = jQuery.data(this, oldData), events = oldData && oldData.events;

            if (events) {
                delete curData.handle;
                curData.events = {};

                for (var type in events) {
                    for (var handler in events[type]) {
                        jQuery.event.add(this, type, events[type][handler], events[type][handler].data);
                    }
                }
            }
        });
    }

    jQuery.buildFragment = function (args, nodes, scripts) {
        var fragment, cacheable, cacheresults,
            doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);

        // Only cache "small" (1/2 KB) strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        if (args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
            !rnocache.test(args[0]) && (jQuery.support.checkClone || !rchecked.test(args[0]))) {

            cacheable = true;
            cacheresults = jQuery.fragments[args[0]];
            if (cacheresults) {
                if (cacheresults !== 1) {
                    fragment = cacheresults;
                }
            }
        }

        if (!fragment) {
            fragment = doc.createDocumentFragment();
            jQuery.clean(args, doc, fragment, scripts);
        }

        if (cacheable) {
            jQuery.fragments[args[0]] = cacheresults ? fragment : 1;
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var ret = [], insert = jQuery(selector),
                parent = this.length === 1 && this[0].parentNode;

            if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {
                insert[original](this[0]);
                return this;

            } else {
                for (var i = 0, l = insert.length; i < l; i++) {
                    var elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    jQuery.extend({
        clean: function (elems, context, fragment, scripts) {
            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if (typeof context.createElement === "undefined") {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            var ret = [];

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string" && !rhtml.test(elem)) {
                    elem = context.createTextNode(elem);

                } else if (typeof elem === "string") {
                    // Fix "XHTML"-style tags in all browsers
                    elem = elem.replace(rxhtmlTag, "<$1></$2>");

                    // Trim whitespace, otherwise indexOf won't work as expected
                    var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
                        wrap = wrapMap[tag] || wrapMap._default,
                        depth = wrap[0],
                        div = context.createElement("div");

                    // Go to html and back, then peel off extra wrappers
                    div.innerHTML = wrap[1] + elem + wrap[2];

                    // Move to the right depth
                    while (depth--) {
                        div = div.lastChild;
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if (!jQuery.support.tbody) {

                        // String was a <table>, *may* have spurious <tbody>
                        var hasBody = rtbody.test(elem),
                            tbody = tag === "table" && !hasBody ?
                                div.firstChild && div.firstChild.childNodes :

                                // String was a bare <thead> or <tfoot>
                                wrap[1] === "<table>" && !hasBody ?
                                    div.childNodes :
                                    [];

                        for (var j = tbody.length - 1; j >= 0; --j) {
                            if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                tbody[j].parentNode.removeChild(tbody[j]);
                            }
                        }

                    }

                    // IE completely kills leading whitespace when innerHTML is used
                    if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                        div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                    }

                    elem = div.childNodes;
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    ret = jQuery.merge(ret, elem);
                }
            }

            if (fragment) {
                for (i = 0; ret[i]; i++) {
                    if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
                        scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);

                    } else {
                        if (ret[i].nodeType === 1) {
                            ret.splice.apply(ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName("script"))));
                        }
                        fragment.appendChild(ret[i]);
                    }
                }
            }

            return ret;
        },

        cleanData: function (elems) {
            var data, id, cache = jQuery.cache,
                special = jQuery.event.special,
                deleteExpando = jQuery.support.deleteExpando;

            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {
                    continue;
                }

                id = elem[jQuery.expando];

                if (id) {
                    data = cache[id];

                    if (data && data.events) {
                        for (var type in data.events) {
                            if (special[type]) {
                                jQuery.event.remove(elem, type);

                            } else {
                                jQuery.removeEvent(elem, type, data.handle);
                            }
                        }
                    }

                    if (deleteExpando) {
                        delete elem[jQuery.expando];

                    } else if (elem.removeAttribute) {
                        elem.removeAttribute(jQuery.expando);
                    }

                    delete cache[id];
                }
            }
        }
    });

    function evalScript(i, elem) {
        if (elem.src) {
            jQuery.ajax({
                url: elem.src,
                async: false,
                dataType: "script"
            });
        } else {
            jQuery.globalEval(elem.text || elem.textContent || elem.innerHTML || "");
        }

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }




    var ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity=([^)]*)/,
        rdashAlpha = /-([a-z])/ig,
        rupper = /([A-Z])/g,
        rnumpx = /^-?\d+(?:px)?$/i,
        rnum = /^-?\d/,

        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssWidth = ["Left", "Right"],
        cssHeight = ["Top", "Bottom"],
        curCSS,

        // cache check for defaultView.getComputedStyle
        getComputedStyle = document.defaultView && document.defaultView.getComputedStyle,

        fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };

    jQuery.fn.css = function (name, value) {
        // Setting 'undefined' is a no-op
        if (arguments.length === 2 && value === undefined) {
            return this;
        }

        return jQuery.access(this, name, value, true, function (elem, name, value) {
            return value !== undefined ?
                jQuery.style(elem, name, value) :
                jQuery.css(elem, name);
        });
    };

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity", "opacity");
                        return ret === "" ? "1" : ret;

                    } else {
                        return elem.style.opacity;
                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "zIndex": true,
            "fontWeight": true,
            "opacity": true,
            "zoom": true,
            "lineHeight": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, origName = jQuery.camelCase(name),
                style = elem.style, hooks = jQuery.cssHooks[origName];

            name = jQuery.cssProps[origName] || origName;

            // Check if we're setting a value
            if (value !== undefined) {
                // Make sure that NaN and null values aren't set. See: #7116
                if (typeof value === "number" && isNaN(value) || value == null) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (typeof value === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value)) !== undefined) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[name] = value;
                    } catch (e) { }
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra) {
            // Make sure that we're working with the right name
            var ret, origName = jQuery.camelCase(name),
                hooks = jQuery.cssHooks[origName];

            name = jQuery.cssProps[origName] || origName;

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks && (ret = hooks.get(elem, true, extra)) !== undefined) {
                return ret;

                // Otherwise, if a way to get the computed value exists, use that
            } else if (curCSS) {
                return curCSS(elem, name, origName);
            }
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function (elem, options, callback) {
            var old = {};

            // Remember the old values, and insert the new ones
            for (var name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }

            callback.call(elem);

            // Revert the old values
            for (name in options) {
                elem.style[name] = old[name];
            }
        },

        camelCase: function (string) {
            return string.replace(rdashAlpha, fcamelCase);
        }
    });

    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                var val;

                if (computed) {
                    if (elem.offsetWidth !== 0) {
                        val = getWH(elem, name, extra);

                    } else {
                        jQuery.swap(elem, cssShow, function () {
                            val = getWH(elem, name, extra);
                        });
                    }

                    return val + "px";
                }
            },

            set: function (elem, value) {
                if (rnumpx.test(value)) {
                    // ignore negative width and height values #1599
                    value = parseFloat(value);

                    if (value >= 0) {
                        return value + "px";
                    }

                } else {
                    return value;
                }
            }
        };
    });

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
                    (parseFloat(RegExp.$1) / 100) + "" :
                    computed ? "1" : "";
            },

            set: function (elem, value) {
                var style = elem.style;

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // Set the alpha filter to set the opacity
                var opacity = jQuery.isNaN(value) ?
                    "" :
                    "alpha(opacity=" + value * 100 + ")",
                    filter = style.filter || "";

                style.filter = ralpha.test(filter) ?
                    filter.replace(ralpha, opacity) :
                    style.filter + ' ' + opacity;
            }
        };
    }

    if (getComputedStyle) {
        curCSS = function (elem, newName, name) {
            var ret, defaultView, computedStyle;

            name = name.replace(rupper, "-$1").toLowerCase();

            if (!(defaultView = elem.ownerDocument.defaultView)) {
                return undefined;
            }

            if ((computedStyle = defaultView.getComputedStyle(elem, null))) {
                ret = computedStyle.getPropertyValue(name);
                if (ret === "" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {
                    ret = jQuery.style(elem, name);
                }
            }

            return ret;
        };

    } else if (document.documentElement.currentStyle) {
        curCSS = function (elem, name) {
            var left, rsLeft, ret = elem.currentStyle && elem.currentStyle[name], style = elem.style;

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if (!rnumpx.test(ret) && rnum.test(ret)) {
                // Remember the original values
                left = style.left;
                rsLeft = elem.runtimeStyle.left;

                // Put in the new values to get a computed value out
                elem.runtimeStyle.left = elem.currentStyle.left;
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                elem.runtimeStyle.left = rsLeft;
            }

            return ret;
        };
    }

    function getWH(elem, name, extra) {
        var which = name === "width" ? cssWidth : cssHeight,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight;

        if (extra === "border") {
            return val;
        }

        jQuery.each(which, function () {
            if (!extra) {
                val -= parseFloat(jQuery.css(elem, "padding" + this)) || 0;
            }

            if (extra === "margin") {
                val += parseFloat(jQuery.css(elem, "margin" + this)) || 0;

            } else {
                val -= parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
            }
        });

        return val;
    }

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function (elem) {
            var width = elem.offsetWidth, height = elem.offsetHeight;

            return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css(elem, "display")) === "none");
        };

        jQuery.expr.filters.visible = function (elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }




    var jsc = jQuery.now(),
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rselectTextarea = /^(?:select|textarea)/i,
        rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
        rnoContent = /^(?:GET|HEAD|DELETE)$/,
        rbracket = /\[\]$/,
        jsre = /\=\?(&|$)/,
        rquery = /\?/,
        rts = /([?&])_=[^&]*/,
        rurl = /^(\w+:)?\/\/([^\/?#]+)/,
        r20 = /%20/g,
        rhash = /#.*$/,

        // Keep a copy of the old load method
        _load = jQuery.fn.load;

    jQuery.fn.extend({
        load: function (url, params, callback) {
            if (typeof url !== "string" && _load) {
                return _load.apply(this, arguments);

                // Don't do a request if no elements are being requested
            } else if (!this.length) {
                return this;
            }

            var off = url.indexOf(" ");
            if (off >= 0) {
                var selector = url.slice(off, url.length);
                url = url.slice(0, off);
            }

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if (params) {
                // If it's a function
                if (jQuery.isFunction(params)) {
                    // We assume that it's the callback
                    callback = params;
                    params = null;

                    // Otherwise, build a param string
                } else if (typeof params === "object") {
                    params = jQuery.param(params, jQuery.ajaxSettings.traditional);
                    type = "POST";
                }
            }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params,
                complete: function (res, status) {
                    // If successful, inject the HTML into all the matched elements
                    if (status === "success" || status === "notmodified") {
                        // See if a selector was specified
                        self.html(selector ?
                            // Create a dummy div to hold the results
                            jQuery("<div>")
                                // inject the contents of the document in, removing the scripts
                                // to avoid any 'Permission Denied' errors in IE
                                .append(res.responseText.replace(rscript, ""))

                                // Locate the specified elements
                                .find(selector) :

                            // If not, just inject the full result
                            res.responseText);
                    }

                    if (callback) {
                        self.each(callback, [res.responseText, status, res]);
                    }
                }
            });

            return this;
        },

        serialize: function () {
            return jQuery.param(this.serializeArray());
        },

        serializeArray: function () {
            return this.map(function () {
                return this.elements ? jQuery.makeArray(this.elements) : this;
            })
                .filter(function () {
                    return this.name && !this.disabled &&
                        (this.checked || rselectTextarea.test(this.nodeName) ||
                            rinput.test(this.type));
                })
                .map(function (i, elem) {
                    var val = jQuery(this).val();

                    return val == null ?
                        null :
                        jQuery.isArray(val) ?
                            jQuery.map(val, function (val, i) {
                                return { name: elem.name, value: val };
                            }) :
                            { name: elem.name, value: val };
                }).get();
        }
    });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function (i, o) {
        jQuery.fn[o] = function (f) {
            return this.bind(o, f);
        };
    });

    jQuery.extend({
        get: function (url, data, callback, type) {
            // shift arguments if data argument was omited
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = null;
            }

            return jQuery.ajax({
                type: "GET",
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        },

        getScript: function (url, callback) {
            return jQuery.get(url, null, callback, "script");
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        post: function (url, data, callback, type) {
            // shift arguments if data argument was omited
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = {};
            }

            return jQuery.ajax({
                type: "POST",
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        },

        ajaxSetup: function (settings) {
            jQuery.extend(jQuery.ajaxSettings, settings);
        },

        ajaxSettings: {
            url: location.href,
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            username: null,
            password: null,
            traditional: false,
            */
            // This function can be overriden by calling jQuery.ajaxSetup
            xhr: function () {
                return new window.XMLHttpRequest();
            },
            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                script: "text/javascript, application/javascript",
                json: "application/json, text/javascript",
                text: "text/plain",
                _default: "*/*"
            }
        },

        ajax: function (origSettings) {
            var s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings),
                jsonp, status, data, type = s.type.toUpperCase(), noContent = rnoContent.test(type);

            s.url = s.url.replace(rhash, "");

            // Use original (not extended) context object if it was provided
            s.context = origSettings && origSettings.context != null ? origSettings.context : s;

            // convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Handle JSONP Parameter Callbacks
            if (s.dataType === "jsonp") {
                if (type === "GET") {
                    if (!jsre.test(s.url)) {
                        s.url += (rquery.test(s.url) ? "&" : "?") + (s.jsonp || "callback") + "=?";
                    }
                } else if (!s.data || !jsre.test(s.data)) {
                    s.data = (s.data ? s.data + "&" : "") + (s.jsonp || "callback") + "=?";
                }
                s.dataType = "json";
            }

            // Build temporary JSONP function
            if (s.dataType === "json" && (s.data && jsre.test(s.data) || jsre.test(s.url))) {
                jsonp = s.jsonpCallback || ("jsonp" + jsc++);

                // Replace the =? sequence both in the query string and the data
                if (s.data) {
                    s.data = (s.data + "").replace(jsre, "=" + jsonp + "$1");
                }

                s.url = s.url.replace(jsre, "=" + jsonp + "$1");

                // We need to make sure
                // that a JSONP style response is executed properly
                s.dataType = "script";

                // Handle JSONP-style loading
                var customJsonp = window[jsonp];

                window[jsonp] = function (tmp) {
                    data = tmp;
                    jQuery.handleSuccess(s, xhr, status, data);
                    jQuery.handleComplete(s, xhr, status, data);

                    if (jQuery.isFunction(customJsonp)) {
                        customJsonp(tmp);

                    } else {
                        // Garbage collect
                        window[jsonp] = undefined;

                        try {
                            delete window[jsonp];
                        } catch (jsonpError) { }
                    }

                    if (head) {
                        head.removeChild(script);
                    }
                };
            }

            if (s.dataType === "script" && s.cache === null) {
                s.cache = false;
            }

            if (s.cache === false && type === "GET") {
                var ts = jQuery.now();

                // try replacing _= if it is there
                var ret = s.url.replace(rts, "$1_=" + ts);

                // if nothing was replaced, add timestamp to the end
                s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
            }

            // If data is available, append data to url for get requests
            if (s.data && type === "GET") {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
            }

            // Watch for a new set of requests
            if (s.global && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Matches an absolute URL, and saves the domain
            var parts = rurl.exec(s.url),
                remote = parts && (parts[1] && parts[1] !== location.protocol || parts[2] !== location.host);

            // If we're requesting a remote document
            // and trying to load JSON or Script with a GET
            if (s.dataType === "script" && type === "GET" && remote) {
                var head = document.getElementsByTagName("head")[0] || document.documentElement;
                var script = document.createElement("script");
                if (s.scriptCharset) {
                    script.charset = s.scriptCharset;
                }
                script.src = s.url;

                // Handle Script loading
                if (!jsonp) {
                    var done = false;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function () {
                        if (!done && (!this.readyState ||
                            this.readyState === "loaded" || this.readyState === "complete")) {
                            done = true;
                            jQuery.handleSuccess(s, xhr, status, data);
                            jQuery.handleComplete(s, xhr, status, data);

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }
                        }
                    };
                }

                // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                // This arises when a base node is used (#2709 and #4378).
                head.insertBefore(script, head.firstChild);

                // We handle everything using the script element injection
                return undefined;
            }

            var requestDone = false;

            // Create the request object
            var xhr = s.xhr();

            if (!xhr) {
                return;
            }

            // Open the socket
            // Passing null username, generates a login popup on Opera (#2865)
            if (s.username) {
                xhr.open(type, s.url, s.async, s.username, s.password);
            } else {
                xhr.open(type, s.url, s.async);
            }

            // Need an extra try/catch for cross domain requests in Firefox 3
            try {
                // Set content-type if data specified and content-body is valid for this type
                if ((s.data != null && !noContent) || (origSettings && origSettings.contentType)) {
                    xhr.setRequestHeader("Content-Type", s.contentType);
                }

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if (s.ifModified) {
                    if (jQuery.lastModified[s.url]) {
                        xhr.setRequestHeader("If-Modified-Since", jQuery.lastModified[s.url]);
                    }

                    if (jQuery.etag[s.url]) {
                        xhr.setRequestHeader("If-None-Match", jQuery.etag[s.url]);
                    }
                }

                // Set header so the called script knows that it's an XMLHttpRequest
                // Only send the header if it's not a remote XHR
                if (!remote) {
                    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                }

                // Set the Accepts header for the server, depending on the dataType
                xhr.setRequestHeader("Accept", s.dataType && s.accepts[s.dataType] ?
                    s.accepts[s.dataType] + ", */*; q=0.01" :
                    s.accepts._default);
            } catch (headerError) { }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
                // Handle the global AJAX counter
                if (s.global && jQuery.active-- === 1) {
                    jQuery.event.trigger("ajaxStop");
                }

                // close opended socket
                xhr.abort();
                return false;
            }

            if (s.global) {
                jQuery.triggerGlobal(s, "ajaxSend", [xhr, s]);
            }

            // Wait for a response to come back
            var onreadystatechange = xhr.onreadystatechange = function (isTimeout) {
                // The request was aborted
                if (!xhr || xhr.readyState === 0 || isTimeout === "abort") {
                    // Opera doesn't call onreadystatechange before this point
                    // so we simulate the call
                    if (!requestDone) {
                        jQuery.handleComplete(s, xhr, status, data);
                    }

                    requestDone = true;
                    if (xhr) {
                        xhr.onreadystatechange = jQuery.noop;
                    }

                    // The transfer is complete and the data is available, or the request timed out
                } else if (!requestDone && xhr && (xhr.readyState === 4 || isTimeout === "timeout")) {
                    requestDone = true;
                    xhr.onreadystatechange = jQuery.noop;

                    status = isTimeout === "timeout" ?
                        "timeout" :
                        !jQuery.httpSuccess(xhr) ?
                            "error" :
                            s.ifModified && jQuery.httpNotModified(xhr, s.url) ?
                                "notmodified" :
                                "success";

                    var errMsg;

                    if (status === "success") {
                        // Watch for, and catch, XML document parse errors
                        try {
                            // process the data (runs the xml through httpData regardless of callback)
                            data = jQuery.httpData(xhr, s.dataType, s);
                        } catch (parserError) {
                            status = "parsererror";
                            errMsg = parserError;
                        }
                    }

                    // Make sure that the request was successful or notmodified
                    if (status === "success" || status === "notmodified") {
                        // JSONP handles its own success callback
                        if (!jsonp) {
                            jQuery.handleSuccess(s, xhr, status, data);
                        }
                    } else {
                        jQuery.handleError(s, xhr, status, errMsg);
                    }

                    // Fire the complete handlers
                    if (!jsonp) {
                        jQuery.handleComplete(s, xhr, status, data);
                    }

                    if (isTimeout === "timeout") {
                        xhr.abort();
                    }

                    // Stop memory leaks
                    if (s.async) {
                        xhr = null;
                    }
                }
            };

            // Override the abort handler, if we can (IE 6 doesn't allow it, but that's OK)
            // Opera doesn't fire onreadystatechange at all on abort
            try {
                var oldAbort = xhr.abort;
                xhr.abort = function () {
                    // xhr.abort in IE7 is not a native JS function
                    // and does not have a call property
                    if (xhr && oldAbort.call) {
                        oldAbort.call(xhr);
                    }

                    onreadystatechange("abort");
                };
            } catch (abortError) { }

            // Timeout checker
            if (s.async && s.timeout > 0) {
                setTimeout(function () {
                    // Check to see if the request is still happening
                    if (xhr && !requestDone) {
                        onreadystatechange("timeout");
                    }
                }, s.timeout);
            }

            // Send the data
            try {
                xhr.send(noContent || s.data == null ? null : s.data);

            } catch (sendError) {
                jQuery.handleError(s, xhr, null, sendError);

                // Fire the complete handlers
                jQuery.handleComplete(s, xhr, status, data);
            }

            // firefox 1.5 doesn't fire statechange for sync requests
            if (!s.async) {
                onreadystatechange();
            }

            // return XMLHttpRequest to allow aborting the request etc.
            return xhr;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param: function (a, traditional) {
            var s = [], add = function (key, value) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction(value) ? value() : value;
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };

            // Set traditional to true for jQuery <= 1.3.2 behavior.
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings.traditional;
            }

            // If an array was passed in, assume that it is an array of form elements.
            if (jQuery.isArray(a) || a.jquery) {
                // Serialize the form elements
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });

            } else {
                // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (var prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }

            // Return the resulting serialization
            return s.join("&").replace(r20, "+");
        }
    });

    function buildParams(prefix, obj, traditional, add) {
        if (jQuery.isArray(obj) && obj.length) {
            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams(prefix + "[" + (typeof v === "object" || jQuery.isArray(v) ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && obj != null && typeof obj === "object") {
            if (jQuery.isEmptyObject(obj)) {
                add(prefix, "");

                // Serialize object item.
            } else {
                jQuery.each(obj, function (k, v) {
                    buildParams(prefix + "[" + k + "]", v, traditional, add);
                });
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        handleError: function (s, xhr, status, e) {
            // If a local callback was specified, fire it
            if (s.error) {
                s.error.call(s.context, xhr, status, e);
            }

            // Fire the global callback
            if (s.global) {
                jQuery.triggerGlobal(s, "ajaxError", [xhr, s, e]);
            }
        },

        handleSuccess: function (s, xhr, status, data) {
            // If a local callback was specified, fire it and pass it the data
            if (s.success) {
                s.success.call(s.context, data, status, xhr);
            }

            // Fire the global callback
            if (s.global) {
                jQuery.triggerGlobal(s, "ajaxSuccess", [xhr, s]);
            }
        },

        handleComplete: function (s, xhr, status) {
            // Process result
            if (s.complete) {
                s.complete.call(s.context, xhr, status);
            }

            // The request was completed
            if (s.global) {
                jQuery.triggerGlobal(s, "ajaxComplete", [xhr, s]);
            }

            // Handle the global AJAX counter
            if (s.global && jQuery.active-- === 1) {
                jQuery.event.trigger("ajaxStop");
            }
        },

        triggerGlobal: function (s, type, args) {
            (s.context && s.context.url == null ? jQuery(s.context) : jQuery.event).trigger(type, args);
        },

        // Determines if an XMLHttpRequest was successful or not
        httpSuccess: function (xhr) {
            try {
                // IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450
                return !xhr.status && location.protocol === "file:" ||
                    xhr.status >= 200 && xhr.status < 300 ||
                    xhr.status === 304 || xhr.status === 1223;
            } catch (e) { }

            return false;
        },

        // Determines if an XMLHttpRequest returns NotModified
        httpNotModified: function (xhr, url) {
            var lastModified = xhr.getResponseHeader("Last-Modified"),
                etag = xhr.getResponseHeader("Etag");

            if (lastModified) {
                jQuery.lastModified[url] = lastModified;
            }

            if (etag) {
                jQuery.etag[url] = etag;
            }

            return xhr.status === 304;
        },

        httpData: function (xhr, type, s) {
            var ct = xhr.getResponseHeader("content-type") || "",
                xml = type === "xml" || !type && ct.indexOf("xml") >= 0,
                data = xml ? xhr.responseXML : xhr.responseText;

            if (xml && data.documentElement.nodeName === "parsererror") {
                jQuery.error("parsererror");
            }

            // Allow a pre-filtering function to sanitize the response
            // s is checked to keep backwards compatibility
            if (s && s.dataFilter) {
                data = s.dataFilter(data, type);
            }

            // The filter can actually parse the response
            if (typeof data === "string") {
                // Get the JavaScript object, if JSON is used.
                if (type === "json" || !type && ct.indexOf("json") >= 0) {
                    data = jQuery.parseJSON(data);

                    // If the type is "script", eval it in global context
                } else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
                    jQuery.globalEval(data);
                }
            }

            return data;
        }

    });

    /*
     * Create the request object; Microsoft failed to properly
     * implement the XMLHttpRequest in IE7 (can't request local files),
     * so we use the ActiveXObject when it is available
     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
     * we need a fallback.
     */
    if (window.ActiveXObject) {
        jQuery.ajaxSettings.xhr = function () {
            if (window.location.protocol !== "file:") {
                try {
                    return new window.XMLHttpRequest();
                } catch (xhrError) { }
            }

            try {
                return new window.ActiveXObject("Microsoft.XMLHTTP");
            } catch (activeError) { }
        };
    }

    // Does this browser support XHR requests?
    jQuery.support.ajax = !!jQuery.ajaxSettings.xhr();




    var elemdisplay = {},
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = /^([+\-]=)?([\d+.\-]+)(.*)$/,
        timerId,
        fxAttrs = [
            // height animations
            ["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
            // width animations
            ["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
            // opacity animations
            ["opacity"]
        ];

    jQuery.fn.extend({
        show: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("show", 3), speed, easing, callback);
            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    // Reset the inline display of this element to learn if it is
                    // being hidden by cascaded rules or not
                    if (!jQuery.data(this[i], "olddisplay") && this[i].style.display === "none") {
                        this[i].style.display = "";
                    }

                    // Set elements which have been overridden with display: none
                    // in a stylesheet to whatever the default browser style is
                    // for such an element
                    if (this[i].style.display === "" && jQuery.css(this[i], "display") === "none") {
                        jQuery.data(this[i], "olddisplay", defaultDisplay(this[i].nodeName));
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    this[i].style.display = jQuery.data(this[i], "olddisplay") || "";
                }

                return this;
            }
        },

        hide: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("hide", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    var display = jQuery.css(this[i], "display");

                    if (display !== "none") {
                        jQuery.data(this[i], "olddisplay", display);
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    this[i].style.display = "none";
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: function (fn, fn2, callback) {
            var bool = typeof fn === "boolean";

            if (jQuery.isFunction(fn) && jQuery.isFunction(fn2)) {
                this._toggle.apply(this, arguments);

            } else if (fn == null || bool) {
                this.each(function () {
                    var state = bool ? fn : jQuery(this).is(":hidden");
                    jQuery(this)[state ? "show" : "hide"]();
                });

            } else {
                this.animate(genFx("toggle", 3), fn, fn2, callback);
            }

            return this;
        },

        fadeTo: function (speed, to, easing, callback) {
            return this.filter(":hidden").css("opacity", 0).show().end()
                .animate({ opacity: to }, speed, easing, callback);
        },

        animate: function (prop, speed, easing, callback) {
            var optall = jQuery.speed(speed, easing, callback);

            if (jQuery.isEmptyObject(prop)) {
                return this.each(optall.complete);
            }

            return this[optall.queue === false ? "each" : "queue"](function () {
                // XXX this does not always have a nodeName when running the
                // test suite

                var opt = jQuery.extend({}, optall), p,
                    isElement = this.nodeType === 1,
                    hidden = isElement && jQuery(this).is(":hidden"),
                    self = this;

                for (p in prop) {
                    var name = jQuery.camelCase(p);

                    if (p !== name) {
                        prop[name] = prop[p];
                        delete prop[p];
                        p = name;
                    }

                    if (prop[p] === "hide" && hidden || prop[p] === "show" && !hidden) {
                        return opt.complete.call(this);
                    }

                    if (isElement && (p === "height" || p === "width")) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height
                        // animated
                        if (jQuery.css(this, "display") === "inline" &&
                            jQuery.css(this, "float") === "none") {
                            if (!jQuery.support.inlineBlockNeedsLayout) {
                                this.style.display = "inline-block";

                            } else {
                                var display = defaultDisplay(this.nodeName);

                                // inline-level elements accept inline-block;
                                // block-level elements need to be inline with layout
                                if (display === "inline") {
                                    this.style.display = "inline-block";

                                } else {
                                    this.style.display = "inline";
                                    this.style.zoom = 1;
                                }
                            }
                        }
                    }

                    if (jQuery.isArray(prop[p])) {
                        // Create (if needed) and add to specialEasing
                        (opt.specialEasing = opt.specialEasing || {})[p] = prop[p][1];
                        prop[p] = prop[p][0];
                    }
                }

                if (opt.overflow != null) {
                    this.style.overflow = "hidden";
                }

                opt.curAnim = jQuery.extend({}, prop);

                jQuery.each(prop, function (name, val) {
                    var e = new jQuery.fx(self, opt, name);

                    if (rfxtypes.test(val)) {
                        e[val === "toggle" ? hidden ? "show" : "hide" : val](prop);

                    } else {
                        var parts = rfxnum.exec(val),
                            start = e.cur(true) || 0;

                        if (parts) {
                            var end = parseFloat(parts[2]),
                                unit = parts[3] || "px";

                            // We need to compute starting value
                            if (unit !== "px") {
                                jQuery.style(self, name, (end || 1) + unit);
                                start = ((end || 1) / e.cur(true)) * start;
                                jQuery.style(self, name, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if (parts[1]) {
                                end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                            }

                            e.custom(start, end, unit);

                        } else {
                            e.custom(start, val, "");
                        }
                    }
                });

                // For JS strict compliance
                return true;
            });
        },

        stop: function (clearQueue, gotoEnd) {
            var timers = jQuery.timers;

            if (clearQueue) {
                this.queue([]);
            }

            this.each(function () {
                // go in reverse order so anything added to the queue during the loop is ignored
                for (var i = timers.length - 1; i >= 0; i--) {
                    if (timers[i].elem === this) {
                        if (gotoEnd) {
                            // force the next step to be the last
                            timers[i](true);
                        }

                        timers.splice(i, 1);
                    }
                }
            });

            // start the next in the queue if the last step wasn't forced
            if (!gotoEnd) {
                this.dequeue();
            }

            return this;
        }

    });

    function genFx(type, num) {
        var obj = {};

        jQuery.each(fxAttrs.concat.apply([], fxAttrs.slice(0, num)), function () {
            obj[this] = type;
        });

        return obj;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show", 1),
        slideUp: genFx("hide", 1),
        slideToggle: genFx("toggle", 1),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.extend({
        speed: function (speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing ||
                    jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

            // Queueing
            opt.old = opt.complete;
            opt.complete = function () {
                if (opt.queue !== false) {
                    jQuery(this).dequeue();
                }
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }
            };

            return opt;
        },

        easing: {
            linear: function (p, n, firstNum, diff) {
                return firstNum + diff * p;
            },
            swing: function (p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
            }
        },

        timers: [],

        fx: function (elem, options, prop) {
            this.options = options;
            this.elem = elem;
            this.prop = prop;

            if (!options.orig) {
                options.orig = {};
            }
        }

    });

    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: function () {
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            (jQuery.fx.step[this.prop] || jQuery.fx.step._default)(this);
        },

        // Get the current size
        cur: function () {
            if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {
                return this.elem[this.prop];
            }

            var r = parseFloat(jQuery.css(this.elem, this.prop));
            return r && r > -10000 ? r : 0;
        },

        // Start an animation from one number to another
        custom: function (from, to, unit) {
            this.startTime = jQuery.now();
            this.start = from;
            this.end = to;
            this.unit = unit || this.unit || "px";
            this.now = this.start;
            this.pos = this.state = 0;

            var self = this, fx = jQuery.fx;
            function t(gotoEnd) {
                return self.step(gotoEnd);
            }

            t.elem = this.elem;

            if (t() && jQuery.timers.push(t) && !timerId) {
                timerId = setInterval(fx.tick, fx.interval);
            }
        },

        // Simple 'show' function
        show: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.show = true;

            // Begin the animation
            // Make sure that we start at a small width/height to avoid any
            // flash of content
            this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

            // Start by showing the element
            jQuery(this.elem).show();
        },

        // Simple 'hide' function
        hide: function () {
            // Remember where we started, so that we can go back to it later
            this.options.orig[this.prop] = jQuery.style(this.elem, this.prop);
            this.options.hide = true;

            // Begin the animation
            this.custom(this.cur(), 0);
        },

        // Each step of an animation
        step: function (gotoEnd) {
            var t = jQuery.now(), done = true;

            if (gotoEnd || t >= this.options.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                this.options.curAnim[this.prop] = true;

                for (var i in this.options.curAnim) {
                    if (this.options.curAnim[i] !== true) {
                        done = false;
                    }
                }

                if (done) {
                    // Reset the overflow
                    if (this.options.overflow != null && !jQuery.support.shrinkWrapBlocks) {
                        var elem = this.elem, options = this.options;
                        jQuery.each(["", "X", "Y"], function (index, value) {
                            elem.style["overflow" + value] = options.overflow[index];
                        });
                    }

                    // Hide the element if the "hide" operation was done
                    if (this.options.hide) {
                        jQuery(this.elem).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if (this.options.hide || this.options.show) {
                        for (var p in this.options.curAnim) {
                            jQuery.style(this.elem, p, this.options.orig[p]);
                        }
                    }

                    // Execute the complete function
                    this.options.complete.call(this.elem);
                }

                return false;

            } else {
                var n = t - this.startTime;
                this.state = n / this.options.duration;

                // Perform the easing function, defaults to swing
                var specialEasing = this.options.specialEasing && this.options.specialEasing[this.prop];
                var defaultEasing = this.options.easing || (jQuery.easing.swing ? "swing" : "linear");
                this.pos = jQuery.easing[specialEasing || defaultEasing](this.state, n, 0, 1, this.options.duration);
                this.now = this.start + ((this.end - this.start) * this.pos);

                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend(jQuery.fx, {
        tick: function () {
            var timers = jQuery.timers;

            for (var i = 0; i < timers.length; i++) {
                if (!timers[i]()) {
                    timers.splice(i--, 1);
                }
            }

            if (!timers.length) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: function () {
            clearInterval(timerId);
            timerId = null;
        },

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: function (fx) {
                jQuery.style(fx.elem, "opacity", fx.now);
            },

            _default: function (fx) {
                if (fx.elem.style && fx.elem.style[fx.prop] != null) {
                    fx.elem.style[fx.prop] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
                } else {
                    fx.elem[fx.prop] = fx.now;
                }
            }
        }
    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
            }).length;
        };
    }

    function defaultDisplay(nodeName) {
        if (!elemdisplay[nodeName]) {
            var elem = jQuery("<" + nodeName + ">").appendTo("body"),
                display = elem.css("display");

            elem.remove();

            if (display === "none" || display === "") {
                display = "block";
            }

            elemdisplay[nodeName] = display;
        }

        return elemdisplay[nodeName];
    }




    var rtable = /^t(?:able|d|h)$/i,
        rroot = /^(?:body|html)$/i;

    if ("getBoundingClientRect" in document.documentElement) {
        jQuery.fn.offset = function (options) {
            var elem = this[0], box;

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            try {
                box = elem.getBoundingClientRect();
            } catch (e) { }

            var doc = elem.ownerDocument,
                docElem = doc.documentElement;

            // Make sure we're not dealing with a disconnected DOM node
            if (!box || !jQuery.contains(docElem, elem)) {
                return box || { top: 0, left: 0 };
            }

            var body = doc.body,
                win = getWindow(doc),
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                scrollTop = (win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop),
                scrollLeft = (win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft),
                top = box.top + scrollTop - clientTop,
                left = box.left + scrollLeft - clientLeft;

            return { top: top, left: left };
        };

    } else {
        jQuery.fn.offset = function (options) {
            var elem = this[0];

            if (options) {
                return this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            if (!elem || !elem.ownerDocument) {
                return null;
            }

            if (elem === elem.ownerDocument.body) {
                return jQuery.offset.bodyOffset(elem);
            }

            jQuery.offset.initialize();

            var offsetParent = elem.offsetParent, prevOffsetParent = elem,
                doc = elem.ownerDocument, computedStyle, docElem = doc.documentElement,
                body = doc.body, defaultView = doc.defaultView,
                prevComputedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle,
                top = elem.offsetTop, left = elem.offsetLeft;

            while ((elem = elem.parentNode) && elem !== body && elem !== docElem) {
                if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                    break;
                }

                computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                top -= elem.scrollTop;
                left -= elem.scrollLeft;

                if (elem === offsetParent) {
                    top += elem.offsetTop;
                    left += elem.offsetLeft;

                    if (jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName))) {
                        top += parseFloat(computedStyle.borderTopWidth) || 0;
                        left += parseFloat(computedStyle.borderLeftWidth) || 0;
                    }

                    prevOffsetParent = offsetParent;
                    offsetParent = elem.offsetParent;
                }

                if (jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible") {
                    top += parseFloat(computedStyle.borderTopWidth) || 0;
                    left += parseFloat(computedStyle.borderLeftWidth) || 0;
                }

                prevComputedStyle = computedStyle;
            }

            if (prevComputedStyle.position === "relative" || prevComputedStyle.position === "static") {
                top += body.offsetTop;
                left += body.offsetLeft;
            }

            if (jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed") {
                top += Math.max(docElem.scrollTop, body.scrollTop);
                left += Math.max(docElem.scrollLeft, body.scrollLeft);
            }

            return { top: top, left: left };
        };
    }

    jQuery.offset = {
        initialize: function () {
            var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat(jQuery.css(body, "marginTop")) || 0,
                html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

            jQuery.extend(container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" });

            container.innerHTML = html;
            body.insertBefore(container, body.firstChild);
            innerDiv = container.firstChild;
            checkDiv = innerDiv.firstChild;
            td = innerDiv.nextSibling.firstChild.firstChild;

            this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
            this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

            checkDiv.style.position = "fixed";
            checkDiv.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
            checkDiv.style.position = checkDiv.style.top = "";

            innerDiv.style.overflow = "hidden";
            innerDiv.style.position = "relative";

            this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

            this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

            body.removeChild(container);
            body = container = innerDiv = checkDiv = table = td = null;
            jQuery.offset.initialize = jQuery.noop;
        },

        bodyOffset: function (body) {
            var top = body.offsetTop, left = body.offsetLeft;

            jQuery.offset.initialize();

            if (jQuery.offset.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function (elem, options, i) {
            var position = jQuery.css(elem, "position");

            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            var curElem = jQuery(elem),
                curOffset = curElem.offset(),
                curCSSTop = jQuery.css(elem, "top"),
                curCSSLeft = jQuery.css(elem, "left"),
                calculatePosition = (position === "absolute" && jQuery.inArray('auto', [curCSSTop, curCSSLeft]) > -1),
                props = {}, curPosition = {}, curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is absolute
            if (calculatePosition) {
                curPosition = curElem.position();
            }

            curTop = calculatePosition ? curPosition.top : parseInt(curCSSTop, 10) || 0;
            curLeft = calculatePosition ? curPosition.left : parseInt(curCSSLeft, 10) || 0;

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };


    jQuery.fn.extend({
        position: function () {
            if (!this[0]) {
                return null;
            }

            var elem = this[0],

                // Get *real* offsetParent
                offsetParent = this.offsetParent(),

                // Get correct offsets
                offset = this.offset(),
                parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

            // Add offsetParent borders
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

            // Subtract the two offsets
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each(["Left", "Top"], function (i, name) {
        var method = "scroll" + name;

        jQuery.fn[method] = function (val) {
            var elem = this[0], win;

            if (!elem) {
                return null;
            }

            if (val !== undefined) {
                // Set the scroll offset
                return this.each(function () {
                    win = getWindow(this);

                    if (win) {
                        win.scrollTo(
                            !i ? val : jQuery(win).scrollLeft(),
                            i ? val : jQuery(win).scrollTop()
                        );

                    } else {
                        this[method] = val;
                    }
                });
            } else {
                win = getWindow(elem);

                // Return the scroll offset
                return win ? ("pageXOffset" in win) ? win[i ? "pageYOffset" : "pageXOffset"] :
                    jQuery.support.boxModel && win.document.documentElement[method] ||
                    win.document.body[method] :
                    elem[method];
            }
        };
    });

    function getWindow(elem) {
        return jQuery.isWindow(elem) ?
            elem :
            elem.nodeType === 9 ?
                elem.defaultView || elem.parentWindow :
                false;
    }




    // Create innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each(["Height", "Width"], function (i, name) {

        var type = name.toLowerCase();

        // innerHeight and innerWidth
        jQuery.fn["inner" + name] = function () {
            return this[0] ?
                parseFloat(jQuery.css(this[0], type, "padding")) :
                null;
        };

        // outerHeight and outerWidth
        jQuery.fn["outer" + name] = function (margin) {
            return this[0] ?
                parseFloat(jQuery.css(this[0], type, margin ? "margin" : "border")) :
                null;
        };

        jQuery.fn[type] = function (size) {
            // Get window width or height
            var elem = this[0];
            if (!elem) {
                return size == null ? null : this;
            }

            if (jQuery.isFunction(size)) {
                return this.each(function (i) {
                    var self = jQuery(this);
                    self[type](size.call(this, i, self[type]()));
                });
            }

            return jQuery.isWindow(elem) ?
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                elem.document.compatMode === "CSS1Compat" && elem.document.documentElement["client" + name] ||
                elem.document.body["client" + name] :

                // Get document width or height
                (elem.nodeType === 9) ? // is it a document
                    // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                    Math.max(
                        elem.documentElement["client" + name],
                        elem.body["scroll" + name], elem.documentElement["scroll" + name],
                        elem.body["offset" + name], elem.documentElement["offset" + name]
                    ) :

                    // Get or set width or height on the element
                    size === undefined ?
                        // Get width or height on the element
                        parseFloat(jQuery.css(elem, type)) :

                        // Set the width or height on the element (default to pixels if value is unitless)
                        this.css(type, typeof size === "string" ? size : size + "px");
        };

    });


})(window);


(function () {

    window.jQuerySG = jQuery.noConflict(true);

}).call(this);

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/postcss-loader/src/index.js?!./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css":
/*!*********************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/postcss-loader/src??ref--2-2!./node_modules/@spider-rulegen/vendor/selectorgadget/css/selectorgadget.css ***!
  \*********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/* line 1, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main {\n    azimuth: center !important;\n    background-attachment: scroll !important;\n    background-image: none !important;\n    background-position: 0% 0% !important;\n    background-repeat: repeat !important;\n    border-collapse: separate !important;\n    border-spacing: 0 !important;\n    bottom: auto !important;\n    caption-side: top !important;\n    clear: none !important;\n    clip: auto !important;\n    color: black !important;\n    content: normal !important;\n    counter-increment: none !important;\n    counter-reset: none !important;\n    cursor: auto !important;\n    direction: ltr !important;\n    elevation: level !important;\n    empty-cells: show !important;\n    font-family: sans-serif !important;\n    font-variant: normal !important;\n    font-weight: normal !important;\n    height: auto !important;\n    left: auto !important;\n    letter-spacing: normal !important;\n    line-height: normal !important;\n    list-style-image: none !important;\n    list-style-position: outside !important;\n    list-style-type: disc !important;\n    max-height: none !important;\n    max-width: none !important;\n    min-height: 0 !important;\n    min-width: 0 !important;\n    orphans: 2 !important;\n    outline-color: invert !important;\n    outline-style: none !important;\n    outline-width: medium !important;\n    overflow: visible !important;\n    page-break-after: auto !important;\n    page-break-before: auto !important;\n    page-break-inside: auto !important;\n    table-layout: auto !important;\n    text-align: left !important;\n    text-decoration: none !important;\n    text-indent: 0 !important;\n    text-transform: none !important;\n    top: auto !important;\n    unicode-bidi: normal !important;\n    vertical-align: baseline !important;\n    visibility: visible !important;\n    white-space: normal !important;\n    widows: 2 !important;\n    width: auto !important;\n    word-spacing: normal !important;\n    position: fixed !important;\n    z-index: 9999999 !important;\n    display: block !important;\n    right: 5px !important;\n    margin: 5px !important;\n    padding: 5px !important;\n    font-size: 14px !important;\n    float: none !important;\n    border: 1px solid black !important;\n    font-style: none !important;\n    background: white !important;\n    text-align: left !important;\n}\n\n\n/* line 71, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main *,\n.selectorgadget_clean,\n.selectorgadget_clean * {\n    azimuth: center;\n    background-attachment: scroll;\n    background-image: none;\n    background-position: 0% 0%;\n    background-repeat: repeat;\n    border-collapse: separate;\n    border-spacing: 0;\n    bottom: auto;\n    caption-side: top;\n    clear: none;\n    clip: auto;\n    color: black;\n    content: normal;\n    counter-increment: none;\n    counter-reset: none;\n    cursor: auto;\n    direction: ltr;\n    elevation: level;\n    empty-cells: show;\n    font-family: sans-serif;\n    font-variant: normal;\n    font-weight: normal;\n    height: auto;\n    left: auto;\n    letter-spacing: normal;\n    line-height: normal;\n    list-style-image: none;\n    list-style-position: outside;\n    list-style-type: disc;\n    max-height: none;\n    max-width: none;\n    min-height: 0;\n    min-width: 0;\n    orphans: 2;\n    outline-color: invert;\n    outline-style: none;\n    outline-width: medium;\n    overflow: visible;\n    page-break-after: auto;\n    page-break-before: auto;\n    page-break-inside: auto;\n    table-layout: auto;\n    text-align: left;\n    text-decoration: none;\n    text-indent: 0;\n    text-transform: none;\n    top: auto;\n    unicode-bidi: normal;\n    vertical-align: baseline;\n    visibility: visible;\n    white-space: normal;\n    widows: 2;\n    width: auto;\n    word-spacing: normal;\n    right: 0px;\n    margin: 0;\n    padding: 0;\n    font-size: 14px;\n    float: none;\n    font-style: none;\n    background: white;\n    text-align: left;\n}\n\n\n/* line 136, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_clean a {\n    color: blue;\n    text-decoration: underline;\n    cursor: pointer;\n}\n\n\n/* line 142, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main .selectorgadget_input_field {\n    display: block;\n    float: left;\n    margin: 0 7px 0 0;\n    background-color: #f5f5f5;\n    border: 1px solid #dedede;\n    border-top: 1px solid #eee;\n    border-left: 1px solid #eee;\n    font-family: \"Lucida Grande\", Tahoma, Arial, Verdana, sans-serif;\n    text-decoration: none;\n    color: #565656;\n    cursor: pointer;\n    padding: 5px 8px 6px 7px;\n}\n\n\n/* line 161, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main .selectorgadget_wizard .selectorgadget_input_field {\n    margin: 7px 3px 7px 3px;\n    float: none;\n    display: inline;\n}\n\n\n/* line 167, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main .selectorgadget_prompt {\n    margin: 3px 0px 3px 0px;\n    font-family: \"Lucida Grande\", Tahoma, Arial, Verdana, sans-serif;\n    font-weight: bold;\n    float: none;\n}\n\n\n/* line 174, lib/css/selectorgadget.css.scss */\n\ndiv#selectorgadget_main .selectorgadget_wizard #selectorgadget_path_field {\n    margin: 5px 0px;\n    clear: both;\n    float: none;\n    display: block;\n}\n\n\n/* line 181, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_selected {\n    background-color: #0F0 !important;\n    background-image: none !important;\n}\n\n\n/* line 186, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_suggested {\n    background-color: #FF5 !important;\n    background-image: none !important;\n}\n\n\n/* line 191, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_border {\n    position: absolute !important;\n    z-index: 999999 !important;\n    background: white !important;\n    background-color: orange !important;\n    margin: 0px !important;\n    padding: 0px !important;\n    display: block !important;\n    float: none !important;\n    border: 0 !important;\n    font-style: none !important;\n    outline: 0 !important;\n    vertical-align: baseline !important;\n    text-align: left !important;\n}\n\n\n/* line 207, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_bottom_border {\n    font-size: 10px !important;\n    padding: 2px 0px 2px 5px !important;\n}\n\n\n/* line 212, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_border_red {\n    background-color: #F00 !important;\n}\n\n\n/* line 219, lib/css/selectorgadget.css.scss */\n\n.selectorgadget_rejected {\n    background-color: #F00 !important;\n    background-image: none !important;\n}\n\n\n/* line 225, lib/css/selectorgadget.css.scss */\n\nimg.selectorgadget_rejected {\n    border: 5px solid #F00 !important;\n}\n\n\n/* line 229, lib/css/selectorgadget.css.scss */\n\nimg.selectorgadget_suggested {\n    border: 5px solid #FF5 !important;\n}\n\n\n/* line 233, lib/css/selectorgadget.css.scss */\n\nimg.selectorgadget_selected {\n    border: 5px solid #0F0 !important;\n}\n\n\n/* line 238, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main.selectorgadget_top {\n    top: 5px !important;\n}\n\n\n/* line 242, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main.selectorgadget_bottom {\n    bottom: 5px !important;\n}\n\n\n/* line 246, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main input {\n    margin-right: 10px !important;\n    font-size: 15px !important;\n}\n\n\n/* line 251, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_path_field {\n    width: 400px !important;\n}\n\n\n/* line 255, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main .selectorgadget_new_line {\n    clear: both;\n}\n\n\n/* line 259, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main .selectorgadget_option {\n    float: left;\n}\n\n\n/* line 263, lib/css/selectorgadget.css.scss */\n\n#selectorgadget_main .selectorgadget_selected_option {\n    text-decoration: underline;\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/addStylesClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/addStylesClient.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return addStylesClient; });
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listToStyles */ "./node_modules/vue-style-loader/lib/listToStyles.js");
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = Object(_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = Object(_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/listToStyles.js":
/*!***********************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/listToStyles.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return listToStyles; });
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),

/***/ "./src/backend.js":
/*!************************!*\
  !*** ./src/backend.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spider-rulegen/vendor */ "./node_modules/@spider-rulegen/vendor/index.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/utils.js");




const emitter = new events__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]()
_spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__["SelectorGadget"].prototype.emitter = emitter

const port = chrome.runtime.connect({
    name: 'content-script'
})

port.onMessage.addListener(handleMessageFromDevtools)
port.onDisconnect.addListener(handleDisconnect)

let pathStore = ''

emitter.on("setPath", (e) => {
    if (pathStore !== e) {
        pathStore = e
        sendMessageToDevtools({ type: "selector:update", value: e })
    }
})

function sendMessageToDevtools(msg) {
    port.postMessage(msg)
}

function handleMessageFromDevtools(e) {
    switch (e.type) {
        case "selector:load":
            console.log("backend - load path: ", e.value)
            // ensure open
            const sg = _spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__["SelectorGadget"].toggleOpen()
            pathStore = sg.refreshFromPath({ value: e.value })
            break
        case "selector:deactive":
            _spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__["SelectorGadget"].toggleClose()
            break
        case "location:href":
            window.location.href = e.value
            break
        case "extract:urls":
            sendMessageToDevtools({ type: "extracted:urls", value: Object(_utils__WEBPACK_IMPORTED_MODULE_2__["getUrls"])(e.value) })
    }
}

function handleDisconnect() {
    _spider_rulegen_vendor__WEBPACK_IMPORTED_MODULE_0__["SelectorGadget"].toggleClose()
}



/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: getUrls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrls", function() { return getUrls; });
function getUrls(cssSelector) {
    const domList = document.querySelectorAll(cssSelector)
    const urls = []
    const hasSeen = new Set()

    function cb(node) {
        if (hasSeen.has(node)) {
            return false
        } else {
            hasSeen.add(node)
            if (node.nodeName === 'A') {
                const url = (node.href || '').trim()
                if (url) {
                    urls.push(url)
                }
                return false
            } else {
                return true
            }
        }
    }

    for (const domItem of domList) {
        domTraverse(domItem, cb)
    }
    return urls;
}

function domTraverse(domItem, cb) {
    const nodes = domItem.childNodes
    if (nodes) {
        for (const node of nodes) {
            const goInto = cb(node)
            if (goInto) {
                domTraverse(node, cb)
            }
        }
    }
}

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzcGlkZXItcnVsZWdlbi92ZW5kb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzcGlkZXItcnVsZWdlbi92ZW5kb3Ivc2VsZWN0b3JnYWRnZXQvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcz80ZjIyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3BpZGVyLXJ1bGVnZW4vdmVuZG9yL3NlbGVjdG9yZ2FkZ2V0L2pzL2NvcmUvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNwaWRlci1ydWxlZ2VuL3ZlbmRvci9zZWxlY3RvcmdhZGdldC9qcy9jb3JlL2RvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNwaWRlci1ydWxlZ2VuL3ZlbmRvci9zZWxlY3RvcmdhZGdldC9qcy9kaWZmLWJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzcGlkZXItcnVsZWdlbi92ZW5kb3Ivc2VsZWN0b3JnYWRnZXQvanMvanF1ZXJ5LWJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzcGlkZXItcnVsZWdlbi92ZW5kb3Ivc2VsZWN0b3JnYWRnZXQvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9iYWNrZW5kLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTREO0FBQ1o7QUFDRjs7Ozs7Ozs7Ozs7O0FDRjlDOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHlQQUEwRztBQUNoSSw0Q0FBNEMsUUFBUztBQUNyRDtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLG1IQUFzRDtBQUN4RSwrQ0FBK0M7QUFDL0M7QUFDQSxHQUFHLEtBQVUsRUFBRSxFOzs7Ozs7Ozs7Ozs7Ozs7O0FDVGY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkM7O0FBRXBDLDJCQUEyQjs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELHdEQUFtQjs7QUFFcEU7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7QUN6b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sZ0NBQWdDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFD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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUzs7QUFFVCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU87QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQyx5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHdDQUF3QyxzQkFBc0I7QUFDOUQsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxPQUFPLE9BQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUI7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxPQUFPO0FBQ2xCLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGtCQUFrQjtBQUM5QixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYTs7Ozs7Ozs7Ozs7QUN0OUREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkMsMkRBQTJELEVBQUU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYiwrQkFBK0IsRUFBRTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtRkFBbUYsdUJBQXVCO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsYUFBYTs7QUFFYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7OztBQUdMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGLFdBQVcsWUFBWTs7QUFFdkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsU0FBUyxZQUFZOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0EsdUJBQXVCO0FBQ3ZCLHdCQUF3QixJQUFJOztBQUU1QjtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZOztBQUV6Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7Ozs7QUFLTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7Ozs7QUFLTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxPQUFPO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQSxtRUFBbUUsUUFBUTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsUUFBUTtBQUMzRTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZGQUE2RixTQUFTO0FBQ3RHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7OztBQUtMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNCQUFzQjs7QUFFbkM7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix1QkFBdUI7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELE9BQU87QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsR0FBRztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxT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O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7O0FBRWIsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0IsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2Isa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLDJCQUEyQjtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQywyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLCtEQUErRDtBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQzs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FB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QUMsRUFBRTtBQUMvQixZQUFZLE9BQU8sS0FBSztBQUN4QixTQUFTLE1BQU07QUFDZixZQUFZLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0FBQzdCLFlBQVksSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLEdBQUcsRUFBRTtBQUN2QyxnQkFBZ0IsTUFBTSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRTtBQUNwRCxnQkFBZ0IsSUFBSSxHQUFHLEVBQUU7QUFDekIsb0JBQW9CLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQ2xDLGlCQUFpQjtBQUNqQixnQkFBZ0IsT0FBTyxLQUFLO0FBQzVCLGFBQWEsTUFBTTtBQUNuQixnQkFBZ0IsT0FBTyxJQUFJO0FBQzNCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsSUFBSSxLQUFLLE1BQU0sT0FBTyxJQUFJLE9BQU8sRUFBRTtBQUNuQyxRQUFRLFdBQVcsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDO0FBQ2hDLEtBQUs7QUFDTCxJQUFJLE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUFDRDtBQUNBLFNBQVMsV0FBVyxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUU7QUFDbEMsSUFBSSxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsVUFBVTtBQUNwQyxJQUFJLElBQUksS0FBSyxFQUFFO0FBQ2YsUUFBUSxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtBQUNsQyxZQUFZLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7QUFDbkMsWUFBWSxJQUFJLE1BQU0sRUFBRTtBQUN4QixnQkFBZ0IsV0FBVyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUM7QUFDckMsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQyIsImZpbGUiOiJiYWNrZW5kLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvYmFja2VuZC5qc1wiKTtcbiIsImltcG9ydCBzdHlsZXMgZnJvbSBcIi4vc2VsZWN0b3JnYWRnZXQvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzc1wiXG5pbXBvcnQganEgZnJvbSBcIi4vc2VsZWN0b3JnYWRnZXQvanMvanF1ZXJ5LWJpbmRcIlxuaW1wb3J0IGRmIGZyb20gXCIuL3NlbGVjdG9yZ2FkZ2V0L2pzL2RpZmYtYmluZFwiXG5leHBvcnQgeyBTZWxlY3RvckdhZGdldCB9IGZyb20gXCIuL3NlbGVjdG9yZ2FkZ2V0L2pzL2NvcmUvY29yZVwiIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTItMiEuL3NlbGVjdG9yZ2FkZ2V0LmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjRiZmJiZjZiXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0yLTIhLi9zZWxlY3RvcmdhZGdldC5jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMi0yIS4vc2VsZWN0b3JnYWRnZXQuY3NzXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCJcbi8qXG4gVGhlIE1JVCBMaWNlbnNlXG4gQ29weXJpZ2h0IChjKSAyMDEyIEFuZHJldyBDYW50aW5vXG4gQ29weXJpZ2h0IChjKSAyMDA5IEFuZHJldyBDYW50aW5vICYgS3lsZSBNYXh3ZWxsXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuIFRIRSBTT0ZUV0FSRS5cbiovXG5cbmltcG9ydCB7IERvbVByZWRpY3Rpb25IZWxwZXIgfSBmcm9tIFwiLi9kb21cIlxuXG5leHBvcnQgZnVuY3Rpb24gU2VsZWN0b3JHYWRnZXQoKSB7IH1cblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmJvcmRlcl93aWR0aCA9IDU7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5ib3JkZXJfcGFkZGluZyA9IDI7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5iX3RvcCA9IG51bGw7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5iX2xlZnQgPSBudWxsO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuYl9yaWdodCA9IG51bGw7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5iX2JvdHRvbSA9IG51bGw7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zZWxlY3RlZCA9IFtdO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUucmVqZWN0ZWQgPSBbXTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNwZWNpYWxfbW9kZSA9IG51bGw7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5wYXRoX291dHB1dF9maWVsZCA9IG51bGw7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zZ19kaXYgPSBudWxsO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuaWdub3JlX2NsYXNzID0gJ3NlbGVjdG9yZ2FkZ2V0X2lnbm9yZSc7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS51bmJvdW5kID0gZmFsc2U7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5wcmVkaWN0aW9uX2hlbHBlciA9IG5ldyBEb21QcmVkaWN0aW9uSGVscGVyKCk7XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5yZXN0cmljdGVkX2VsZW1lbnRzID0galF1ZXJ5U0cubWFwKFsnaHRtbCcsICdib2R5JywgJ2hlYWQnLCAnYmFzZSddLCBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4galF1ZXJ5U0coc2VsZWN0b3IpLmdldCgwKTtcbn0pO1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUubWFrZUJvcmRlcnMgPSBmdW5jdGlvbiAob3JpZ19lbGVtLCBtYWtlUmVkKSB7XG4gICAgdmFyIGVsZW0sIGhlaWdodCwgbGVmdCwgcCwgcGF0aF90b19zaG93LCB0b3AsIHdpZHRoO1xuICAgIHRoaXMucmVtb3ZlQm9yZGVycygpO1xuICAgIHRoaXMuc2V0dXBCb3JkZXJzKCk7XG4gICAgaWYgKG9yaWdfZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHBhdGhfdG9fc2hvdyA9IG9yaWdfZWxlbS5wYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICcgJyArIG9yaWdfZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aF90b19zaG93ID0gb3JpZ19lbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgZWxlbSA9IGpRdWVyeVNHKG9yaWdfZWxlbSk7XG4gICAgcCA9IGVsZW0ub2Zmc2V0KCk7XG4gICAgdG9wID0gcC50b3A7XG4gICAgbGVmdCA9IHAubGVmdDtcbiAgICB3aWR0aCA9IGVsZW0ub3V0ZXJXaWR0aCgpO1xuICAgIGhlaWdodCA9IGVsZW0ub3V0ZXJIZWlnaHQoKTtcbiAgICB0aGlzLmJfdG9wLmNzcygnd2lkdGgnLCB0aGlzLnB4KHdpZHRoICsgdGhpcy5ib3JkZXJfcGFkZGluZyAqIDIgKyB0aGlzLmJvcmRlcl93aWR0aCAqIDIpKS5jc3MoJ3RvcCcsIHRoaXMucHgodG9wIC0gdGhpcy5ib3JkZXJfd2lkdGggLSB0aGlzLmJvcmRlcl9wYWRkaW5nKSkuY3NzKCdsZWZ0JywgdGhpcy5weChsZWZ0IC0gdGhpcy5ib3JkZXJfcGFkZGluZyAtIHRoaXMuYm9yZGVyX3dpZHRoKSk7XG4gICAgdGhpcy5iX2JvdHRvbS5jc3MoJ3dpZHRoJywgdGhpcy5weCh3aWR0aCArIHRoaXMuYm9yZGVyX3BhZGRpbmcgKiAyICsgdGhpcy5ib3JkZXJfd2lkdGggKiAyIC0gNSkpLmNzcygndG9wJywgdGhpcy5weCh0b3AgKyBoZWlnaHQgKyB0aGlzLmJvcmRlcl9wYWRkaW5nKSkuY3NzKCdsZWZ0JywgdGhpcy5weChsZWZ0IC0gdGhpcy5ib3JkZXJfcGFkZGluZyAtIHRoaXMuYm9yZGVyX3dpZHRoKSkudGV4dChwYXRoX3RvX3Nob3cpO1xuICAgIHRoaXMuYl9sZWZ0LmNzcygnaGVpZ2h0JywgdGhpcy5weChoZWlnaHQgKyB0aGlzLmJvcmRlcl9wYWRkaW5nICogMikpLmNzcygndG9wJywgdGhpcy5weCh0b3AgLSB0aGlzLmJvcmRlcl9wYWRkaW5nKSkuY3NzKCdsZWZ0JywgdGhpcy5weChsZWZ0IC0gdGhpcy5ib3JkZXJfcGFkZGluZyAtIHRoaXMuYm9yZGVyX3dpZHRoKSk7XG4gICAgdGhpcy5iX3JpZ2h0LmNzcygnaGVpZ2h0JywgdGhpcy5weChoZWlnaHQgKyB0aGlzLmJvcmRlcl9wYWRkaW5nICogMikpLmNzcygndG9wJywgdGhpcy5weCh0b3AgLSB0aGlzLmJvcmRlcl9wYWRkaW5nKSkuY3NzKCdsZWZ0JywgdGhpcy5weChsZWZ0ICsgd2lkdGggKyB0aGlzLmJvcmRlcl9wYWRkaW5nKSk7XG4gICAgdGhpcy5iX3JpZ2h0LmdldCgwKS50YXJnZXRfZWxlbSA9IHRoaXMuYl9sZWZ0LmdldCgwKS50YXJnZXRfZWxlbSA9IHRoaXMuYl90b3AuZ2V0KDApLnRhcmdldF9lbGVtID0gdGhpcy5iX2JvdHRvbS5nZXQoMCkudGFyZ2V0X2VsZW0gPSBvcmlnX2VsZW07XG4gICAgaWYgKG1ha2VSZWQgfHwgZWxlbS5oYXNDbGFzcyhcInNlbGVjdG9yZ2FkZ2V0X3N1Z2dlc3RlZFwiKSB8fCBlbGVtLmhhc0NsYXNzKFwic2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgdGhpcy5iX3RvcC5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyX3JlZCcpO1xuICAgICAgICB0aGlzLmJfYm90dG9tLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXJfcmVkJyk7XG4gICAgICAgIHRoaXMuYl9sZWZ0LmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXJfcmVkJyk7XG4gICAgICAgIHRoaXMuYl9yaWdodC5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyX3JlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmJfdG9wLmhhc0NsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXJfcmVkJykpIHtcbiAgICAgICAgICAgIHRoaXMuYl90b3AucmVtb3ZlQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvcmRlcl9yZWQnKTtcbiAgICAgICAgICAgIHRoaXMuYl9ib3R0b20ucmVtb3ZlQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvcmRlcl9yZWQnKTtcbiAgICAgICAgICAgIHRoaXMuYl9sZWZ0LnJlbW92ZUNsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXJfcmVkJyk7XG4gICAgICAgICAgICB0aGlzLmJfcmlnaHQucmVtb3ZlQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvcmRlcl9yZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaG93Qm9yZGVycygpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnB4ID0gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCArICdweCc7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2hvd0JvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5iX3RvcC5zaG93KCk7XG4gICAgdGhpcy5iX2JvdHRvbS5zaG93KCk7XG4gICAgdGhpcy5iX2xlZnQuc2hvdygpO1xuICAgIHJldHVybiB0aGlzLmJfcmlnaHQuc2hvdygpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJlbW92ZUJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYl90b3ApIHtcbiAgICAgICAgdGhpcy5iX3RvcC5oaWRlKCk7XG4gICAgICAgIHRoaXMuYl9ib3R0b20uaGlkZSgpO1xuICAgICAgICB0aGlzLmJfbGVmdC5oaWRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJfcmlnaHQuaGlkZSgpO1xuICAgIH1cbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zZXR1cEJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdpZHRoO1xuICAgIGlmICghdGhpcy5iX3RvcCkge1xuICAgICAgICB3aWR0aCA9IHRoaXMuYm9yZGVyX3dpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5iX3RvcCA9IGpRdWVyeVNHKCc8ZGl2PicpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXInKS5jc3MoJ2hlaWdodCcsIHdpZHRoKS5oaWRlKCkuYmluZChcIm1vdXNlZG93bi5zZ1wiLCB7XG4gICAgICAgICAgICAnc2VsZic6IHRoaXNcbiAgICAgICAgfSwgdGhpcy5zZ01vdXNlZG93bik7XG4gICAgICAgIHRoaXMuYl9ib3R0b20gPSBqUXVlcnlTRygnPGRpdj4nKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfYm9yZGVyJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvdHRvbV9ib3JkZXInKS5jc3MoJ2hlaWdodCcsIHRoaXMucHgodGhpcy5ib3JkZXJfd2lkdGggKyA2KSkuaGlkZSgpLmJpbmQoXCJtb3VzZWRvd24uc2dcIiwge1xuICAgICAgICAgICAgJ3NlbGYnOiB0aGlzXG4gICAgICAgIH0sIHRoaXMuc2dNb3VzZWRvd24pO1xuICAgICAgICB0aGlzLmJfbGVmdCA9IGpRdWVyeVNHKCc8ZGl2PicpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3JkZXInKS5jc3MoJ3dpZHRoJywgd2lkdGgpLmhpZGUoKS5iaW5kKFwibW91c2Vkb3duLnNnXCIsIHtcbiAgICAgICAgICAgICdzZWxmJzogdGhpc1xuICAgICAgICB9LCB0aGlzLnNnTW91c2Vkb3duKTtcbiAgICAgICAgdGhpcy5iX3JpZ2h0ID0galF1ZXJ5U0coJzxkaXY+JykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvcmRlcicpLmNzcygnd2lkdGgnLCB3aWR0aCkuaGlkZSgpLmJpbmQoXCJtb3VzZWRvd24uc2dcIiwge1xuICAgICAgICAgICAgJ3NlbGYnOiB0aGlzXG4gICAgICAgIH0sIHRoaXMuc2dNb3VzZWRvd24pO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRCb3JkZXJUb0RvbSgpO1xuICAgIH1cbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5hZGRCb3JkZXJUb0RvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYl90b3AuZ2V0KDApKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYl9ib3R0b20uZ2V0KDApKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYl9sZWZ0LmdldCgwKSk7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5iX3JpZ2h0LmdldCgwKSk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUucmVtb3ZlQm9yZGVyRnJvbURvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5iX3RvcCkge1xuICAgICAgICB0aGlzLmJfdG9wLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmJfYm90dG9tLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmJfbGVmdC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5iX3JpZ2h0LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5iX3RvcCA9IHRoaXMuYl9ib3R0b20gPSB0aGlzLmJfbGVmdCA9IHRoaXMuYl9yaWdodCA9IG51bGw7XG4gICAgfVxufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNlbGVjdGFibGUgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHJldHVybiAhdGhpcy5jc3NfcmVzdHJpY3Rpb24gfHwgKHRoaXMuY3NzX3Jlc3RyaWN0aW9uICYmIGpRdWVyeVNHKGVsZW0pLmlzKHRoaXMuY3NzX3Jlc3RyaWN0aW9uKSk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2dNb3VzZW92ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBnYWRnZXQsIHBhcmVudCwgc2VsZjtcbiAgICBnYWRnZXQgPSBlLmRhdGEuc2VsZjtcbiAgICBpZiAoZ2FkZ2V0LnVuYm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzID09PSBkb2N1bWVudC5ib2R5IHx8IHRoaXMgPT09IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGYgPSBqUXVlcnlTRyh0aGlzKTtcbiAgICBnYWRnZXQudW5oaWdobGlnaHRJZnJhbWVzKCk7XG4gICAgaWYgKHNlbGYuaXMoXCJpZnJhbWVcIikpIHtcbiAgICAgICAgZ2FkZ2V0LmhpZ2hsaWdodElmcmFtZShzZWxmLCBlKTtcbiAgICB9XG4gICAgaWYgKGdhZGdldC5zcGVjaWFsX21vZGUgIT09ICdkJykge1xuICAgICAgICBwYXJlbnQgPSBnYWRnZXQuZmlyc3RTZWxlY3RlZE9yU3VnZ2VzdGVkUGFyZW50KHRoaXMpO1xuICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudCAhPT0gdGhpcyAmJiBnYWRnZXQuc2VsZWN0YWJsZShwYXJlbnQpKSB7XG4gICAgICAgICAgICBnYWRnZXQubWFrZUJvcmRlcnMocGFyZW50LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnYWRnZXQuc2VsZWN0YWJsZShzZWxmKSkge1xuICAgICAgICAgICAgICAgIGdhZGdldC5tYWtlQm9yZGVycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghalF1ZXJ5U0coJy5zZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcsIHRoaXMpLmdldCgwKSkge1xuICAgICAgICAgICAgaWYgKGdhZGdldC5zZWxlY3RhYmxlKHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgZ2FkZ2V0Lm1ha2VCb3JkZXJzKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5maXJzdFNlbGVjdGVkT3JTdWdnZXN0ZWRQYXJlbnQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBvcmlnO1xuICAgIG9yaWcgPSBlbGVtO1xuICAgIGlmIChqUXVlcnlTRyhlbGVtKS5oYXNDbGFzcygnc2VsZWN0b3JnYWRnZXRfc3VnZ2VzdGVkJykgfHwgalF1ZXJ5U0coZWxlbSkuaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkJykpIHtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIHdoaWxlIChlbGVtLnBhcmVudE5vZGUgJiYgKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpKSB7XG4gICAgICAgIGlmIChqUXVlcnlTRy5pbkFycmF5KGVsZW0sIHRoaXMucmVzdHJpY3RlZF9lbGVtZW50cykgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5U0coZWxlbSkuaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3N1Z2dlc3RlZCcpIHx8IGpRdWVyeVNHKGVsZW0pLmhhc0NsYXNzKCdzZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2dNb3VzZW91dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGVsZW0sIGdhZGdldDtcbiAgICBnYWRnZXQgPSBlLmRhdGEuc2VsZjtcbiAgICBpZiAoZ2FkZ2V0LnVuYm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzID09PSBkb2N1bWVudC5ib2R5IHx8IHRoaXMgPT09IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsZW0gPSBqUXVlcnlTRyh0aGlzKTtcbiAgICBnYWRnZXQucmVtb3ZlQm9yZGVycygpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5oaWdobGlnaHRJZnJhbWUgPSBmdW5jdGlvbiAoZWxlbSwgY2xpY2spIHtcbiAgICB2YXIgYmxvY2ssIGluc3RydWN0aW9ucywgcCwgc2VsZiwgc3JjLCB0YXJnZXQ7XG4gICAgcCA9IGVsZW0ub2Zmc2V0KCk7XG4gICAgc2VsZiA9IHRoaXM7XG4gICAgdGFyZ2V0ID0galF1ZXJ5U0coY2xpY2sudGFyZ2V0KTtcbiAgICBibG9jayA9IGpRdWVyeVNHKCc8ZGl2PicpLmNzcygncG9zaXRpb24nLCAnYWJzb2x1dGUnKS5jc3MoJ3otaW5kZXgnLCAnOTk5OTgnKS5jc3MoJ3dpZHRoJywgdGhpcy5weChlbGVtLm91dGVyV2lkdGgoKSkpLmNzcygnaGVpZ2h0JywgdGhpcy5weChlbGVtLm91dGVySGVpZ2h0KCkpKS5jc3MoJ3RvcCcsIHRoaXMucHgocC50b3ApKS5jc3MoJ2xlZnQnLCB0aGlzLnB4KHAubGVmdCkpLmNzcygnYmFja2dyb3VuZC1jb2xvcicsICcjQUFBJykuY3NzKCdvcGFjaXR5JywgJzAuNicpLmFkZENsYXNzKFwic2VsZWN0b3JnYWRnZXRfaWZyYW1lXCIpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9jbGVhbicpO1xuICAgIGluc3RydWN0aW9ucyA9IGpRdWVyeVNHKFwiPGRpdj48c3Bhbj5UaGlzIGlzIGFuIGlmcmFtZS4gIFRvIHNlbGVjdCBpbiBpdCwgPC9zcGFuPjwvZGl2PlwiKS5hZGRDbGFzcyhcInNlbGVjdG9yZ2FkZ2V0X2lmcmFtZV9pbmZvXCIpLmFkZENsYXNzKFwic2VsZWN0b3JnYWRnZXRfaWZyYW1lXCIpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9jbGVhbicpO1xuICAgIGluc3RydWN0aW9ucy5jc3Moe1xuICAgICAgICB3aWR0aDogXCIyMDBweFwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIlxuICAgIH0sIHtcbiAgICAgICAgcGFkZGluZzogXCI1cHhcIixcbiAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgXCJ6LWluZGV4XCI6IFwiOTk5OTlcIixcbiAgICAgICAgdG9wOiB0aGlzLnB4KHAudG9wICsgKGVsZW0ub3V0ZXJIZWlnaHQoKSAvIDQuMCkpLFxuICAgICAgICBsZWZ0OiB0aGlzLnB4KHAubGVmdCArIChlbGVtLm91dGVyV2lkdGgoKSAtIDIwMCkgLyAyLjApLFxuICAgICAgICBoZWlnaHQ6IFwiMTUwcHhcIlxuICAgIH0pO1xuICAgIHNyYyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgc3JjID0gZWxlbS5jb250ZW50cygpLmdldCgwKS5sb2NhdGlvbi5ocmVmO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc3JjID0gZWxlbS5hdHRyKFwic3JjXCIpO1xuICAgIH1cbiAgICBpbnN0cnVjdGlvbnMuYXBwZW5kKGpRdWVyeVNHKFwiPGEgdGFyZ2V0PSdfdG9wJz5jbGljayBoZXJlIHRvIG9wZW4gaXQ8L2E+XCIpLmF0dHIoXCJocmVmXCIsIHNyYykpO1xuICAgIGluc3RydWN0aW9ucy5hcHBlbmQoalF1ZXJ5U0coXCI8c3Bhbj4sIHRoZW4gcmVsYXVuY2ggU2VsZWN0b3JHYWRnZXQuPC9zcGFuPlwiKSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbnN0cnVjdGlvbnMuZ2V0KDApKTtcbiAgICBibG9jay5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLnNlbGVjdGFibGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5tb3VzZWRvd24oKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJsb2NrLmdldCgwKSk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUudW5oaWdobGlnaHRJZnJhbWVzID0gZnVuY3Rpb24gKGVsZW0sIGNsaWNrKSB7XG4gICAgcmV0dXJuIGpRdWVyeVNHKFwiLnNlbGVjdG9yZ2FkZ2V0X2lmcmFtZVwiKS5yZW1vdmUoKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zZ01vdXNlZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGVsZW0sIGdhZGdldCwgcG90ZW50aWFsX2VsZW0sIHByZWRpY3Rpb24sIHdfZWxlbTtcbiAgICBnYWRnZXQgPSBlLmRhdGEuc2VsZjtcbiAgICBpZiAoZ2FkZ2V0LnVuYm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsZW0gPSB0aGlzO1xuICAgIHdfZWxlbSA9IGpRdWVyeVNHKGVsZW0pO1xuICAgIGlmICh3X2VsZW0uaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvcmRlcicpKSB7XG4gICAgICAgIGVsZW0gPSBlbGVtLnRhcmdldF9lbGVtIHx8IGVsZW07XG4gICAgICAgIHdfZWxlbSA9IGpRdWVyeVNHKGVsZW0pO1xuICAgIH1cbiAgICBpZiAoZWxlbSA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbGVtID09PSBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ2FkZ2V0LnNwZWNpYWxfbW9kZSAhPT0gJ2QnKSB7XG4gICAgICAgIHBvdGVudGlhbF9lbGVtID0gZ2FkZ2V0LmZpcnN0U2VsZWN0ZWRPclN1Z2dlc3RlZFBhcmVudChlbGVtKTtcbiAgICAgICAgaWYgKHBvdGVudGlhbF9lbGVtICE9PSBudWxsICYmIHBvdGVudGlhbF9lbGVtICE9PSBlbGVtKSB7XG4gICAgICAgICAgICBlbGVtID0gcG90ZW50aWFsX2VsZW07XG4gICAgICAgICAgICB3X2VsZW0gPSBqUXVlcnlTRyhlbGVtKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChqUXVlcnlTRygnLnNlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkJywgdGhpcykuZ2V0KDApKSB7XG4gICAgICAgICAgICBnYWRnZXQuYmxvY2tDbGlja3NPbihlbGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdhZGdldC5zZWxlY3RhYmxlKHdfZWxlbSkpIHtcbiAgICAgICAgZ2FkZ2V0LnJlbW92ZUJvcmRlcnMoKTtcbiAgICAgICAgZ2FkZ2V0LmJsb2NrQ2xpY2tzT24oZWxlbSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHdfZWxlbS5oYXNDbGFzcygnc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWQnKSkge1xuICAgICAgICB3X2VsZW0ucmVtb3ZlQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkJyk7XG4gICAgICAgIGdhZGdldC5zZWxlY3RlZC5zcGxpY2UoalF1ZXJ5U0cuaW5BcnJheShlbGVtLCBnYWRnZXQuc2VsZWN0ZWQpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHdfZWxlbS5oYXNDbGFzcyhcInNlbGVjdG9yZ2FkZ2V0X3JlamVjdGVkXCIpKSB7XG4gICAgICAgIHdfZWxlbS5yZW1vdmVDbGFzcygnc2VsZWN0b3JnYWRnZXRfcmVqZWN0ZWQnKTtcbiAgICAgICAgZ2FkZ2V0LnJlamVjdGVkLnNwbGljZShqUXVlcnlTRy5pbkFycmF5KGVsZW0sIGdhZGdldC5yZWplY3RlZCksIDEpO1xuICAgIH0gZWxzZSBpZiAod19lbGVtLmhhc0NsYXNzKFwic2VsZWN0b3JnYWRnZXRfc3VnZ2VzdGVkXCIpKSB7XG4gICAgICAgIHdfZWxlbS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfcmVqZWN0ZWQnKTtcbiAgICAgICAgZ2FkZ2V0LnJlamVjdGVkLnB1c2goZWxlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd19lbGVtLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcpO1xuICAgICAgICBnYWRnZXQuc2VsZWN0ZWQucHVzaChlbGVtKTtcbiAgICB9XG4gICAgZ2FkZ2V0LmNsZWFyU3VnZ2VzdGVkKCk7XG4gICAgcHJlZGljdGlvbiA9IGdhZGdldC5wcmVkaWN0aW9uX2hlbHBlci5wcmVkaWN0Q3NzKGpRdWVyeVNHKGdhZGdldC5zZWxlY3RlZCksIGpRdWVyeVNHKGdhZGdldC5yZWplY3RlZC5jb25jYXQoZ2FkZ2V0LnJlc3RyaWN0ZWRfZWxlbWVudHMpKSk7XG4gICAgZ2FkZ2V0LnN1Z2dlc3RQcmVkaWN0ZWQocHJlZGljdGlvbik7XG4gICAgZ2FkZ2V0LnNldFBhdGgocHJlZGljdGlvbik7XG4gICAgZ2FkZ2V0LnJlbW92ZUJvcmRlcnMoKTtcbiAgICBnYWRnZXQuYmxvY2tDbGlja3NPbihlbGVtKTtcbiAgICB3X2VsZW0udHJpZ2dlcihcIm1vdXNlb3Zlci5zZ1wiLCB7XG4gICAgICAgICdzZWxmJzogZ2FkZ2V0XG4gICAgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnNldHVwRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBqUXVlcnlTRyhcIio6bm90KC5zZWxlY3RvcmdhZGdldF9pZ25vcmUpXCIpLmJpbmQoXCJtb3VzZW92ZXIuc2dcIiwge1xuICAgICAgICAnc2VsZic6IHRoaXNcbiAgICB9LCB0aGlzLnNnTW91c2VvdmVyKTtcbiAgICBqUXVlcnlTRyhcIio6bm90KC5zZWxlY3RvcmdhZGdldF9pZ25vcmUpXCIpLmJpbmQoXCJtb3VzZW91dC5zZ1wiLCB7XG4gICAgICAgICdzZWxmJzogdGhpc1xuICAgIH0sIHRoaXMuc2dNb3VzZW91dCk7XG4gICAgalF1ZXJ5U0coXCIqOm5vdCguc2VsZWN0b3JnYWRnZXRfaWdub3JlKVwiKS5iaW5kKFwibW91c2Vkb3duLnNnXCIsIHtcbiAgICAgICAgJ3NlbGYnOiB0aGlzXG4gICAgfSwgdGhpcy5zZ01vdXNlZG93bik7XG4gICAgalF1ZXJ5U0coXCJodG1sXCIpLmJpbmQoXCJrZXlkb3duLnNnXCIsIHtcbiAgICAgICAgJ3NlbGYnOiB0aGlzXG4gICAgfSwgdGhpcy5saXN0ZW5Gb3JBY3Rpb25LZXlzKTtcbiAgICByZXR1cm4galF1ZXJ5U0coXCJodG1sXCIpLmJpbmQoXCJrZXl1cC5zZ1wiLCB7XG4gICAgICAgICdzZWxmJzogdGhpc1xuICAgIH0sIHRoaXMuY2xlYXJBY3Rpb25LZXlzKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5saXN0ZW5Gb3JBY3Rpb25LZXlzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZ2FkZ2V0O1xuICAgIGdhZGdldCA9IGUuZGF0YS5zZWxmO1xuICAgIGlmIChnYWRnZXQudW5ib3VuZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMTYgfHwgZS5rZXlDb2RlID09PSA2OCkge1xuICAgICAgICBnYWRnZXQuc3BlY2lhbF9tb2RlID0gJ2QnO1xuICAgICAgICByZXR1cm4gZ2FkZ2V0LnJlbW92ZUJvcmRlcnMoKTtcbiAgICB9XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuY2xlYXJBY3Rpb25LZXlzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZ2FkZ2V0O1xuICAgIGdhZGdldCA9IGUuZGF0YS5zZWxmO1xuICAgIGlmIChnYWRnZXQudW5ib3VuZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2FkZ2V0LnJlbW92ZUJvcmRlcnMoKTtcbiAgICByZXR1cm4gZ2FkZ2V0LnNwZWNpYWxfbW9kZSA9IG51bGw7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuYmxvY2tDbGlja3NPbiA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIGJsb2NrLCBwO1xuICAgIGVsZW0gPSBqUXVlcnlTRyhlbGVtKTtcbiAgICBwID0gZWxlbS5vZmZzZXQoKTtcbiAgICBibG9jayA9IGpRdWVyeVNHKCc8ZGl2PicpLmNzcygncG9zaXRpb24nLCAnYWJzb2x1dGUnKS5jc3MoJ3otaW5kZXgnLCAnOTk5OTk5OScpLmNzcygnd2lkdGgnLCB0aGlzLnB4KGVsZW0ub3V0ZXJXaWR0aCgpKSkuY3NzKCdoZWlnaHQnLCB0aGlzLnB4KGVsZW0ub3V0ZXJIZWlnaHQoKSkpLmNzcygndG9wJywgdGhpcy5weChwLnRvcCkpLmNzcygnbGVmdCcsIHRoaXMucHgocC5sZWZ0KSkuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgJycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYmxvY2suZ2V0KDApKTtcbiAgICBzZXRUaW1lb3V0KChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBibG9jay5yZW1vdmUoKTtcbiAgICB9KSwgNDAwKTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgaWYgKG1vZGUgPT09ICdicm93c2UnKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRIYW5kbGVycygpO1xuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgICAgICB0aGlzLnNldHVwRXZlbnRIYW5kbGVycygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbGVhclNlbGVjdGVkKCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc3VnZ2VzdFByZWRpY3RlZCA9IGZ1bmN0aW9uIChwcmVkaWN0aW9uKSB7XG4gICAgdmFyIGNvdW50O1xuICAgIGlmIChwcmVkaWN0aW9uICYmIHByZWRpY3Rpb24gIT09ICcnKSB7XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgalF1ZXJ5U0cocHJlZGljdGlvbikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKCFqUXVlcnlTRyh0aGlzKS5oYXNDbGFzcygnc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWQnKSAmJiAhalF1ZXJ5U0codGhpcykuaGFzQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lnbm9yZScpICYmICFqUXVlcnlTRyh0aGlzKS5oYXNDbGFzcygnc2VsZWN0b3JnYWRnZXRfcmVqZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnlTRyh0aGlzKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfc3VnZ2VzdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jbGVhcl9idXR0b24pIHtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9idXR0b24uYXR0cigndmFsdWUnLCAnQ2xlYXIgKCcgKyBjb3VudCArICcpJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsZWFyX2J1dHRvbi5hdHRyKCd2YWx1ZScsICdDbGVhcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gTW9kaWZ5OiBlbWl0IHNldFBhdGggZXZlbnRcblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24gKHByZWRpY3Rpb24pIHtcbiAgICBsZXQgcGF0aCA9ICcnXG4gICAgaWYgKHByZWRpY3Rpb24gJiYgcHJlZGljdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhdGggPSBwcmVkaWN0aW9uXG4gICAgfVxuICAgIHRoaXMucGF0aF9vdXRwdXRfZmllbGQudmFsdWUgPSBwYXRoXG4gICAgdGhpcy5lbWl0dGVyICYmIHRoaXMuZW1pdHRlci5lbWl0KCdzZXRQYXRoJywgcGF0aClcbiAgICByZXR1cm4gcGF0aFxufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJlZnJlc2hGcm9tUGF0aCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHBhdGgsIHNlbGY7XG4gICAgc2VsZiA9IChlICYmIGUuZGF0YSAmJiBlLmRhdGEuc2VsZikgfHwgdGhpcztcblxuICAgIC8vIE1vZGlmeTogc2V0IHBhdGggZnJvbSBlXG4gICAgaWYgKGUgJiYgZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGYucGF0aF9vdXRwdXRfZmllbGQudmFsdWUgPSBlLnZhbHVlXG4gICAgfVxuXG4gICAgcGF0aCA9IHNlbGYucGF0aF9vdXRwdXRfZmllbGQudmFsdWU7XG4gICAgc2VsZi5jbGVhclNlbGVjdGVkKCk7XG4gICAgc2VsZi5zdWdnZXN0UHJlZGljdGVkKHBhdGgpO1xuICAgIHJldHVybiBzZWxmLnNldFBhdGgocGF0aCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2hvd1hQYXRoID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcGF0aCwgc2VsZjtcbiAgICBzZWxmID0gKGUgJiYgZS5kYXRhICYmIGUuZGF0YS5zZWxmKSB8fCB0aGlzO1xuICAgIHBhdGggPSBzZWxmLnBhdGhfb3V0cHV0X2ZpZWxkLnZhbHVlO1xuICAgIGlmIChwYXRoID09PSAnTm8gdmFsaWQgcGF0aCBmb3VuZC4nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHByb21wdChcIlRoZSBDU1Mgc2VsZWN0b3IgJ1wiICsgcGF0aCArIFwiJyBhcyBhbiBYUGF0aCBpcyBzaG93biBiZWxvdy4gIFBsZWFzZSByZXBvcnQgYW55IGJ1Z3MgdGhhdCB5b3UgZmluZCB3aXRoIHRoaXMgY29udmVydGVyLlwiLCBzZWxmLnByZWRpY3Rpb25faGVscGVyLmNzc1RvWFBhdGgocGF0aCkpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmNsZWFyU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmO1xuICAgIHNlbGYgPSAoZSAmJiBlLmRhdGEgJiYgZS5kYXRhLnNlbGYpIHx8IHRoaXM7XG4gICAgc2VsZi5zZWxlY3RlZCA9IFtdO1xuICAgIHNlbGYucmVqZWN0ZWQgPSBbXTtcbiAgICBqUXVlcnlTRygnLnNlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkJykucmVtb3ZlQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X3NlbGVjdGVkJyk7XG4gICAgalF1ZXJ5U0coJy5zZWxlY3RvcmdhZGdldF9yZWplY3RlZCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RvcmdhZGdldF9yZWplY3RlZCcpO1xuICAgIHNlbGYucmVtb3ZlQm9yZGVycygpO1xuICAgIHJldHVybiBzZWxmLmNsZWFyU3VnZ2VzdGVkKCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuY2xlYXJFdmVyeXRoaW5nID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZjtcbiAgICBzZWxmID0gKGUgJiYgZS5kYXRhICYmIGUuZGF0YS5zZWxmKSB8fCB0aGlzO1xuICAgIHNlbGYuY2xlYXJTZWxlY3RlZCgpO1xuICAgIHJldHVybiBzZWxmLnJlc2V0T3V0cHV0cygpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJlc2V0T3V0cHV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRQYXRoKCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuY2xlYXJTdWdnZXN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgalF1ZXJ5U0coJy5zZWxlY3RvcmdhZGdldF9zdWdnZXN0ZWQnKS5yZW1vdmVDbGFzcygnc2VsZWN0b3JnYWRnZXRfc3VnZ2VzdGVkJyk7XG4gICAgaWYgKHRoaXMuY2xlYXJfYnV0dG9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyX2J1dHRvbi5hdHRyKCd2YWx1ZScsICdDbGVhcicpO1xuICAgIH1cbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5zaG93SGVscCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxlcnQoXCJDbGljayBvbiBhIHBhZ2UgZWxlbWVudCB0aGF0IHlvdSB3b3VsZCBsaWtlIHlvdXIgc2VsZWN0b3IgdG8gbWF0Y2ggKGl0IHdpbGwgdHVybiBncmVlbikuIFNlbGVjdG9yR2FkZ2V0IHdpbGwgdGhlbiBnZW5lcmF0ZSBhIG1pbmltYWwgQ1NTIHNlbGVjdG9yIGZvciB0aGF0IGVsZW1lbnQsIGFuZCB3aWxsIGhpZ2hsaWdodCAoeWVsbG93KSBldmVyeXRoaW5nIHRoYXQgaXMgbWF0Y2hlZCBieSB0aGUgc2VsZWN0b3IuIE5vdyBjbGljayBvbiBhIGhpZ2hsaWdodGVkIGVsZW1lbnQgdG8gcmVqZWN0IGl0IChyZWQpLCBvciBjbGljayBvbiBhbiB1bmhpZ2hsaWdodGVkIGVsZW1lbnQgdG8gYWRkIGl0IChncmVlbikuIFRocm91Z2ggdGhpcyBwcm9jZXNzIG9mIHNlbGVjdGlvbiBhbmQgcmVqZWN0aW9uLCBTZWxlY3RvckdhZGdldCBoZWxwcyB5b3UgdG8gY29tZSB1cCB3aXRoIHRoZSBwZXJmZWN0IENTUyBzZWxlY3RvciBmb3IgeW91ciBuZWVkcy5cXG5cXG5Ib2xkaW5nICdzaGlmdCcgd2hpbGUgbW92aW5nIHRoZSBtb3VzZSB3aWxsIGxldCB5b3Ugc2VsZWN0IGVsZW1lbnRzIGluc2lkZSBvZiBvdGhlciBzZWxlY3RlZCBlbGVtZW50cy5cIik7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUudXNlUmVtb3RlSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3aW5kb3cuc2dfb3B0aW9ucyAmJiB3aW5kb3cuc2dfb3B0aW9ucy5yZW1vdGVfaW50ZXJmYWNlO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnVwZGF0ZVJlbW90ZUludGVyZmFjZSA9IGZ1bmN0aW9uIChkYXRhX29iaikge1xuICAgIHJldHVybiB0aGlzLmFkZFNjcmlwdCh0aGlzLmNvbXBvc2VSZW1vdGVVcmwod2luZG93LnNnX29wdGlvbnMucmVtb3RlX2ludGVyZmFjZSwgZGF0YV9vYmopKTtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5jb21wb3NlUmVtb3RlVXJsID0gZnVuY3Rpb24gKHVybCwgZGF0YV9vYmopIHtcbiAgICB2YXIga2V5LCBwYXJhbXM7XG4gICAgcGFyYW1zID0gKHVybC5zcGxpdChcIj9cIilbMV0gJiYgdXJsLnNwbGl0KFwiP1wiKVsxXS5zcGxpdChcIiZcIikpIHx8IFtdO1xuICAgIHBhcmFtcy5wdXNoKFwidD1cIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xuICAgIHBhcmFtcy5wdXNoKFwidXJsPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XG4gICAgaWYgKGRhdGFfb2JqKSB7XG4gICAgICAgIGZvciAoa2V5IGluIGRhdGFfb2JqKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhX29ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucmVtb3RlX2RhdGEpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gdGhpcy5yZW1vdGVfZGF0YSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KFwiZGF0YVtcIiArIGtleSArIFwiXVwiKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnJlbW90ZV9kYXRhW2tleV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsLnNwbGl0KFwiP1wiKVswXSArIFwiP1wiICsgcGFyYW1zLmpvaW4oXCImXCIpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLmFkZFNjcmlwdCA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICB2YXIgaGVhZCwgcztcbiAgICBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9qYXZhc2NyaXB0Jyk7XG4gICAgcy5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYyk7XG4gICAgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgaWYgKGhlYWQpIHtcbiAgICAgICAgcmV0dXJuIGhlYWQuYXBwZW5kQ2hpbGQocyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocyk7XG4gICAgfVxufTtcblxuLy8gU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLm1ha2VJbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4vLyAgICAgdGhpcy5zZ19kaXYgPSBqUXVlcnlTRygnPGRpdj4nKS5hdHRyKCdpZCcsICdzZWxlY3RvcmdhZGdldF9tYWluJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvdHRvbScpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pZ25vcmUnKTtcbi8vICAgICBpZiAodGhpcy51c2VSZW1vdGVJbnRlcmZhY2UoKSkge1xuLy8gICAgICAgICB0aGlzLnBhdGhfb3V0cHV0X2ZpZWxkID0ge1xuLy8gICAgICAgICAgICAgdmFsdWU6IG51bGxcbi8vICAgICAgICAgfTtcbi8vICAgICAgICAgdGhpcy5yZW1vdGVfZGF0YSA9IHt9O1xuLy8gICAgICAgICB0aGlzLnVwZGF0ZVJlbW90ZUludGVyZmFjZSgpO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHRoaXMubWFrZVN0YW5kYXJkSW50ZXJmYWNlKCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBqUXVlcnlTRygnYm9keScpLmFwcGVuZCh0aGlzLnNnX2Rpdik7XG4vLyB9O1xuXG4vLyBNb2RpZnk6IG5vdGlmeSBwYXJlbnQgdG8gc2hvdyBpbnRlcmZhY2VcblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5tYWtlSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGF0aF9vdXRwdXRfZmllbGQgPSB7IHZhbHVlOiBcIlwiIH1cbn1cblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLm1ha2VTdGFuZGFyZEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aCwgc2VsZjtcbiAgICBzZWxmID0gdGhpcztcbiAgICBwYXRoID0galF1ZXJ5U0coJzxpbnB1dD4nKS5hdHRyKCdpZCcsICdzZWxlY3RvcmdhZGdldF9wYXRoX2ZpZWxkJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lnbm9yZScpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pbnB1dF9maWVsZCcpLmtleWRvd24oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJlZnJlc2hGcm9tUGF0aChlKTtcbiAgICAgICAgfVxuICAgIH0pLmZvY3VzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeVNHKHRoaXMpLnNlbGVjdCgpO1xuICAgIH0pO1xuICAgIHRoaXMuc2dfZGl2LmFwcGVuZChwYXRoKTtcbiAgICB0aGlzLmNsZWFyX2J1dHRvbiA9IGpRdWVyeVNHKCc8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwiQ2xlYXJcIi8+JykuYmluZChcImNsaWNrXCIsIHtcbiAgICAgICAgJ3NlbGYnOiB0aGlzXG4gICAgfSwgdGhpcy5jbGVhckV2ZXJ5dGhpbmcpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pZ25vcmUnKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfaW5wdXRfZmllbGQnKTtcbiAgICB0aGlzLnNnX2Rpdi5hcHBlbmQodGhpcy5jbGVhcl9idXR0b24pO1xuICAgIHRoaXMuc2dfZGl2LmFwcGVuZChqUXVlcnlTRygnPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIlRvZ2dsZSBQb3NpdGlvblwiLz4nKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLnNnX2Rpdi5oYXNDbGFzcygnc2VsZWN0b3JnYWRnZXRfdG9wJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnNnX2Rpdi5yZW1vdmVDbGFzcygnc2VsZWN0b3JnYWRnZXRfdG9wJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2JvdHRvbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2dfZGl2LnJlbW92ZUNsYXNzKCdzZWxlY3RvcmdhZGdldF9ib3R0b20nKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfdG9wJyk7XG4gICAgICAgIH1cbiAgICB9KS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfaWdub3JlJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lucHV0X2ZpZWxkJykpO1xuICAgIHRoaXMuc2dfZGl2LmFwcGVuZChqUXVlcnlTRygnPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIlhQYXRoXCIvPicpLmJpbmQoXCJjbGlja1wiLCB7XG4gICAgICAgICdzZWxmJzogdGhpc1xuICAgIH0sIHRoaXMuc2hvd1hQYXRoKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfaWdub3JlJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lucHV0X2ZpZWxkJykpO1xuICAgIHRoaXMuc2dfZGl2LmFwcGVuZChqUXVlcnlTRygnPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIj9cIi8+JykuYmluZChcImNsaWNrXCIsIHtcbiAgICAgICAgJ3NlbGYnOiB0aGlzXG4gICAgfSwgdGhpcy5zaG93SGVscCkuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lnbm9yZScpLmFkZENsYXNzKCdzZWxlY3RvcmdhZGdldF9pbnB1dF9maWVsZCcpKTtcbiAgICB0aGlzLnNnX2Rpdi5hcHBlbmQoalF1ZXJ5U0coJzxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJYXCIvPicpLmJpbmQoXCJjbGlja1wiLCB7XG4gICAgICAgICdzZWxmJzogdGhpc1xuICAgIH0sIHRoaXMudW5iaW5kQW5kUmVtb3ZlSW50ZXJmYWNlKS5hZGRDbGFzcygnc2VsZWN0b3JnYWRnZXRfaWdub3JlJykuYWRkQ2xhc3MoJ3NlbGVjdG9yZ2FkZ2V0X2lucHV0X2ZpZWxkJykpO1xuICAgIHJldHVybiB0aGlzLnBhdGhfb3V0cHV0X2ZpZWxkID0gcGF0aC5nZXQoMCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUucmVtb3ZlSW50ZXJmYWNlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAvLyBNb2RpZnk6IGRvIG5vdGhpbmcsIGNhdXNlIG5vIGVsZW1lbnQgd2FzIGluc2VydCBvbiBtYWtlSW50ZXJmYWNlXG4gICAgLy8gdGhpcy5zZ19kaXYucmVtb3ZlKCk7XG4gICAgLy8gcmV0dXJuIHRoaXMuc2dfZGl2ID0gbnVsbDtcbn07XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzZWxmO1xuICAgIHNlbGYgPSAoZSAmJiBlLmRhdGEgJiYgZS5kYXRhLnNlbGYpIHx8IHRoaXM7XG4gICAgc2VsZi51bmJvdW5kID0gdHJ1ZTtcbiAgICBzZWxmLnJlbW92ZUJvcmRlckZyb21Eb20oKTtcbiAgICByZXR1cm4gc2VsZi5jbGVhclNlbGVjdGVkKCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUudW5iaW5kQW5kUmVtb3ZlSW50ZXJmYWNlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZjtcbiAgICBzZWxmID0gKGUgJiYgZS5kYXRhICYmIGUuZGF0YS5zZWxmKSB8fCB0aGlzO1xuICAgIHNlbGYudW5iaW5kKCk7XG4gICAgcmV0dXJuIHNlbGYucmVtb3ZlSW50ZXJmYWNlKCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuc2V0T3V0cHV0TW9kZSA9IGZ1bmN0aW9uIChlLCBvdXRwdXRfbW9kZSkge1xuICAgIHZhciBzZWxmO1xuICAgIHNlbGYgPSAoZSAmJiBlLmRhdGEgJiYgZS5kYXRhLnNlbGYpIHx8IHRoaXM7XG4gICAgcmV0dXJuIHNlbGYub3V0cHV0X21vZGUgPSAoZSAmJiBlLmRhdGEgJiYgZS5kYXRhLm1vZGUpIHx8IG91dHB1dF9tb2RlO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJlYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVuYm91bmQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyRXZlcnl0aGluZygpO1xuICAgIHJldHVybiB0aGlzLnNldHVwQm9yZGVycygpO1xufTtcblxuU2VsZWN0b3JHYWRnZXQucHJvdG90eXBlLnJlYmluZEFuZE1ha2VJbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tYWtlSW50ZXJmYWNlKCk7XG4gICAgcmV0dXJuIHRoaXMucmViaW5kKCk7XG59O1xuXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUucmFuZEJldHdlZW4gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBiKSArIGE7XG59O1xuXG5TZWxlY3RvckdhZGdldC50b2dnbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmICghd2luZG93LnNlbGVjdG9yX2dhZGdldCkge1xuICAgICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0ID0gbmV3IFNlbGVjdG9yR2FkZ2V0KCk7XG4gICAgICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQubWFrZUludGVyZmFjZSgpO1xuICAgICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LmNsZWFyRXZlcnl0aGluZygpO1xuICAgICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LnNldE1vZGUoJ2ludGVyYWN0aXZlJyk7XG4gICAgICAgIGlmICgob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5hbmFseXRpY3MgOiB2b2lkIDApICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldC5hbmFseXRpY3MoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAod2luZG93LnNlbGVjdG9yX2dhZGdldC51bmJvdW5kKSB7XG4gICAgICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQucmViaW5kQW5kTWFrZUludGVyZmFjZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQudW5iaW5kQW5kUmVtb3ZlSW50ZXJmYWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBqUXVlcnlTRygnLnNlbGVjdG9yX2dhZGdldF9sb2FkaW5nJykucmVtb3ZlKCk7XG59O1xuXG4vLyBNb2RpZnk6IGFkZCBTZWxlY3RvckdhZGdldC50b2dnbGVPcGVuXG5TZWxlY3RvckdhZGdldC50b2dnbGVPcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAoIXdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQpIHtcbiAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldCA9IG5ldyBTZWxlY3RvckdhZGdldCgpO1xuICAgICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0Lm1ha2VJbnRlcmZhY2UoKTtcbiAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldC5jbGVhckV2ZXJ5dGhpbmcoKTtcbiAgICAgICAgd2luZG93LnNlbGVjdG9yX2dhZGdldC5zZXRNb2RlKCdpbnRlcmFjdGl2ZScpO1xuICAgICAgICAvLyBpZiAoKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuYW5hbHl0aWNzIDogdm9pZCAwKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQuYW5hbHl0aWNzKCk7XG4gICAgICAgIC8vIH1cbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQudW5ib3VuZCkge1xuICAgICAgICB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LnJlYmluZEFuZE1ha2VJbnRlcmZhY2UoKTtcbiAgICB9XG4gICAgalF1ZXJ5U0coJy5zZWxlY3Rvcl9nYWRnZXRfbG9hZGluZycpLnJlbW92ZSgpO1xuICAgIHJldHVybiB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0XG59XG5cblNlbGVjdG9yR2FkZ2V0LnRvZ2dsZUNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQgJiYgIXdpbmRvdy5zZWxlY3Rvcl9nYWRnZXQudW5ib3VuZCAmJiB3aW5kb3cuc2VsZWN0b3JfZ2FkZ2V0LnVuYmluZEFuZFJlbW92ZUludGVyZmFjZSgpO1xuICAgIHJldHVybiBqUXVlcnlTRygnLnNlbGVjdG9yX2dhZGdldF9sb2FkaW5nJykucmVtb3ZlKCk7XG59XG5cblNlbGVjdG9yR2FkZ2V0LnByb3RvdHlwZS5hbmFseXRpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvb2tpZSwgcmFuZG9tLCByZWZlcmVyLCB0b2RheSwgdXJjaGluVXJsLCB1c2VydmFyLCB1dG1hYywgdXRtaG4sIHV0bW4sIHV0bXA7XG4gICAgdXRtYWMgPSAnVUEtMTQ4OTQ4LTknO1xuICAgIHV0bWhuID0gZW5jb2RlVVJJQ29tcG9uZW50KCd3d3cuc2VsZWN0b3JnYWRnZXQuY29tJyk7XG4gICAgdXRtbiA9IHRoaXMucmFuZEJldHdlZW4oMTAwMDAwMDAwMCwgOTk5OTk5OTk5OSk7XG4gICAgY29va2llID0gdGhpcy5yYW5kQmV0d2VlbigxMDAwMDAwMCwgOTk5OTk5OTkpO1xuICAgIHJhbmRvbSA9IHRoaXMucmFuZEJldHdlZW4oMTAwMDAwMDAwMCwgMjE0NzQ4MzY0Nyk7XG4gICAgdG9kYXkgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMC4wKTtcbiAgICByZWZlcmVyID0gZW5jb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB1c2VydmFyID0gJy0nO1xuICAgIHV0bXAgPSAnc2cnO1xuICAgIHVyY2hpblVybCA9ICdodHRwOi8vd3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tL19fdXRtLmdpZj91dG13dj0xJnV0bW49JyArIHV0bW4gKyAnJnV0bXNyPS0mdXRtc2M9LSZ1dG11bD0tJnV0bWplPTAmdXRtZmw9LSZ1dG1kdD0tJnV0bWhuPScgKyB1dG1obiArICcmdXRtcj0nICsgcmVmZXJlciArICcmdXRtcD0nICsgdXRtcCArICcmdXRtYWM9JyArIHV0bWFjICsgJyZ1dG1jYz1fX3V0bWElM0QnICsgY29va2llICsgJy4nICsgcmFuZG9tICsgJy4nICsgdG9kYXkgKyAnLicgKyB0b2RheSArICcuJyArIHRvZGF5ICsgJy4yJTNCJTJCX191dG1iJTNEJyArIGNvb2tpZSArICclM0IlMkJfX3V0bWMlM0QnICsgY29va2llICsgJyUzQiUyQl9fdXRteiUzRCcgKyBjb29raWUgKyAnLicgKyB0b2RheSArICcuMi4yLnV0bWNjbiUzRChkaXJlY3QpJTdDdXRtY3NyJTNEKGRpcmVjdCklN0N1dG1jbWQlM0Qobm9uZSklM0IlMkJfX3V0bXYlM0QnICsgY29va2llICsgJy4nICsgdXNlcnZhciArICclM0InO1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGpRdWVyeVNHKCc8aW1nIC8+JykuYXR0cignc3JjJywgdXJjaGluVXJsKS5nZXQoMCkpO1xufTsiLCJcbi8qXG4gVGhlIE1JVCBMaWNlbnNlXG4gQ29weXJpZ2h0IChjKSAyMDEyIEFuZHJldyBDYW50aW5vXG4gQ29weXJpZ2h0IChjKSAyMDA5IEFuZHJldyBDYW50aW5vICYgS3lsZSBNYXh3ZWxsXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuIFRIRSBTT0ZUV0FSRS5cbiovXG5cbmV4cG9ydCBmdW5jdGlvbiBEb21QcmVkaWN0aW9uSGVscGVyKCkgeyB9XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLnJlY3Vyc2l2ZU5vZGVzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbjtcbiAgICBpZiAoZS5ub2RlTmFtZSAmJiBlLnBhcmVudE5vZGUgJiYgZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBuID0gdGhpcy5yZWN1cnNpdmVOb2RlcyhlLnBhcmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBuZXcgQXJyYXkoKTtcbiAgICB9XG4gICAgbi5wdXNoKGUpO1xuICAgIHJldHVybiBuO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuZXNjYXBlQ3NzTmFtZXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9cXGJzZWxlY3RvcmdhZGdldF9cXHcrXFxiL2csICcnKS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1tcXCNcXDtcXCZcXCxcXC5cXCtcXCpcXH5cXCdcXDpcXFwiXFwhXFxeXFwkXFxbXFxdXFwoXFwpXFw9XFw+XFx8XFwvXS9nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnXFxcXCcgKyBlO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvXFxzKy8sICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLScpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXhjZXB0aW9uIGluIGVzY2FwZUNzc05hbWVzXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5jaGlsZEVsZW1OdW1iZXIgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBjb3VudDtcbiAgICBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVsZW0ucHJldmlvdXNTaWJsaW5nICYmIChlbGVtID0gZWxlbS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLnNpYmxpbmdzV2l0aG91dFRleHROb2RlcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGZpbHRlcmVkX25vZGVzLCBub2RlLCBub2RlcywgX2ksIF9sZW47XG4gICAgbm9kZXMgPSBlLnBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICBmaWx0ZXJlZF9ub2RlcyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gbm9kZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW19pXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIiNcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IGUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlcmVkX25vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZF9ub2Rlcztcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLnBhdGhPZiA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIGUsIGosIHBhdGgsIHNpYmxpbmdzLCBfaSwgX2xlbiwgX3JlZjtcbiAgICBwYXRoID0gXCJcIjtcbiAgICBfcmVmID0gdGhpcy5yZWN1cnNpdmVOb2RlcyhlbGVtKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZSA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgc2libGluZ3MgPSB0aGlzLnNpYmxpbmdzV2l0aG91dFRleHROb2RlcyhlKTtcbiAgICAgICAgICAgIGlmIChlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICAgICAgaiA9IHNpYmxpbmdzLmxlbmd0aCAtIDIgPCAwID8gMCA6IHNpYmxpbmdzLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBzaWJsaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmdzW2pdID09PSBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpYmxpbmdzW2pdLm5vZGVOYW1lLm1hdGNoKC9eKHNjcmlwdHwjLio/KSQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggKz0gdGhpcy5jc3NEZXNjcmlwdG9yKHNpYmxpbmdzW2pdKSArIChqICsgMSA9PT0gc2libGluZ3MubGVuZ3RoID8gXCIrIFwiIDogXCJ+IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aCArPSB0aGlzLmNzc0Rlc2NyaXB0b3IoZSkgKyBcIiA+IFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsZWFuQ3NzKHBhdGgpO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuY3NzRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGNzc05hbWUsIGVzY2FwZWQsIHBhdGgsIF9pLCBfbGVuLCBfcmVmO1xuICAgIHBhdGggPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgZXNjYXBlZCA9IG5vZGUuaWQgJiYgdGhpcy5lc2NhcGVDc3NOYW1lcyhuZXcgU3RyaW5nKG5vZGUuaWQpKTtcbiAgICBpZiAoZXNjYXBlZCAmJiBlc2NhcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGF0aCArPSAnIycgKyBlc2NhcGVkO1xuICAgIH1cbiAgICBpZiAobm9kZS5jbGFzc05hbWUpIHtcbiAgICAgICAgX3JlZiA9IG5vZGUuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBjc3NOYW1lID0gX3JlZltfaV07XG4gICAgICAgICAgICBlc2NhcGVkID0gdGhpcy5lc2NhcGVDc3NOYW1lcyhjc3NOYW1lKTtcbiAgICAgICAgICAgIGlmIChjc3NOYW1lICYmIGVzY2FwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gJy4nICsgZXNjYXBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImJvZHlcIikge1xuICAgICAgICBwYXRoICs9ICc6bnRoLWNoaWxkKCcgKyAodGhpcy5jaGlsZEVsZW1OdW1iZXIobm9kZSkgKyAxKSArICcpJztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5jc3NEaWZmID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGNvbGxlY3RpdmVfY29tbW9uLCBjc3NFbGVtLCBkaWZmLCBkbXAsIGVuY29kZWRfY3NzX2FycmF5LCBleGlzdGluZ190b2tlbnMsIHBhcnQsIF9pLCBfaiwgX2xlbiwgX2xlbjE7XG4gICAgdHJ5IHtcbiAgICAgICAgZG1wID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2goKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IFwiUGxlYXNlIGluY2x1ZGUgdGhlIGRpZmZfbWF0Y2hfcGF0Y2ggbGlicmFyeS5cIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcnJheSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZXhpc3RpbmdfdG9rZW5zID0ge307XG4gICAgZW5jb2RlZF9jc3NfYXJyYXkgPSB0aGlzLmVuY29kZUNzc0ZvckRpZmYoYXJyYXksIGV4aXN0aW5nX3Rva2Vucyk7XG4gICAgY29sbGVjdGl2ZV9jb21tb24gPSBlbmNvZGVkX2Nzc19hcnJheS5wb3AoKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGVuY29kZWRfY3NzX2FycmF5Lmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGNzc0VsZW0gPSBlbmNvZGVkX2Nzc19hcnJheVtfaV07XG4gICAgICAgIGRpZmYgPSBkbXAuZGlmZl9tYWluKGNvbGxlY3RpdmVfY29tbW9uLCBjc3NFbGVtKTtcbiAgICAgICAgY29sbGVjdGl2ZV9jb21tb24gPSAnJztcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gZGlmZi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIHBhcnQgPSBkaWZmW19qXTtcbiAgICAgICAgICAgIGlmIChwYXJ0WzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGl2ZV9jb21tb24gKz0gcGFydFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZWNvZGVDc3MoY29sbGVjdGl2ZV9jb21tb24sIGV4aXN0aW5nX3Rva2Vucyk7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS50b2tlbml6ZUNzcyA9IGZ1bmN0aW9uIChjc3Nfc3RyaW5nKSB7XG4gICAgdmFyIGNoYXIsIHNraXAsIHRva2Vucywgd29yZCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgc2tpcCA9IGZhbHNlO1xuICAgIHdvcmQgPSAnJztcbiAgICB0b2tlbnMgPSBbXTtcbiAgICBfcmVmID0gdGhpcy5jbGVhbkNzcyhjc3Nfc3RyaW5nKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgY2hhciA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJy4nIHx8IGNoYXIgPT09ICcgJyB8fCBjaGFyID09PSAnIycgfHwgY2hhciA9PT0gJz4nIHx8IGNoYXIgPT09ICc6JyB8fCBjaGFyID09PSAnLCcgfHwgY2hhciA9PT0gJysnIHx8IGNoYXIgPT09ICd+Jykge1xuICAgICAgICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHdvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29yZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHdvcmQgKz0gY2hhcjtcbiAgICAgICAgaWYgKGNoYXIgPT09ICcgJyB8fCBjaGFyID09PSAnLCcpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHdvcmQpO1xuICAgICAgICAgICAgd29yZCA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3b3JkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdG9rZW5zLnB1c2god29yZCk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS50b2tlbml6ZUNzc0ZvckRpZmYgPSBmdW5jdGlvbiAoY3NzX3N0cmluZykge1xuICAgIHZhciBibG9jaywgY29tYmluZWRfdG9rZW5zLCB0b2tlbiwgX2ksIF9sZW4sIF9yZWY7XG4gICAgY29tYmluZWRfdG9rZW5zID0gW107XG4gICAgYmxvY2sgPSBbXTtcbiAgICBfcmVmID0gdGhpcy50b2tlbml6ZUNzcyhjc3Nfc3RyaW5nKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgdG9rZW4gPSBfcmVmW19pXTtcbiAgICAgICAgYmxvY2sucHVzaCh0b2tlbik7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gJyAnICYmIGJsb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbWJpbmVkX3Rva2VucyA9IGNvbWJpbmVkX3Rva2Vucy5jb25jYXQoYmxvY2spO1xuICAgICAgICAgICAgYmxvY2sgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJysnIHx8IHRva2VuID09PSAnficpIHtcbiAgICAgICAgICAgIGJsb2NrID0gW2Jsb2NrLmpvaW4oJycpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmxvY2subGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gY29tYmluZWRfdG9rZW5zLmNvbmNhdChibG9jayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkX3Rva2VucztcbiAgICB9XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5kZWNvZGVDc3MgPSBmdW5jdGlvbiAoc3RyaW5nLCBleGlzdGluZ190b2tlbnMpIHtcbiAgICB2YXIgY2hhcmFjdGVyLCBpbnZlcnRlZCwgb3V0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpbnZlcnRlZCA9IHRoaXMuaW52ZXJ0T2JqZWN0KGV4aXN0aW5nX3Rva2Vucyk7XG4gICAgb3V0ID0gJyc7XG4gICAgX3JlZiA9IHN0cmluZy5zcGxpdCgnJyk7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGNoYXJhY3RlciA9IF9yZWZbX2ldO1xuICAgICAgICBvdXQgKz0gaW52ZXJ0ZWRbY2hhcmFjdGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xlYW5Dc3Mob3V0KTtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLmVuY29kZUNzc0ZvckRpZmYgPSBmdW5jdGlvbiAoc3RyaW5ncywgZXhpc3RpbmdfdG9rZW5zKSB7XG4gICAgdmFyIGNvZGVwb2ludCwgb3V0LCBzdHJpbmcsIHN0cmluZ3Nfb3V0LCB0b2tlbiwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjtcbiAgICBjb2RlcG9pbnQgPSA1MDtcbiAgICBzdHJpbmdzX291dCA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc3RyaW5ncy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmdzW19pXTtcbiAgICAgICAgb3V0ID0gbmV3IFN0cmluZygpO1xuICAgICAgICBfcmVmID0gdGhpcy50b2tlbml6ZUNzc0ZvckRpZmYoc3RyaW5nKTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gX3JlZltfal07XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nX3Rva2Vuc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ190b2tlbnNbdG9rZW5dID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlcG9pbnQrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gZXhpc3RpbmdfdG9rZW5zW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmdzX291dC5wdXNoKG91dCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdzX291dDtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLnRva2VuUHJpb3JpdGllcyA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgICB2YXIgZXBzaWxvbiwgZmlyc3QsIGksIHByaW9yaXRpZXMsIHNlY29uZCwgdG9rZW4sIF9pLCBfbGVuO1xuICAgIGVwc2lsb24gPSAwLjAwMTtcbiAgICBwcmlvcml0aWVzID0gbmV3IEFycmF5KCk7XG4gICAgaSA9IDA7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0b2tlbnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbX2ldO1xuICAgICAgICBmaXJzdCA9IHRva2VuLnN1YnN0cmluZygwLCAxKTtcbiAgICAgICAgc2Vjb25kID0gdG9rZW4uc3Vic3RyaW5nKDEsIDIpO1xuICAgICAgICBpZiAoZmlyc3QgPT09ICc6JyAmJiBzZWNvbmQgPT09ICduJykge1xuICAgICAgICAgICAgcHJpb3JpdGllc1tpXSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09ICc+Jykge1xuICAgICAgICAgICAgcHJpb3JpdGllc1tpXSA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09ICcrJyB8fCBmaXJzdCA9PT0gJ34nKSB7XG4gICAgICAgICAgICBwcmlvcml0aWVzW2ldID0gMztcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdCAhPT0gJzonICYmIGZpcnN0ICE9PSAnLicgJiYgZmlyc3QgIT09ICcjJyAmJiBmaXJzdCAhPT0gJyAnICYmIGZpcnN0ICE9PSAnPicgJiYgZmlyc3QgIT09ICcrJyAmJiBmaXJzdCAhPT0gJ34nKSB7XG4gICAgICAgICAgICBwcmlvcml0aWVzW2ldID0gNDtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBwcmlvcml0aWVzW2ldID0gNTtcbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdCA9ICcjJykge1xuICAgICAgICAgICAgcHJpb3JpdGllc1tpXSA9IDY7XG4gICAgICAgICAgICBpZiAodG9rZW4ubWF0Y2goL1xcZHszLH0vKSkge1xuICAgICAgICAgICAgICAgIHByaW9yaXRpZXNbaV0gPSAyLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmlvcml0aWVzW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwcmlvcml0aWVzW2ldICs9IGkgKiBlcHNpbG9uO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBwcmlvcml0aWVzO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUub3JkZXJGcm9tUHJpb3JpdGllcyA9IGZ1bmN0aW9uIChwcmlvcml0aWVzKSB7XG4gICAgdmFyIGksIG9yZGVyaW5nLCB0bXAsIF9pLCBfaiwgX3JlZiwgX3JlZjE7XG4gICAgdG1wID0gbmV3IEFycmF5KCk7XG4gICAgb3JkZXJpbmcgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYgPSBwcmlvcml0aWVzLmxlbmd0aDsgMCA8PSBfcmVmID8gX2kgPCBfcmVmIDogX2kgPiBfcmVmOyBpID0gMCA8PSBfcmVmID8gKytfaSA6IC0tX2kpIHtcbiAgICAgICAgdG1wW2ldID0ge1xuICAgICAgICAgICAgdmFsdWU6IHByaW9yaXRpZXNbaV0sXG4gICAgICAgICAgICBvcmlnaW5hbDogaVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0bXAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7XG4gICAgfSk7XG4gICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMSA9IHByaW9yaXRpZXMubGVuZ3RoOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgb3JkZXJpbmdbaV0gPSB0bXBbaV0ub3JpZ2luYWw7XG4gICAgfVxuICAgIHJldHVybiBvcmRlcmluZztcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLnNpbXBsaWZ5Q3NzID0gZnVuY3Rpb24gKGNzcywgc2VsZWN0ZWQsIHJlamVjdGVkKSB7XG4gICAgdmFyIGJlc3Rfc29fZmFyLCBmaXJzdCwgZ290X3Nob3J0ZXIsIGksIGxvb2tfYmFja19pbmRleCwgb3JkZXJpbmcsIHBhcnQsIHBhcnRzLCBwcmlvcml0aWVzLCBzZWNvbmQsIHNlbGVjdG9yLCBfaSwgX3JlZixcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgIHBhcnRzID0gdGhpcy50b2tlbml6ZUNzcyhjc3MpO1xuICAgIHByaW9yaXRpZXMgPSB0aGlzLnRva2VuUHJpb3JpdGllcyhwYXJ0cyk7XG4gICAgb3JkZXJpbmcgPSB0aGlzLm9yZGVyRnJvbVByaW9yaXRpZXMocHJpb3JpdGllcyk7XG4gICAgc2VsZWN0b3IgPSB0aGlzLmNsZWFuQ3NzKGNzcyk7XG4gICAgbG9va19iYWNrX2luZGV4ID0gLTE7XG4gICAgYmVzdF9zb19mYXIgPSBcIlwiO1xuICAgIGlmICh0aGlzLnNlbGVjdG9yR2V0cygnYWxsJywgc2VsZWN0ZWQsIHNlbGVjdG9yKSAmJiB0aGlzLnNlbGVjdG9yR2V0cygnbm9uZScsIHJlamVjdGVkLCBzZWxlY3RvcikpIHtcbiAgICAgICAgYmVzdF9zb19mYXIgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgZ290X3Nob3J0ZXIgPSB0cnVlO1xuICAgIHdoaWxlIChnb3Rfc2hvcnRlcikge1xuICAgICAgICBnb3Rfc2hvcnRlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBfaSA9IDAsIF9yZWYgPSBwYXJ0cy5sZW5ndGg7IDAgPD0gX3JlZiA/IF9pIDwgX3JlZiA6IF9pID4gX3JlZjsgaSA9IDAgPD0gX3JlZiA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgICAgICBwYXJ0ID0gb3JkZXJpbmdbaV07XG4gICAgICAgICAgICBpZiAocGFydHNbcGFydF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdCA9IHBhcnRzW3BhcnRdLnN1YnN0cmluZygwLCAxKTtcbiAgICAgICAgICAgIHNlY29uZCA9IHBhcnRzW3BhcnRdLnN1YnN0cmluZygxLCAyKTtcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy53b3VsZExlYXZlRnJlZUZsb2F0aW5nTnRoQ2hpbGQocGFydHMsIHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhwYXJ0LCBwYXJ0cywgZmlyc3QsIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zZWxlY3RvckdldHMoJ2FsbCcsIHNlbGVjdGVkLCBzZWxlY3RvcikgJiYgX3RoaXMuc2VsZWN0b3JHZXRzKCdub25lJywgcmVqZWN0ZWQsIHNlbGVjdG9yKSAmJiAoc2VsZWN0b3IubGVuZ3RoIDwgYmVzdF9zb19mYXIubGVuZ3RoIHx8IGJlc3Rfc29fZmFyLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdF9zb19mYXIgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgZ290X3Nob3J0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xlYW5Dc3MoYmVzdF9zb19mYXIpO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuX3JlbW92ZUVsZW1lbnRzID0gZnVuY3Rpb24gKHBhcnQsIHBhcnRzLCBmaXJzdENoYXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGosIGxvb2tfYmFja19pbmRleCwgc2VsZWN0b3IsIHRtcCwgX2ksIF9qO1xuICAgIGlmIChmaXJzdENoYXIgPT09ICcrJyB8fCBmaXJzdENoYXIgPT09ICd+Jykge1xuICAgICAgICBsb29rX2JhY2tfaW5kZXggPSB0aGlzLnBvc2l0aW9uT2ZTcGFjZUJlZm9yZUluZGV4T3JMaW5lU3RhcnQocGFydCwgcGFydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvb2tfYmFja19pbmRleCA9IHBhcnQ7XG4gICAgfVxuICAgIHRtcCA9IHBhcnRzLnNsaWNlKGxvb2tfYmFja19pbmRleCwgcGFydCArIDEpO1xuICAgIGZvciAoaiA9IF9pID0gbG9va19iYWNrX2luZGV4OyBsb29rX2JhY2tfaW5kZXggPD0gcGFydCA/IF9pIDw9IHBhcnQgOiBfaSA+PSBwYXJ0OyBqID0gbG9va19iYWNrX2luZGV4IDw9IHBhcnQgPyArK19pIDogLS1faSkge1xuICAgICAgICBwYXJ0c1tqXSA9ICcnO1xuICAgIH1cbiAgICBzZWxlY3RvciA9IHRoaXMuY2xlYW5Dc3MocGFydHMuam9pbignJykpO1xuICAgIGlmIChzZWxlY3RvciA9PT0gJycgfHwgIWNhbGxiYWNrKHNlbGVjdG9yKSkge1xuICAgICAgICBmb3IgKGogPSBfaiA9IGxvb2tfYmFja19pbmRleDsgbG9va19iYWNrX2luZGV4IDw9IHBhcnQgPyBfaiA8PSBwYXJ0IDogX2ogPj0gcGFydDsgaiA9IGxvb2tfYmFja19pbmRleCA8PSBwYXJ0ID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgICAgIHBhcnRzW2pdID0gdG1wW2ogLSBsb29rX2JhY2tfaW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLnBvc2l0aW9uT2ZTcGFjZUJlZm9yZUluZGV4T3JMaW5lU3RhcnQgPSBmdW5jdGlvbiAocGFydCwgcGFydHMpIHtcbiAgICB2YXIgaTtcbiAgICBpID0gcGFydDtcbiAgICB3aGlsZSAoaSA+PSAwICYmIHBhcnRzW2ldICE9PSAnICcpIHtcbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgaSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBpO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUud291bGRMZWF2ZUZyZWVGbG9hdGluZ050aENoaWxkID0gZnVuY3Rpb24gKHBhcnRzLCBwYXJ0KSB7XG4gICAgdmFyIGksIG50aF9jaGlsZF9pc19vbl9yaWdodCwgc3BhY2VfaXNfb25fbGVmdDtcbiAgICBzcGFjZV9pc19vbl9sZWZ0ID0gbnRoX2NoaWxkX2lzX29uX3JpZ2h0ID0gZmFsc2U7XG4gICAgaSA9IHBhcnQgKyAxO1xuICAgIHdoaWxlIChpIDwgcGFydHMubGVuZ3RoICYmIHBhcnRzW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIGlmIChpIDwgcGFydHMubGVuZ3RoICYmIHBhcnRzW2ldLnN1YnN0cmluZygwLCAyKSA9PT0gJzpuJykge1xuICAgICAgICBudGhfY2hpbGRfaXNfb25fcmlnaHQgPSB0cnVlO1xuICAgIH1cbiAgICBpID0gcGFydCAtIDE7XG4gICAgd2hpbGUgKGkgPiAtMSAmJiBwYXJ0c1tpXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoaSA8IDAgfHwgcGFydHNbaV0gPT09ICcgJykge1xuICAgICAgICBzcGFjZV9pc19vbl9sZWZ0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlX2lzX29uX2xlZnQgJiYgbnRoX2NoaWxkX2lzX29uX3JpZ2h0O1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuY2xlYW5Dc3MgPSBmdW5jdGlvbiAoY3NzKSB7XG4gICAgdmFyIGNsZWFuZWRfY3NzLCBsYXN0X2NsZWFuZWRfY3NzO1xuICAgIGNsZWFuZWRfY3NzID0gY3NzO1xuICAgIGxhc3RfY2xlYW5lZF9jc3MgPSBudWxsO1xuICAgIHdoaWxlIChsYXN0X2NsZWFuZWRfY3NzICE9PSBjbGVhbmVkX2Nzcykge1xuICAgICAgICBsYXN0X2NsZWFuZWRfY3NzID0gY2xlYW5lZF9jc3M7XG4gICAgICAgIGNsZWFuZWRfY3NzID0gY2xlYW5lZF9jc3MucmVwbGFjZSgvKF58XFxzKykoXFwrfFxcfikvLCAnJykucmVwbGFjZSgvKFxcK3xcXH4pXFxzKiQvLCAnJykucmVwbGFjZSgvPi9nLCAnID4gJykucmVwbGFjZSgvXFxzKig+XFxzKikrL2csICcgPiAnKS5yZXBsYWNlKC8sL2csICcgLCAnKS5yZXBsYWNlKC9cXHMrL2csICcgJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpLnJlcGxhY2UoL1xccyosJC9nLCAnJykucmVwbGFjZSgvXlxccyosXFxzKi9nLCAnJykucmVwbGFjZSgvXFxzKj4kL2csICcnKS5yZXBsYWNlKC9ePlxccyovZywgJycpLnJlcGxhY2UoL1tcXCtcXH5cXD5dXFxzKiwvZywgJywnKS5yZXBsYWNlKC9bXFwrXFx+XVxccyo+L2csICc+JykucmVwbGFjZSgvXFxzKigsXFxzKikrL2csICcgLCAnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuZWRfY3NzO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuZ2V0UGF0aHNGb3IgPSBmdW5jdGlvbiAobm9kZXNldCkge1xuICAgIHZhciBub2RlLCBvdXQsIF9pLCBfbGVuO1xuICAgIG91dCA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gbm9kZXNldC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBub2RlID0gbm9kZXNldFtfaV07XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUubm9kZU5hbWUpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHRoaXMucGF0aE9mKG5vZGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUucHJlZGljdENzcyA9IGZ1bmN0aW9uIChzLCByKSB7XG4gICAgdmFyIGNzcywgc2VsZWN0ZWQsIHNlbGVjdGVkX3BhdGhzLCBzaW1wbGVzdCwgdW5pb24sIF9pLCBfbGVuO1xuICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHNlbGVjdGVkX3BhdGhzID0gdGhpcy5nZXRQYXRoc0ZvcihzKTtcbiAgICBjc3MgPSB0aGlzLmNzc0RpZmYoc2VsZWN0ZWRfcGF0aHMpO1xuICAgIHNpbXBsZXN0ID0gdGhpcy5zaW1wbGlmeUNzcyhjc3MsIHMsIHIpO1xuICAgIGlmIChzaW1wbGVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVzdDtcbiAgICB9XG4gICAgdW5pb24gPSAnJztcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBzW19pXTtcbiAgICAgICAgdW5pb24gPSB0aGlzLnBhdGhPZihzZWxlY3RlZCkgKyBcIiwgXCIgKyB1bmlvbjtcbiAgICB9XG4gICAgdW5pb24gPSB0aGlzLmNsZWFuQ3NzKHVuaW9uKTtcbiAgICByZXR1cm4gdGhpcy5zaW1wbGlmeUNzcyh1bmlvbiwgcywgcik7XG59O1xuXG5Eb21QcmVkaWN0aW9uSGVscGVyLnByb3RvdHlwZS5zZWxlY3RvckdldHMgPSBmdW5jdGlvbiAodHlwZSwgbGlzdCwgdGhlX3NlbGVjdG9yKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwICYmIHR5cGUgPT09ICdhbGwnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwICYmIHR5cGUgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5ub3QodGhlX3NlbGVjdG9yKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gIShsaXN0LmlzKHRoZV9zZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igb24gc2VsZWN0b3I6IFwiICsgdGhlX3NlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLmludmVydE9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5LCBuZXdfb2JqZWN0LCB2YWx1ZTtcbiAgICBuZXdfb2JqZWN0ID0ge307XG4gICAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIG5ld19vYmplY3RbdmFsdWVdID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gbmV3X29iamVjdDtcbn07XG5cbkRvbVByZWRpY3Rpb25IZWxwZXIucHJvdG90eXBlLmNzc1RvWFBhdGggPSBmdW5jdGlvbiAoY3NzX3N0cmluZykge1xuICAgIHZhciBjc3NfYmxvY2ssIG91dCwgdG9rZW4sIHRva2VucywgX2ksIF9sZW47XG4gICAgdG9rZW5zID0gdGhpcy50b2tlbml6ZUNzcyhjc3Nfc3RyaW5nKTtcbiAgICBpZiAodG9rZW5zWzBdICYmIHRva2Vuc1swXSA9PT0gJyAnKSB7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIGlmICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKHRva2Vucy5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG4gICAgY3NzX2Jsb2NrID0gW107XG4gICAgb3V0ID0gXCJcIjtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHRva2Vucy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tfaV07XG4gICAgICAgIGlmICh0b2tlbiA9PT0gJyAnKSB7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5jc3NUb1hQYXRoQmxvY2tIZWxwZXIoY3NzX2Jsb2NrKTtcbiAgICAgICAgICAgIGNzc19ibG9jayA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzX2Jsb2NrLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQgKyB0aGlzLmNzc1RvWFBhdGhCbG9ja0hlbHBlcihjc3NfYmxvY2spO1xufTtcblxuRG9tUHJlZGljdGlvbkhlbHBlci5wcm90b3R5cGUuY3NzVG9YUGF0aEJsb2NrSGVscGVyID0gZnVuY3Rpb24gKGNzc19ibG9jaykge1xuICAgIHZhciBjdXJyZW50LCBleHByZXNzaW9ucywgZmlyc3QsIGksIG91dCwgcmUsIHJlc3QsIF9pLCBfaiwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY3NzX2Jsb2NrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJy8vJztcbiAgICB9XG4gICAgb3V0ID0gJy8vJztcbiAgICBmaXJzdCA9IGNzc19ibG9ja1swXS5zdWJzdHJpbmcoMCwgMSk7XG4gICAgaWYgKGZpcnN0ID09PSAnLCcpIHtcbiAgICAgICAgcmV0dXJuIFwiIHwgXCI7XG4gICAgfVxuICAgIGlmIChmaXJzdCA9PT0gJzonIHx8IGZpcnN0ID09PSAnIycgfHwgZmlyc3QgPT09ICcuJykge1xuICAgICAgICBvdXQgKz0gJyonO1xuICAgIH1cbiAgICBleHByZXNzaW9ucyA9IFtdO1xuICAgIHJlID0gbnVsbDtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNzc19ibG9jay5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjdXJyZW50ID0gY3NzX2Jsb2NrW19pXTtcbiAgICAgICAgZmlyc3QgPSBjdXJyZW50LnN1YnN0cmluZygwLCAxKTtcbiAgICAgICAgcmVzdCA9IGN1cnJlbnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAoZmlyc3QgPT09ICc6Jykge1xuICAgICAgICAgICAgaWYgKHJlID0gcmVzdC5tYXRjaCgvXm50aC1jaGlsZFxcKChcXGQrKVxcKSQvKSkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goJygoKGNvdW50KHByZWNlZGluZy1zaWJsaW5nOjoqKSArIDEpID0gJyArIHJlWzFdICsgJykgYW5kIHBhcmVudDo6KiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCdjb250YWlucyhjb25jYXQoIFwiIFwiLCBAY2xhc3MsIFwiIFwiICksIGNvbmNhdCggXCIgXCIsIFwiJyArIHJlc3QgKyAnXCIsIFwiIFwiICkpJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09ICcjJykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCgnKEBpZCA9IFwiJyArIHJlc3QgKyAnXCIpJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09ICcsJykge1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gY3VycmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBvdXQgKz0gJ1snO1xuICAgIH1cbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYgPSBleHByZXNzaW9ucy5sZW5ndGg7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgaSA9IDAgPD0gX3JlZiA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgIG91dCArPSBleHByZXNzaW9uc1tpXTtcbiAgICAgICAgaWYgKGkgPCBleHByZXNzaW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBhbmQgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBvdXQgKz0gJ10nO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbiIsIi8qKlxuICogRGlmZiBNYXRjaCBhbmQgUGF0Y2hcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNiBHb29nbGUgSW5jLlxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbXB1dGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHRleHRzIHRvIGNyZWF0ZSBhIHBhdGNoLlxuICogQXBwbGllcyB0aGUgcGF0Y2ggb250byBhbm90aGVyIHRleHQsIGFsbG93aW5nIGZvciBlcnJvcnMuXG4gKiBAYXV0aG9yIGZyYXNlckBnb29nbGUuY29tIChOZWlsIEZyYXNlcilcbiAqL1xuXG4vKipcbiAqIENsYXNzIGNvbnRhaW5pbmcgdGhlIGRpZmYsIG1hdGNoIGFuZCBwYXRjaCBtZXRob2RzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIGRpZmZfbWF0Y2hfcGF0Y2goKSB7XG5cbiAgLy8gRGVmYXVsdHMuXG4gIC8vIFJlZGVmaW5lIHRoZXNlIGluIHlvdXIgcHJvZ3JhbSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG5cbiAgLy8gTnVtYmVyIG9mIHNlY29uZHMgdG8gbWFwIGEgZGlmZiBiZWZvcmUgZ2l2aW5nIHVwLiAgKDAgZm9yIGluZmluaXR5KVxuICB0aGlzLkRpZmZfVGltZW91dCA9IDEuMDtcbiAgLy8gQ29zdCBvZiBhbiBlbXB0eSBlZGl0IG9wZXJhdGlvbiBpbiB0ZXJtcyBvZiBlZGl0IGNoYXJhY3RlcnMuXG4gIHRoaXMuRGlmZl9FZGl0Q29zdCA9IDQ7XG4gIC8vIFRoZSBzaXplIGJleW9uZCB3aGljaCB0aGUgZG91YmxlLWVuZGVkIGRpZmYgYWN0aXZhdGVzLlxuICAvLyBEb3VibGUtZW5kaW5nIGlzIHR3aWNlIGFzIGZhc3QsIGJ1dCBsZXNzIGFjY3VyYXRlLlxuICB0aGlzLkRpZmZfRHVhbFRocmVzaG9sZCA9IDMyO1xuICAvLyBUd2VhayB0aGUgcmVsYXRpdmUgaW1wb3J0YW5jZSAoMC4wID0gYWNjdXJhY3ksIDEuMCA9IHByb3hpbWl0eSlcbiAgdGhpcy5NYXRjaF9CYWxhbmNlID0gMC41O1xuICAvLyBBdCB3aGF0IHBvaW50IGlzIG5vIG1hdGNoIGRlY2xhcmVkICgwLjAgPSBwZXJmZWN0aW9uLCAxLjAgPSB2ZXJ5IGxvb3NlKVxuICB0aGlzLk1hdGNoX1RocmVzaG9sZCA9IDAuNTtcbiAgLy8gVGhlIG1pbiBhbmQgbWF4IGN1dG9mZnMgdXNlZCB3aGVuIGNvbXB1dGluZyB0ZXh0IGxlbmd0aHMuXG4gIHRoaXMuTWF0Y2hfTWluTGVuZ3RoID0gMTAwO1xuICB0aGlzLk1hdGNoX01heExlbmd0aCA9IDEwMDA7XG4gIC8vIENodW5rIHNpemUgZm9yIGNvbnRleHQgbGVuZ3RoLlxuICB0aGlzLlBhdGNoX01hcmdpbiA9IDQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cbiAgICogVGhlIG5vcm1hbCBhbnN3ZXIgZm9yIEphdmFTY3JpcHQgaXMgMzIuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWF4IGJpdHNcbiAgICovXG4gIGZ1bmN0aW9uIGdldE1heEJpdHMoKSB7XG4gICAgdmFyIG1heGJpdHMgPSAwO1xuICAgIHZhciBvbGRpID0gMTtcbiAgICB2YXIgbmV3aSA9IDI7XG4gICAgd2hpbGUgKG9sZGkgIT0gbmV3aSkge1xuICAgICAgbWF4Yml0cysrO1xuICAgICAgb2xkaSA9IG5ld2k7XG4gICAgICBuZXdpID0gbmV3aSA8PCAxO1xuICAgIH1cbiAgICByZXR1cm4gbWF4Yml0cztcbiAgfVxuICAvLyBIb3cgbWFueSBiaXRzIGluIGEgbnVtYmVyP1xuICB0aGlzLk1hdGNoX01heEJpdHMgPSBnZXRNYXhCaXRzKCk7XG59XG5cblxuLy8gIERJRkYgRlVOQ1RJT05TXG5cblxuLyoqXG4gKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XG4gKiBbW0RJRkZfREVMRVRFLCAnSGVsbG8nXSwgW0RJRkZfSU5TRVJULCAnR29vZGJ5ZSddLCBbRElGRl9FUVVBTCwgJyB3b3JsZC4nXV1cbiAqIHdoaWNoIG1lYW5zOiBkZWxldGUgJ0hlbGxvJywgYWRkICdHb29kYnllJyBhbmQga2VlcCAnIHdvcmxkLidcbiAqL1xudmFyIERJRkZfREVMRVRFID0gLTE7XG52YXIgRElGRl9JTlNFUlQgPSAxO1xudmFyIERJRkZfRVFVQUwgPSAwO1xuXG5cbi8qKlxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBTaW1wbGlmaWVzIHRoZSBwcm9ibGVtIGJ5IHN0cmlwcGluZ1xuICogYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4IG9mZiB0aGUgdGV4dHMgYmVmb3JlIGRpZmZpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZFxuICogQHBhcmFtIHtib29sZWFufSBvcHRfY2hlY2tsaW5lcyBPcHRpb25hbCBzcGVlZHVwIGZsYWcuICBJZiBwcmVzZW50IGFuZCBmYWxzZSxcbiAqICAgICB0aGVuIGRvbid0IHJ1biBhIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cbiAqICAgICBEZWZhdWx0cyB0byB0cnVlLCB3aGljaCBkb2VzIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjwqPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbWFpbiA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIsIG9wdF9jaGVja2xpbmVzKSB7XG4gIC8vIENoZWNrIGZvciBlcXVhbGl0eSAoc3BlZWR1cClcbiAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgcmV0dXJuIFtbRElGRl9FUVVBTCwgdGV4dDFdXTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0X2NoZWNrbGluZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRfY2hlY2tsaW5lcyA9IHRydWU7XG4gIH1cbiAgdmFyIGNoZWNrbGluZXMgPSBvcHRfY2hlY2tsaW5lcztcblxuICAvLyBUcmltIG9mZiBjb21tb24gcHJlZml4IChzcGVlZHVwKVxuICB2YXIgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICB2YXIgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG5cbiAgLy8gVHJpbSBvZmYgY29tbW9uIHN1ZmZpeCAoc3BlZWR1cClcbiAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICB2YXIgY29tbW9uc3VmZml4ID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKDAsIHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBvbiB0aGUgbWlkZGxlIGJsb2NrXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9jb21wdXRlKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcyk7XG5cbiAgLy8gUmVzdG9yZSB0aGUgcHJlZml4IGFuZCBzdWZmaXhcbiAgaWYgKGNvbW1vbnByZWZpeCkge1xuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pO1xuICB9XG4gIGlmIChjb21tb25zdWZmaXgpIHtcbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBjb21tb25zdWZmaXhdKTtcbiAgfVxuICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgQXNzdW1lcyB0aGF0IHRoZSB0ZXh0cyBkbyBub3RcbiAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tsaW5lcyBTcGVlZHVwIGZsYWcuICBJZiBmYWxzZSwgdGhlbiBkb24ndCBydW4gYVxuICogICAgIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cbiAqICAgICBJZiB0cnVlLCB0aGVuIHJ1biBhIGZhc3Rlciwgc2xpZ2h0bHkgbGVzcyBvcHRpbWFsIGRpZmZcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48Kj4+fSBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21wdXRlID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcykge1xuICB2YXIgZGlmZnM7XG5cbiAgaWYgKCF0ZXh0MSkge1xuICAgIC8vIEp1c3QgYWRkIHNvbWUgdGV4dCAoc3BlZWR1cClcbiAgICByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgfVxuXG4gIGlmICghdGV4dDIpIHtcbiAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XG4gIH1cblxuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgdmFyIGkgPSBsb25ndGV4dC5pbmRleE9mKHNob3J0dGV4dCk7XG4gIGlmIChpICE9IC0xKSB7XG4gICAgLy8gU2hvcnRlciB0ZXh0IGlzIGluc2lkZSB0aGUgbG9uZ2VyIHRleHQgKHNwZWVkdXApXG4gICAgZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLFxuICAgIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLFxuICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dO1xuICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZnM7XG4gIH1cbiAgbG9uZ3RleHQgPSBzaG9ydHRleHQgPSBudWxsOyAgLy8gR2FyYmFnZSBjb2xsZWN0XG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gIHZhciBobSA9IHRoaXMuZGlmZl9oYWxmTWF0Y2godGV4dDEsIHRleHQyKTtcbiAgaWYgKGhtKSB7XG4gICAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICAgIHZhciB0ZXh0MV9hID0gaG1bMF07XG4gICAgdmFyIHRleHQxX2IgPSBobVsxXTtcbiAgICB2YXIgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHZhciB0ZXh0Ml9iID0gaG1bM107XG4gICAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgICAvLyBTZW5kIGJvdGggcGFpcnMgb2ZmIGZvciBzZXBhcmF0ZSBwcm9jZXNzaW5nLlxuICAgIHZhciBkaWZmc19hID0gdGhpcy5kaWZmX21haW4odGV4dDFfYSwgdGV4dDJfYSwgY2hlY2tsaW5lcyk7XG4gICAgdmFyIGRpZmZzX2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MV9iLCB0ZXh0Ml9iLCBjaGVja2xpbmVzKTtcbiAgICAvLyBNZXJnZSB0aGUgcmVzdWx0cy5cbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRfY29tbW9uXV0sIGRpZmZzX2IpO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhIHJlYWwgZGlmZi5cbiAgaWYgKGNoZWNrbGluZXMgJiYgKHRleHQxLmxlbmd0aCA8IDEwMCB8fCB0ZXh0Mi5sZW5ndGggPCAxMDApKSB7XG4gICAgLy8gVG9vIHRyaXZpYWwgZm9yIHRoZSBvdmVyaGVhZC5cbiAgICBjaGVja2xpbmVzID0gZmFsc2U7XG4gIH1cbiAgdmFyIGxpbmVhcnJheTtcbiAgaWYgKGNoZWNrbGluZXMpIHtcbiAgICAvLyBTY2FuIHRoZSB0ZXh0IG9uIGEgbGluZS1ieS1saW5lIGJhc2lzIGZpcnN0LlxuICAgIHZhciBhID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICAgIHRleHQxID0gYVswXTtcbiAgICB0ZXh0MiA9IGFbMV07XG4gICAgbGluZWFycmF5ID0gYVsyXTtcbiAgfVxuICBkaWZmcyA9IHRoaXMuZGlmZl9tYXAodGV4dDEsIHRleHQyKTtcbiAgaWYgKCFkaWZmcykge1xuICAgIC8vIE5vIGFjY2VwdGFibGUgcmVzdWx0LlxuICAgIGRpZmZzID0gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIH1cbiAgaWYgKGNoZWNrbGluZXMpIHtcbiAgICAvLyBDb252ZXJ0IHRoZSBkaWZmIGJhY2sgdG8gb3JpZ2luYWwgdGV4dC5cbiAgICB0aGlzLmRpZmZfY2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lYXJyYXkpO1xuICAgIC8vIEVsaW1pbmF0ZSBmcmVhayBtYXRjaGVzIChlLmcuIGJsYW5rIGxpbmVzKVxuICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xuXG4gICAgLy8gUmVkaWZmIGFueSByZXBsYWNlbWVudCBibG9ja3MsIHRoaXMgdGltZSBjaGFyYWN0ZXItYnktY2hhcmFjdGVyLlxuICAgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTtcbiAgICB2YXIgcG9pbnRlciA9IDA7XG4gICAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gICAgdmFyIHRleHRfZGVsZXRlID0gJyc7XG4gICAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA+PSAxICYmIGNvdW50X2luc2VydCA+PSAxKSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfbWFpbih0ZXh0X2RlbGV0ZSwgdGV4dF9pbnNlcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gYS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciArIGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcG9pbnRlcisrO1xuICAgIH1cbiAgICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgfVxuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8qKlxuICogU3BsaXQgdHdvIHRleHRzIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcbiAqIGhhc2hlcyB3aGVyZSBlYWNoIFVuaWNvZGUgY2hhcmFjdGVyIHJlcHJlc2VudHMgb25lIGxpbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZ1xuICogQHJldHVybiB7QXJyYXkuPHN0cmluZ3xBcnJheS48c3RyaW5nPj59IFRocmVlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgZW5jb2RlZCB0ZXh0MSwgdGhlIGVuY29kZWQgdGV4dDIgYW5kIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncy4gIFRoZVxuICogICAgIHplcm90aCBlbGVtZW50IG9mIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncyBpcyBpbnRlbnRpb25hbGx5IGJsYW5rLlxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lc1RvQ2hhcnMgPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gIHZhciBsaW5lQXJyYXkgPSBbXTsgIC8vIGUuZy4gbGluZUFycmF5WzRdID09ICdIZWxsb1xcbidcbiAgdmFyIGxpbmVIYXNoID0ge307ICAgLy8gZS5nLiBsaW5lSGFzaFsnSGVsbG9cXG4nXSA9PSA0XG5cbiAgLy8gJ1xceDAwJyBpcyBhIHZhbGlkIGNoYXJhY3RlciwgYnV0IHZhcmlvdXMgZGVidWdnZXJzIGRvbid0IGxpa2UgaXQuXG4gIC8vIFNvIHdlJ2xsIGluc2VydCBhIGp1bmsgZW50cnkgdG8gYXZvaWQgZ2VuZXJhdGluZyBhIG51bGwgY2hhcmFjdGVyLlxuICBsaW5lQXJyYXlbMF0gPSAnJztcblxuICAvKipcbiAgICogU3BsaXQgYSB0ZXh0IGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcbiAgICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cbiAgICogTW9kaWZpZXMgbGluZWFycmF5IGFuZCBsaW5laGFzaCB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU3RyaW5nIHRvIGVuY29kZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBkaWZmX2xpbmVzVG9DaGFyc011bmdlKHRleHQpIHtcbiAgICB2YXIgY2hhcnMgPSAnJztcbiAgICAvLyBXYWxrIHRoZSB0ZXh0LCBwdWxsaW5nIG91dCBhIHN1YnN0cmluZyBmb3IgZWFjaCBsaW5lLlxuICAgIC8vIHRleHQuc3BsaXQoJ1xcbicpIHdvdWxkIHdvdWxkIHRlbXBvcmFyaWx5IGRvdWJsZSBvdXIgbWVtb3J5IGZvb3RwcmludC5cbiAgICAvLyBNb2RpZnlpbmcgdGV4dCB3b3VsZCBjcmVhdGUgbWFueSBsYXJnZSBzdHJpbmdzIHRvIGdhcmJhZ2UgY29sbGVjdC5cbiAgICB2YXIgbGluZVN0YXJ0ID0gMDtcbiAgICB2YXIgbGluZUVuZCA9IC0xO1xuICAgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyaWFibGUgaXMgZmFzdGVyIHRoYW4gbG9va2luZyBpdCB1cC5cbiAgICB2YXIgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMSkge1xuICAgICAgbGluZUVuZCA9IHRleHQuaW5kZXhPZignXFxuJywgbGluZVN0YXJ0KTtcbiAgICAgIGlmIChsaW5lRW5kID09IC0xKSB7XG4gICAgICAgIGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICB2YXIgbGluZSA9IHRleHQuc3Vic3RyaW5nKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xuICAgICAgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XG5cbiAgICAgIGlmIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDpcbiAgICAgICAgKGxpbmVIYXNoW2xpbmVdICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpO1xuICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcbiAgICAgICAgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfVxuXG4gIHZhciBjaGFyczEgPSBkaWZmX2xpbmVzVG9DaGFyc011bmdlKHRleHQxKTtcbiAgdmFyIGNoYXJzMiA9IGRpZmZfbGluZXNUb0NoYXJzTXVuZ2UodGV4dDIpO1xuICByZXR1cm4gW2NoYXJzMSwgY2hhcnMyLCBsaW5lQXJyYXldO1xufTtcblxuXG4vKipcbiAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXG4gKiB0ZXh0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxpbmVBcnJheSBBcnJheSBvZiB1bmlxdWUgc3RyaW5nc1xuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jaGFyc1RvTGluZXMgPSBmdW5jdGlvbiAoZGlmZnMsIGxpbmVBcnJheSkge1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGNoYXJzID0gZGlmZnNbeF1bMV07XG4gICAgdmFyIHRleHQgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNoYXJzLmxlbmd0aDsgeSsrKSB7XG4gICAgICB0ZXh0W3ldID0gbGluZUFycmF5W2NoYXJzLmNoYXJDb2RlQXQoeSldO1xuICAgIH1cbiAgICBkaWZmc1t4XVsxXSA9IHRleHQuam9pbignJyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBFeHBsb3JlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGJldHdlZW4gdGhlIHR3byB0ZXh0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPCo+Pj99IEFycmF5IG9mIGRpZmYgdHVwbGVzIG9yIG51bGwgaWYgbm8gZGlmZlxuICogICAgIGF2YWlsYWJsZVxuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9tYXAgPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gIC8vIERvbid0IHJ1biBmb3IgdG9vIGxvbmcuXG4gIHZhciBtc19lbmQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICsgdGhpcy5EaWZmX1RpbWVvdXQgKiAxMDAwO1xuICB2YXIgbWF4X2QgPSB0ZXh0MS5sZW5ndGggKyB0ZXh0Mi5sZW5ndGggLSAxO1xuICB2YXIgZG91YmxlRW5kID0gdGhpcy5EaWZmX0R1YWxUaHJlc2hvbGQgKiAyIDwgbWF4X2Q7XG4gIHZhciB2X21hcDEgPSBbXTtcbiAgdmFyIHZfbWFwMiA9IFtdO1xuICB2YXIgdjEgPSB7fTtcbiAgdmFyIHYyID0ge307XG4gIHYxWzFdID0gMDtcbiAgdjJbMV0gPSAwO1xuICB2YXIgeCwgeTtcbiAgdmFyIGZvb3RzdGVwOyAgLy8gVXNlZCB0byB0cmFjayBvdmVybGFwcGluZyBwYXRocy5cbiAgdmFyIGZvb3RzdGVwcyA9IHt9O1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICAvLyBTYWZhcmkgMS54IGRvZXNuJ3QgaGF2ZSBoYXNPd25Qcm9wZXJ0eVxuICB2YXIgaGFzT3duUHJvcGVydHkgPSAhIShmb290c3RlcHMuaGFzT3duUHJvcGVydHkpO1xuICAvLyBJZiB0aGUgdG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaXMgb2RkLCB0aGVuIHRoZSBmcm9udCBwYXRoIHdpbGwgY29sbGlkZVxuICAvLyB3aXRoIHRoZSByZXZlcnNlIHBhdGguXG4gIHZhciBmcm9udCA9ICh0ZXh0MS5sZW5ndGggKyB0ZXh0Mi5sZW5ndGgpICUgMjtcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XG4gICAgLy8gQmFpbCBvdXQgaWYgdGltZW91dCByZWFjaGVkLlxuICAgIGlmICh0aGlzLkRpZmZfVGltZW91dCA+IDAgJiYgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSA+IG1zX2VuZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gV2FsayB0aGUgZnJvbnQgcGF0aCBvbmUgc3RlcC5cbiAgICB2X21hcDFbZF0gPSB7fTtcbiAgICBmb3IgKHZhciBrID0gLWQ7IGsgPD0gZDsgayArPSAyKSB7XG4gICAgICBpZiAoayA9PSAtZCB8fCBrICE9IGQgJiYgdjFbayAtIDFdIDwgdjFbayArIDFdKSB7XG4gICAgICAgIHggPSB2MVtrICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdjFbayAtIDFdICsgMTtcbiAgICAgIH1cbiAgICAgIHkgPSB4IC0gaztcbiAgICAgIGlmIChkb3VibGVFbmQpIHtcbiAgICAgICAgZm9vdHN0ZXAgPSB4ICsgJywnICsgeTtcbiAgICAgICAgaWYgKGZyb250ICYmIChoYXNPd25Qcm9wZXJ0eSA/IGZvb3RzdGVwcy5oYXNPd25Qcm9wZXJ0eShmb290c3RlcCkgOlxuICAgICAgICAgIChmb290c3RlcHNbZm9vdHN0ZXBdICE9PSB1bmRlZmluZWQpKSkge1xuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZnJvbnQpIHtcbiAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCFkb25lICYmIHggPCB0ZXh0MS5sZW5ndGggJiYgeSA8IHRleHQyLmxlbmd0aCAmJlxuICAgICAgICB0ZXh0MS5jaGFyQXQoeCkgPT0gdGV4dDIuY2hhckF0KHkpKSB7XG4gICAgICAgIHgrKztcbiAgICAgICAgeSsrO1xuICAgICAgICBpZiAoZG91YmxlRW5kKSB7XG4gICAgICAgICAgZm9vdHN0ZXAgPSB4ICsgJywnICsgeTtcbiAgICAgICAgICBpZiAoZnJvbnQgJiYgKGhhc093blByb3BlcnR5ID8gZm9vdHN0ZXBzLmhhc093blByb3BlcnR5KGZvb3RzdGVwKSA6XG4gICAgICAgICAgICAoZm9vdHN0ZXBzW2Zvb3RzdGVwXSAhPT0gdW5kZWZpbmVkKSkpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZyb250KSB7XG4gICAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHYxW2tdID0geDtcbiAgICAgIHZfbWFwMVtkXVt4ICsgJywnICsgeV0gPSB0cnVlO1xuICAgICAgaWYgKHggPT0gdGV4dDEubGVuZ3RoICYmIHkgPT0gdGV4dDIubGVuZ3RoKSB7XG4gICAgICAgIC8vIFJlYWNoZWQgdGhlIGVuZCBpbiBzaW5nbGUtcGF0aCBtb2RlLlxuICAgICAgICByZXR1cm4gdGhpcy5kaWZmX3BhdGgxKHZfbWFwMSwgdGV4dDEsIHRleHQyKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAvLyBGcm9udCBwYXRoIHJhbiBvdmVyIHJldmVyc2UgcGF0aC5cbiAgICAgICAgdl9tYXAyID0gdl9tYXAyLnNsaWNlKDAsIGZvb3RzdGVwc1tmb290c3RlcF0gKyAxKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfcGF0aDEodl9tYXAxLCB0ZXh0MS5zdWJzdHJpbmcoMCwgeCksXG4gICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIHkpKTtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KHRoaXMuZGlmZl9wYXRoMih2X21hcDIsIHRleHQxLnN1YnN0cmluZyh4KSxcbiAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcoeSkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZG91YmxlRW5kKSB7XG4gICAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXG4gICAgICB2X21hcDJbZF0gPSB7fTtcbiAgICAgIGZvciAodmFyIGsgPSAtZDsgayA8PSBkOyBrICs9IDIpIHtcbiAgICAgICAgaWYgKGsgPT0gLWQgfHwgayAhPSBkICYmIHYyW2sgLSAxXSA8IHYyW2sgKyAxXSkge1xuICAgICAgICAgIHggPSB2MltrICsgMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHYyW2sgLSAxXSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgeSA9IHggLSBrO1xuICAgICAgICBmb290c3RlcCA9ICh0ZXh0MS5sZW5ndGggLSB4KSArICcsJyArICh0ZXh0Mi5sZW5ndGggLSB5KTtcbiAgICAgICAgaWYgKCFmcm9udCAmJiAoaGFzT3duUHJvcGVydHkgPyBmb290c3RlcHMuaGFzT3duUHJvcGVydHkoZm9vdHN0ZXApIDpcbiAgICAgICAgICAoZm9vdHN0ZXBzW2Zvb3RzdGVwXSAhPT0gdW5kZWZpbmVkKSkpIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICBmb290c3RlcHNbZm9vdHN0ZXBdID0gZDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoIWRvbmUgJiYgeCA8IHRleHQxLmxlbmd0aCAmJiB5IDwgdGV4dDIubGVuZ3RoICYmXG4gICAgICAgICAgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIHggLSAxKSA9PVxuICAgICAgICAgIHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSB5IC0gMSkpIHtcbiAgICAgICAgICB4Kys7XG4gICAgICAgICAgeSsrO1xuICAgICAgICAgIGZvb3RzdGVwID0gKHRleHQxLmxlbmd0aCAtIHgpICsgJywnICsgKHRleHQyLmxlbmd0aCAtIHkpO1xuICAgICAgICAgIGlmICghZnJvbnQgJiYgKGhhc093blByb3BlcnR5ID8gZm9vdHN0ZXBzLmhhc093blByb3BlcnR5KGZvb3RzdGVwKSA6XG4gICAgICAgICAgICAoZm9vdHN0ZXBzW2Zvb3RzdGVwXSAhPT0gdW5kZWZpbmVkKSkpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbnQpIHtcbiAgICAgICAgICAgIGZvb3RzdGVwc1tmb290c3RlcF0gPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2MltrXSA9IHg7XG4gICAgICAgIHZfbWFwMltkXVt4ICsgJywnICsgeV0gPSB0cnVlO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIC8vIFJldmVyc2UgcGF0aCByYW4gb3ZlciBmcm9udCBwYXRoLlxuICAgICAgICAgIHZfbWFwMSA9IHZfbWFwMS5zbGljZSgwLCBmb290c3RlcHNbZm9vdHN0ZXBdICsgMSk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfcGF0aDEodl9tYXAxLCB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0geCksXG4gICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0geSkpO1xuICAgICAgICAgIHJldHVybiBhLmNvbmNhdCh0aGlzLmRpZmZfcGF0aDIodl9tYXAyLFxuICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHgpLFxuICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHkpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gTnVtYmVyIG9mIGRpZmZzIGVxdWFscyBudW1iZXIgb2YgY2hhcmFjdGVycywgbm8gY29tbW9uYWxpdHkgYXQgYWxsLlxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBXb3JrIGZyb20gdGhlIG1pZGRsZSBiYWNrIHRvIHRoZSBzdGFydCB0byBkZXRlcm1pbmUgdGhlIHBhdGguXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSB2X21hcCBBcnJheSBvZiBwYXRocy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIGZyYWdtZW50IHRvIGJlIGRpZmZlZFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgZnJhZ21lbnQgdG8gYmUgZGlmZmVkXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPCo+Pn0gQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfcGF0aDEgPSBmdW5jdGlvbiAodl9tYXAsIHRleHQxLCB0ZXh0Mikge1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgeCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHkgPSB0ZXh0Mi5sZW5ndGg7XG4gIC8qKiBAdHlwZSB7bnVtYmVyP30gKi9cbiAgdmFyIGxhc3Rfb3AgPSBudWxsO1xuICBmb3IgKHZhciBkID0gdl9tYXAubGVuZ3RoIC0gMjsgZCA+PSAwOyBkLS0pIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgaWYgKHZfbWFwW2RdLmhhc093blByb3BlcnR5ID8gdl9tYXBbZF0uaGFzT3duUHJvcGVydHkoKHggLSAxKSArICcsJyArIHkpIDpcbiAgICAgICAgKHZfbWFwW2RdWyh4IC0gMSkgKyAnLCcgKyB5XSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB4LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgIHBhdGhbMF1bMV0gPSB0ZXh0MS5jaGFyQXQoeCkgKyBwYXRoWzBdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChbRElGRl9ERUxFVEUsIHRleHQxLmNoYXJBdCh4KV0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0RFTEVURTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHZfbWFwW2RdLmhhc093blByb3BlcnR5ID9cbiAgICAgICAgdl9tYXBbZF0uaGFzT3duUHJvcGVydHkoeCArICcsJyArICh5IC0gMSkpIDpcbiAgICAgICAgKHZfbWFwW2RdW3ggKyAnLCcgKyAoeSAtIDEpXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB5LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgIHBhdGhbMF1bMV0gPSB0ZXh0Mi5jaGFyQXQoeSkgKyBwYXRoWzBdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChbRElGRl9JTlNFUlQsIHRleHQyLmNoYXJBdCh5KV0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0lOU0VSVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LS07XG4gICAgICAgIHktLTtcbiAgICAgICAgLy9pZiAodGV4dDEuY2hhckF0KHgpICE9IHRleHQyLmNoYXJBdCh5KSkge1xuICAgICAgICAvLyAgdGhyb3cgbmV3IEVycm9yKCdObyBkaWFnb25hbC4gIENhblxcJ3QgaGFwcGVuLiAoZGlmZl9wYXRoMSknKTtcbiAgICAgICAgLy99XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgcGF0aFswXVsxXSA9IHRleHQxLmNoYXJBdCh4KSArIHBhdGhbMF1bMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KFtESUZGX0VRVUFMLCB0ZXh0MS5jaGFyQXQoeCldKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9FUVVBTDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8qKlxuICogV29yayBmcm9tIHRoZSBtaWRkbGUgYmFjayB0byB0aGUgZW5kIHRvIGRldGVybWluZSB0aGUgcGF0aC5cbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHZfbWFwIEFycmF5IG9mIHBhdGhzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgZnJhZ21lbnQgdG8gYmUgZGlmZmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyBmcmFnbWVudCB0byBiZSBkaWZmZWRcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48Kj4+fSBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHByaXZhdGVcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wYXRoMiA9IGZ1bmN0aW9uICh2X21hcCwgdGV4dDEsIHRleHQyKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHZhciBwYXRoTGVuZ3RoID0gMDtcbiAgdmFyIHggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB5ID0gdGV4dDIubGVuZ3RoO1xuICAvKiogQHR5cGUge251bWJlcj99ICovXG4gIHZhciBsYXN0X29wID0gbnVsbDtcbiAgZm9yICh2YXIgZCA9IHZfbWFwLmxlbmd0aCAtIDI7IGQgPj0gMDsgZC0tKSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGlmICh2X21hcFtkXS5oYXNPd25Qcm9wZXJ0eSA/IHZfbWFwW2RdLmhhc093blByb3BlcnR5KCh4IC0gMSkgKyAnLCcgKyB5KSA6XG4gICAgICAgICh2X21hcFtkXVsoeCAtIDEpICsgJywnICsgeV0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgeC0tO1xuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICBwYXRoW3BhdGhMZW5ndGggLSAxXVsxXSArPSB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCsrXSA9XG4gICAgICAgICAgICBbRElGRl9ERUxFVEUsIHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSldO1xuICAgICAgICB9XG4gICAgICAgIGxhc3Rfb3AgPSBESUZGX0RFTEVURTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHZfbWFwW2RdLmhhc093blByb3BlcnR5ID9cbiAgICAgICAgdl9tYXBbZF0uaGFzT3duUHJvcGVydHkoeCArICcsJyArICh5IC0gMSkpIDpcbiAgICAgICAgKHZfbWFwW2RdW3ggKyAnLCcgKyAoeSAtIDEpXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB5LS07XG4gICAgICAgIGlmIChsYXN0X29wID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCAtIDFdWzFdICs9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSB5IC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoKytdID1cbiAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIHkgLSAxKV07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9vcCA9IERJRkZfSU5TRVJUO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgtLTtcbiAgICAgICAgeS0tO1xuICAgICAgICAvL2lmICh0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpICE9XG4gICAgICAgIC8vICAgIHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSB5IC0gMSkpIHtcbiAgICAgICAgLy8gIHRocm93IG5ldyBFcnJvcignTm8gZGlhZ29uYWwuICBDYW5cXCd0IGhhcHBlbi4gKGRpZmZfcGF0aDIpJyk7XG4gICAgICAgIC8vfVxuICAgICAgICBpZiAobGFzdF9vcCA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIHBhdGhbcGF0aExlbmd0aCAtIDFdWzFdICs9IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSB4IC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFtwYXRoTGVuZ3RoKytdID1cbiAgICAgICAgICAgIFtESUZGX0VRVUFMLCB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0geCAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0X29wID0gRElGRl9FUVVBTDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gcHJlZml4IG9mIHR3byBzdHJpbmdzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBzdGFydCBvZiBlYWNoXG4gKiAgICAgc3RyaW5nLlxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vblByZWZpeCA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQ29kZUF0KDApICE9PSB0ZXh0Mi5jaGFyQ29kZUF0KDApKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcnN0YXJ0ID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpID09XG4gICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiBlYWNoIHN0cmluZy5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25TdWZmaXggPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckNvZGVBdCh0ZXh0MS5sZW5ndGggLSAxKSAhPT1cbiAgICB0ZXh0Mi5jaGFyQ29kZUF0KHRleHQyLmxlbmd0aCAtIDEpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcmVuZCA9IDA7XG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDEubGVuZ3RoIC0gcG9pbnRlcmVuZCkgPT1cbiAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0Mi5sZW5ndGggLSBwb2ludGVyZW5kKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyZW5kID0gcG9pbnRlcm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgfVxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XG59O1xuXG5cbi8qKlxuICogRG8gdGhlIHR3byB0ZXh0cyBzaGFyZSBhIHN1YnN0cmluZyB3aGljaCBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBsb25nZXIgdGV4dD9cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPj99IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAqICAgICB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9oYWxmTWF0Y2ggPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBpZiAobG9uZ3RleHQubGVuZ3RoIDwgMTAgfHwgc2hvcnR0ZXh0Lmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbnVsbDsgIC8vIFBvaW50bGVzcy5cbiAgfVxuICB2YXIgZG1wID0gdGhpczsgIC8vICd0aGlzJyBiZWNvbWVzICd3aW5kb3cnIGluIGEgY2xvc3VyZS5cblxuICAvKipcbiAgICogRG9lcyBhIHN1YnN0cmluZyBvZiBzaG9ydHRleHQgZXhpc3Qgd2l0aGluIGxvbmd0ZXh0IHN1Y2ggdGhhdCB0aGUgc3Vic3RyaW5nXG4gICAqIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiBsb25ndGV4dD9cbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9uZ3RleHQgTG9uZ2VyIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFN0YXJ0IGluZGV4IG9mIHF1YXJ0ZXIgbGVuZ3RoIHN1YnN0cmluZyB3aXRoaW4gbG9uZ3RleHRcbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz4/fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuICAgKiAgICAgbG9uZ3RleHQsIHRoZSBzdWZmaXggb2YgbG9uZ3RleHQsIHRoZSBwcmVmaXggb2Ygc2hvcnR0ZXh0LCB0aGUgc3VmZml4XG4gICAqICAgICBvZiBzaG9ydHRleHQgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBkaWZmX2hhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCwgaSkge1xuICAgIC8vIFN0YXJ0IHdpdGggYSAxLzQgbGVuZ3RoIHN1YnN0cmluZyBhdCBwb3NpdGlvbiBpIGFzIGEgc2VlZC5cbiAgICB2YXIgc2VlZCA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gICAgdmFyIGogPSAtMTtcbiAgICB2YXIgYmVzdF9jb21tb24gPSAnJztcbiAgICB2YXIgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XG4gICAgd2hpbGUgKChqID0gc2hvcnR0ZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPSAtMSkge1xuICAgICAgdmFyIHByZWZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblByZWZpeChsb25ndGV4dC5zdWJzdHJpbmcoaSksXG4gICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaikpO1xuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblN1ZmZpeChsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSksXG4gICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaikpO1xuICAgICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCkge1xuICAgICAgICBiZXN0X2NvbW1vbiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiAtIHN1ZmZpeExlbmd0aCwgaikgK1xuICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9iID0gbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9hID0gc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiArIHByZWZpeExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPj0gbG9uZ3RleHQubGVuZ3RoIC8gMikge1xuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYixcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgc2Vjb25kIHF1YXJ0ZXIgaXMgdGhlIHNlZWQgZm9yIGEgaGFsZi1tYXRjaC5cbiAgdmFyIGhtMSA9IGRpZmZfaGFsZk1hdGNoSShsb25ndGV4dCwgc2hvcnR0ZXh0LFxuICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gIC8vIENoZWNrIGFnYWluIGJhc2VkIG9uIHRoZSB0aGlyZCBxdWFydGVyLlxuICB2YXIgaG0yID0gZGlmZl9oYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDIpKTtcbiAgdmFyIGhtO1xuICBpZiAoIWhtMSAmJiAhaG0yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIWhtMikge1xuICAgIGhtID0gaG0xO1xuICB9IGVsc2UgaWYgKCFobTEpIHtcbiAgICBobSA9IGhtMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBCb3RoIG1hdGNoZWQuICBTZWxlY3QgdGhlIGxvbmdlc3QuXG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcbiAgfVxuXG4gIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgdmFyIHRleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2I7XG4gIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICB0ZXh0MV9hID0gaG1bMF07XG4gICAgdGV4dDFfYiA9IGhtWzFdO1xuICAgIHRleHQyX2EgPSBobVsyXTtcbiAgICB0ZXh0Ml9iID0gaG1bM107XG4gIH0gZWxzZSB7XG4gICAgdGV4dDJfYSA9IGhtWzBdO1xuICAgIHRleHQyX2IgPSBobVsxXTtcbiAgICB0ZXh0MV9hID0gaG1bMl07XG4gICAgdGV4dDFfYiA9IGhtWzNdO1xuICB9XG4gIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gIHJldHVybiBbdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYiwgbWlkX2NvbW1vbl07XG59O1xuXG5cbi8qKlxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgc2VtYW50aWNhbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjwqPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cFNlbWFudGljID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XG4gIHZhciBlcXVhbGl0aWVzID0gW107ICAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBsYXN0ZXF1YWxpdHkgPSBudWxsOyAgLy8gQWx3YXlzIGVxdWFsIHRvIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aC0xXVsxXVxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgcHJpb3IgdG8gdGhlIGVxdWFsaXR5LlxuICB2YXIgbGVuZ3RoX2NoYW5nZXMxID0gMDtcbiAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIGFmdGVyIHRoZSBlcXVhbGl0eS5cbiAgdmFyIGxlbmd0aF9jaGFuZ2VzMiA9IDA7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfRVFVQUwpIHsgIC8vIGVxdWFsaXR5IGZvdW5kXG4gICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgbGVuZ3RoX2NoYW5nZXMxID0gbGVuZ3RoX2NoYW5nZXMyO1xuICAgICAgbGVuZ3RoX2NoYW5nZXMyID0gMDtcbiAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgIH0gZWxzZSB7ICAvLyBhbiBpbnNlcnRpb24gb3IgZGVsZXRpb25cbiAgICAgIGxlbmd0aF9jaGFuZ2VzMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICE9PSBudWxsICYmIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9IGxlbmd0aF9jaGFuZ2VzMSkgJiZcbiAgICAgICAgKGxhc3RlcXVhbGl0eS5sZW5ndGggPD0gbGVuZ3RoX2NoYW5nZXMyKSkge1xuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkXG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCxcbiAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xuICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XG4gICAgICAgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZC5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBwcmV2aW91cyBlcXVhbGl0eSAoaXQgbmVlZHMgdG8gYmUgcmVldmFsdWF0ZWQpLlxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgIGxlbmd0aF9jaGFuZ2VzMSA9IDA7ICAvLyBSZXNldCB0aGUgY291bnRlcnMuXG4gICAgICAgIGxlbmd0aF9jaGFuZ2VzMiA9IDA7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgfVxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xufTtcblxuXG4vKipcbiAqIExvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICogd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gYWxpZ24gdGhlIGVkaXQgdG8gYSB3b3JkIGJvdW5kYXJ5LlxuICogZS5nOiBUaGUgYzxpbnM+YXQgYzwvaW5zPmFtZS4gLT4gVGhlIDxpbnM+Y2F0IDwvaW5zPmNhbWUuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48Kj4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gIC8vIERlZmluZSBzb21lIHJlZ2V4IHBhdHRlcm5zIGZvciBtYXRjaGluZyBib3VuZGFyaWVzLiBcbiAgdmFyIHB1bmN0dWF0aW9uID0gL1teYS16QS1aMC05XS87XG4gIHZhciB3aGl0ZXNwYWNlID0gL1xccy87XG4gIHZhciBsaW5lYnJlYWsgPSAvW1xcclxcbl0vO1xuICB2YXIgYmxhbmtsaW5lRW5kID0gL1xcblxccj9cXG4kLztcbiAgdmFyIGJsYW5rbGluZVN0YXJ0ID0gL15cXHI/XFxuXFxyP1xcbi87XG5cbiAgLyoqXG4gICAqIEdpdmVuIHR3byBzdHJpbmdzLCBjb21wdXRlIGEgc2NvcmUgcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhlIGludGVybmFsXG4gICAqIGJvdW5kYXJ5IGZhbGxzIG9uIGxvZ2ljYWwgYm91bmRhcmllcy5cbiAgICogU2NvcmVzIHJhbmdlIGZyb20gNSAoYmVzdCkgdG8gMCAod29yc3QpLlxuICAgKiBDbG9zdXJlLCBtYWtlcyByZWZlcmVuY2UgdG8gcmVnZXggcGF0dGVybnMgZGVmaW5lZCBhYm92ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9uZSBGaXJzdCBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNjb3JlLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZShvbmUsIHR3bykge1xuICAgIGlmICghb25lIHx8ICF0d28pIHtcbiAgICAgIC8vIEVkZ2VzIGFyZSB0aGUgYmVzdC5cbiAgICAgIHJldHVybiA1O1xuICAgIH1cblxuICAgIC8vIEVhY2ggcG9ydCBvZiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZXMgc2xpZ2h0bHkgZGlmZmVyZW50bHkgZHVlIHRvXG4gICAgLy8gc3VidGxlIGRpZmZlcmVuY2VzIGluIGVhY2ggbGFuZ3VhZ2UncyBkZWZpbml0aW9uIG9mIHRoaW5ncyBsaWtlXG4gICAgLy8gJ3doaXRlc3BhY2UnLiAgU2luY2UgdGhpcyBmdW5jdGlvbidzIHB1cnBvc2UgaXMgbGFyZ2VseSBjb3NtZXRpYyxcbiAgICAvLyB0aGUgY2hvaWNlIGhhcyBiZWVuIG1hZGUgdG8gdXNlIGVhY2ggbGFuZ3VhZ2UncyBuYXRpdmUgZmVhdHVyZXNcbiAgICAvLyByYXRoZXIgdGhhbiBmb3JjZSB0b3RhbCBjb25mb3JtaXR5LlxuICAgIHZhciBzY29yZSA9IDA7XG4gICAgLy8gT25lIHBvaW50IGZvciBub24tYWxwaGFudW1lcmljLlxuICAgIGlmIChvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKS5tYXRjaChwdW5jdHVhdGlvbikgfHxcbiAgICAgIHR3by5jaGFyQXQoMCkubWF0Y2gocHVuY3R1YXRpb24pKSB7XG4gICAgICBzY29yZSsrO1xuICAgICAgLy8gVHdvIHBvaW50cyBmb3Igd2hpdGVzcGFjZS5cbiAgICAgIGlmIChvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKS5tYXRjaCh3aGl0ZXNwYWNlKSB8fFxuICAgICAgICB0d28uY2hhckF0KDApLm1hdGNoKHdoaXRlc3BhY2UpKSB7XG4gICAgICAgIHNjb3JlKys7XG4gICAgICAgIC8vIFRocmVlIHBvaW50cyBmb3IgbGluZSBicmVha3MuXG4gICAgICAgIGlmIChvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKS5tYXRjaChsaW5lYnJlYWspIHx8XG4gICAgICAgICAgdHdvLmNoYXJBdCgwKS5tYXRjaChsaW5lYnJlYWspKSB7XG4gICAgICAgICAgc2NvcmUrKztcbiAgICAgICAgICAvLyBGb3VyIHBvaW50cyBmb3IgYmxhbmsgbGluZXMuXG4gICAgICAgICAgaWYgKG9uZS5tYXRjaChibGFua2xpbmVFbmQpIHx8IHR3by5tYXRjaChibGFua2xpbmVTdGFydCkpIHtcbiAgICAgICAgICAgIHNjb3JlKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzY29yZTtcbiAgfVxuXG4gIHZhciBwb2ludGVyID0gMTtcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcbiAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgdmFyIGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcbiAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB2YXIgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuXG4gICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXG4gICAgICB2YXIgY29tbW9uT2Zmc2V0ID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeChlcXVhbGl0eTEsIGVkaXQpO1xuICAgICAgaWYgKGNvbW1vbk9mZnNldCkge1xuICAgICAgICB2YXIgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlY29uZCwgc3RlcCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIHJpZ2h0LCBsb29raW5nIGZvciB0aGUgYmVzdCBmaXQuXG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgIHZhciBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgIHZhciBiZXN0U2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgK1xuICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICB3aGlsZSAoZWRpdC5jaGFyQXQoMCkgPT09IGVxdWFsaXR5Mi5jaGFyQXQoMCkpIHtcbiAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApO1xuICAgICAgICBlZGl0ID0gZWRpdC5zdWJzdHJpbmcoMSkgKyBlcXVhbGl0eTIuY2hhckF0KDApO1xuICAgICAgICBlcXVhbGl0eTIgPSBlcXVhbGl0eTIuc3Vic3RyaW5nKDEpO1xuICAgICAgICB2YXIgc2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgK1xuICAgICAgICAgIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgICAgLy8gVGhlID49IGVuY291cmFnZXMgdHJhaWxpbmcgcmF0aGVyIHRoYW4gbGVhZGluZyB3aGl0ZXNwYWNlIG9uIGVkaXRzLlxuICAgICAgICBpZiAoc2NvcmUgPj0gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgICAgICBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICAgICAgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9IGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBpbXByb3ZlbWVudCwgc2F2ZSBpdCBiYWNrIHRvIHRoZSBkaWZmLlxuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGJlc3RFcXVhbGl0eTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgIH1cbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdDtcbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTIpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBiZXN0RXF1YWxpdHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlZHVjZSB0aGUgbnVtYmVyIG9mIGVkaXRzIGJ5IGVsaW1pbmF0aW5nIG9wZXJhdGlvbmFsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICB2YXIgbGFzdGVxdWFsaXR5ID0gJyc7ICAvLyBBbHdheXMgZXF1YWwgdG8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoLTFdWzFdXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gIC8vIElzIHRoZXJlIGFuIGluc2VydGlvbiBvcGVyYXRpb24gYmVmb3JlIHRoZSBsYXN0IGVxdWFsaXR5LlxuICB2YXIgcHJlX2lucyA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwcmVfZGVsID0gZmFsc2U7XG4gIC8vIElzIHRoZXJlIGFuIGluc2VydGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXG4gIHZhciBwb3N0X2lucyA9IGZhbHNlO1xuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgdmFyIHBvc3RfZGVsID0gZmFsc2U7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfRVFVQUwpIHsgIC8vIGVxdWFsaXR5IGZvdW5kXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgdGhpcy5EaWZmX0VkaXRDb3N0ICYmXG4gICAgICAgIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcbiAgICAgICAgLy8gQ2FuZGlkYXRlIGZvdW5kLlxuICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgICBwcmVfaW5zID0gcG9zdF9pbnM7XG4gICAgICAgIHByZV9kZWwgPSBwb3N0X2RlbDtcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgYSBjYW5kaWRhdGUsIGFuZCBjYW4gbmV2ZXIgYmVjb21lIG9uZS5cbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIGxhc3RlcXVhbGl0eSA9ICcnO1xuICAgICAgfVxuICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7ICAvLyBhbiBpbnNlcnRpb24gb3IgZGVsZXRpb25cbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0RFTEVURSkge1xuICAgICAgICBwb3N0X2RlbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0X2lucyA9IHRydWU7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgICogRml2ZSB0eXBlcyB0byBiZSBzcGxpdDpcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlhZPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGlucz5DPC9pbnM+XG4gICAgICAgKiA8aW5zPkE8L2RlbD5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGRlbD5DPC9kZWw+XG4gICAgICAgKi9cbiAgICAgIGlmIChsYXN0ZXF1YWxpdHkgJiYgKChwcmVfaW5zICYmIHByZV9kZWwgJiYgcG9zdF9pbnMgJiYgcG9zdF9kZWwpIHx8XG4gICAgICAgICgobGFzdGVxdWFsaXR5Lmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAvIDIpICYmXG4gICAgICAgICAgKHByZV9pbnMgKyBwcmVfZGVsICsgcG9zdF9pbnMgKyBwb3N0X2RlbCkgPT0gMykpKSB7XG4gICAgICAgIC8vIER1cGxpY2F0ZSByZWNvcmRcbiAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLFxuICAgICAgICAgIFtESUZGX0RFTEVURSwgbGFzdGVxdWFsaXR5XSk7XG4gICAgICAgIC8vIENoYW5nZSBzZWNvbmQgY29weSB0byBpbnNlcnQuXG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgZXF1YWxpdHkgd2UganVzdCBkZWxldGVkO1xuICAgICAgICBsYXN0ZXF1YWxpdHkgPSAnJztcbiAgICAgICAgaWYgKHByZV9pbnMgJiYgcHJlX2RlbCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMgbWFkZSB3aGljaCBjb3VsZCBhZmZlY3QgcHJldmlvdXMgZW50cnksIGtlZXAgZ29pbmcuXG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IHRydWU7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHk7XG4gICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcbiAgICAgICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuXG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW9yZGVyIGFuZCBtZXJnZSBsaWtlIGVkaXQgc2VjdGlvbnMuICBNZXJnZSBlcXVhbGl0aWVzLlxuICogQW55IGVkaXQgc2VjdGlvbiBjYW4gbW92ZSBhcyBsb25nIGFzIGl0IGRvZXNuJ3QgY3Jvc3MgYW4gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48Kj4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBNZXJnZSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCAnJ10pOyAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgdmFyIHBvaW50ZXIgPSAwO1xuICB2YXIgY291bnRfZGVsZXRlID0gMDtcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcbiAgdmFyIGNvbW1vbmxlbmd0aDtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgfHwgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmICgocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCkgPiAwICYmXG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09XG4gICAgICAgICAgICAgICAgRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgLSAxXVsxXSArPVxuICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIFtESUZGX0VRVUFMLFxuICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0X2luc2VydC5sZW5ndGggLVxuICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKDAsIHRleHRfZGVsZXRlLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb3VudF9pbnNlcnQgPT09IDApIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXG4gICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZV0sXG4gICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgK1xuICAgICAgICAgICAgKGNvdW50X2RlbGV0ZSA/IDEgOiAwKSArIChjb3VudF9pbnNlcnQgPyAxIDogMCkgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAvLyBNZXJnZSB0aGlzIGVxdWFsaXR5IHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xuICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSAnJykge1xuICAgIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB9XG5cbiAgLy8gU2Vjb25kIHBhc3M6IGxvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xuICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXG4gIC8vIGUuZzogQTxpbnM+QkE8L2lucz5DIC0+IDxpbnM+QUI8L2lucz5BQ1xuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICBwb2ludGVyID0gMTtcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcbiAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICtcbiAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpO1xuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aClcbiAgICAgICAgPT0gZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIG5leHQgZXF1YWxpdHkuXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgK1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICAvLyBJZiBzaGlmdHMgd2VyZSBtYWRlLCB0aGUgZGlmZiBuZWVkcyByZW9yZGVyaW5nIGFuZCBhbm90aGVyIHNoaWZ0IHN3ZWVwLlxuICBpZiAoY2hhbmdlcykge1xuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogbG9jIGlzIGEgbG9jYXRpb24gaW4gdGV4dDEsIGNvbXB1dGUgYW5kIHJldHVybiB0aGUgZXF1aXZhbGVudCBsb2NhdGlvbiBpblxuICogdGV4dDIuXG4gKiBlLmcuICdUaGUgY2F0JyB2cyAnVGhlIGJpZyBjYXQnLCAxLT4xLCA1LT44XG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48Kj4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBMb2NhdGlvbiB3aXRoaW4gdGV4dDFcbiAqIEByZXR1cm4ge251bWJlcn0gTG9jYXRpb24gd2l0aGluIHRleHQyXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfeEluZGV4ID0gZnVuY3Rpb24gKGRpZmZzLCBsb2MpIHtcbiAgdmFyIGNoYXJzMSA9IDA7XG4gIHZhciBjaGFyczIgPSAwO1xuICB2YXIgbGFzdF9jaGFyczEgPSAwO1xuICB2YXIgbGFzdF9jaGFyczIgPSAwO1xuICB2YXIgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkgeyAgLy8gRXF1YWxpdHkgb3IgZGVsZXRpb24uXG4gICAgICBjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7ICAvLyBFcXVhbGl0eSBvciBpbnNlcnRpb24uXG4gICAgICBjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoY2hhcnMxID4gbG9jKSB7ICAvLyBPdmVyc2hvdCB0aGUgbG9jYXRpb24uXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdF9jaGFyczEgPSBjaGFyczE7XG4gICAgbGFzdF9jaGFyczIgPSBjaGFyczI7XG4gIH1cbiAgLy8gV2FzIHRoZSBsb2NhdGlvbiB3YXMgZGVsZXRlZD9cbiAgaWYgKGRpZmZzLmxlbmd0aCAhPSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSkge1xuICAgIHJldHVybiBsYXN0X2NoYXJzMjtcbiAgfVxuICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXIgbGVuZ3RoLlxuICByZXR1cm4gbGFzdF9jaGFyczIgKyAobG9jIC0gbGFzdF9jaGFyczEpO1xufTtcblxuXG4vKipcbiAqIENvbnZlcnQgYSBkaWZmIGFycmF5IGludG8gYSBwcmV0dHkgSFRNTCByZXBvcnQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48Kj4+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHJlcHJlc2VudGF0aW9uXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfcHJldHR5SHRtbCA9IGZ1bmN0aW9uIChkaWZmcykge1xuICB2YXIgaHRtbCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICB2YXIgb3AgPSBkaWZmc1t4XVswXTsgICAvLyBPcGVyYXRpb24gKGluc2VydCwgZGVsZXRlLCBlcXVhbClcbiAgICB2YXIgZGF0YSA9IGRpZmZzW3hdWzFdOyAvLyBUZXh0IG9mIGNoYW5nZS5cbiAgICB2YXIgdGV4dCA9IGRhdGEucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXFxuL2csICcmcGFyYTs8QlI+Jyk7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaHRtbFt4XSA9ICc8SU5TIFNUWUxFPVwiYmFja2dyb3VuZDojRTZGRkU2O1wiIFRJVExFPVwiaT0nICsgaSArICdcIj4nICtcbiAgICAgICAgICB0ZXh0ICsgJzwvSU5TPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgaHRtbFt4XSA9ICc8REVMIFNUWUxFPVwiYmFja2dyb3VuZDojRkZFNkU2O1wiIFRJVExFPVwiaT0nICsgaSArICdcIj4nICtcbiAgICAgICAgICB0ZXh0ICsgJzwvREVMPic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBodG1sW3hdID0gJzxTUEFOIFRJVExFPVwiaT0nICsgaSArICdcIj4nICsgdGV4dCArICc8L1NQQU4+JztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChvcCAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIGkgKz0gZGF0YS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBodG1sLmpvaW4oJycpO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc291cmNlIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBkZWxldGlvbnMpLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPCo+Pn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqIEByZXR1cm4ge3N0cmluZ30gU291cmNlIHRleHRcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90ZXh0MSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICB2YXIgdHh0ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUKSB7XG4gICAgICB0eHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHR4dC5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIGRlc3RpbmF0aW9uIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBpbnNlcnRpb25zKS5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjwqPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERlc3RpbmF0aW9uIHRleHRcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90ZXh0MiA9IGZ1bmN0aW9uIChkaWZmcykge1xuICB2YXIgdHh0ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7XG4gICAgICB0eHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHR4dC5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDcnVzaCB0aGUgZGlmZiBpbnRvIGFuIGVuY29kZWQgc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgb3BlcmF0aW9uc1xuICogcmVxdWlyZWQgdG8gdHJhbnNmb3JtIHRleHQxIGludG8gdGV4dDIuXG4gKiBFLmcuID0zXFx0LTJcXHQraW5nICAtPiBLZWVwIDMgY2hhcnMsIGRlbGV0ZSAyIGNoYXJzLCBpbnNlcnQgJ2luZycuXG4gKiBPcGVyYXRpb25zIGFyZSB0YWItc2VwYXJhdGVkLiAgSW5zZXJ0ZWQgdGV4dCBpcyBlc2NhcGVkIHVzaW5nICV4eCBub3RhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjwqPj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERlbHRhIHRleHRcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90b0RlbHRhID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gIHZhciB0eHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHN3aXRjaCAoZGlmZnNbeF1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIHR4dFt4XSA9ICcrJyArIGVuY29kZVVSSShkaWZmc1t4XVsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgdHh0W3hdID0gJy0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgdHh0W3hdID0gJz0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBlbmNvZGUgY2hhciAwLlxuICByZXR1cm4gdHh0LmpvaW4oJ1xcdCcpLnJlcGxhY2UoL1xcMC9nLCAnJTAwJykucmVwbGFjZSgvJTIwL2csICcgJyk7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gdGhlIG9yaWdpbmFsIHRleHQxLCBhbmQgYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZVxuICogb3BlcmF0aW9ucyByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MiwgY29tcHV0ZSB0aGUgZnVsbCBkaWZmLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIFNvdXJjZSBzdHJpbmcgZm9yIHRoZSBkaWZmXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVsdGEgRGVsdGEgdGV4dFxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjwqPj59IEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaW52YWxpZCBpbnB1dFxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Zyb21EZWx0YSA9IGZ1bmN0aW9uICh0ZXh0MSwgZGVsdGEpIHtcbiAgdmFyIGRpZmZzID0gW107XG4gIHZhciBkaWZmc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEN1cnNvciBpbiB0ZXh0MVxuICAvLyBPcGVyYSBkb2Vzbid0IGtub3cgaG93IHRvIGRlY29kZSBjaGFyIDAuXG4gIGRlbHRhID0gZGVsdGEucmVwbGFjZSgvJTAwL2csICdcXDAnKTtcbiAgdmFyIHRva2VucyA9IGRlbHRhLnNwbGl0KC9cXHQvZyk7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW5zLmxlbmd0aDsgeCsrKSB7XG4gICAgLy8gRWFjaCB0b2tlbiBiZWdpbnMgd2l0aCBhIG9uZSBjaGFyYWN0ZXIgcGFyYW1ldGVyIHdoaWNoIHNwZWNpZmllcyB0aGVcbiAgICAvLyBvcGVyYXRpb24gb2YgdGhpcyB0b2tlbiAoZGVsZXRlLCBpbnNlcnQsIGVxdWFsaXR5KS5cbiAgICB2YXIgcGFyYW0gPSB0b2tlbnNbeF0uc3Vic3RyaW5nKDEpO1xuICAgIHN3aXRjaCAodG9rZW5zW3hdLmNoYXJBdCgwKSkge1xuICAgICAgY2FzZSAnKyc6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9JTlNFUlQsIGRlY29kZVVSSShwYXJhbSldO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy0nOlxuICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAnPSc6XG4gICAgICAgIHZhciBuID0gcGFyc2VJbnQocGFyYW0sIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKG4pIHx8IG4gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IHRleHQxLnN1YnN0cmluZyhwb2ludGVyLCBwb2ludGVyICs9IG4pO1xuICAgICAgICBpZiAodG9rZW5zW3hdLmNoYXJBdCgwKSA9PSAnPScpIHtcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtESUZGX0VRVUFMLCB0ZXh0XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtESUZGX0RFTEVURSwgdGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBCbGFuayB0b2tlbnMgYXJlIG9rIChmcm9tIGEgdHJhaWxpbmcgXFx0KS5cbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBpcyBhbiBlcnJvci5cbiAgICAgICAgaWYgKHRva2Vuc1t4XSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaWZmIG9wZXJhdGlvbiBpbiBkaWZmX2Zyb21EZWx0YTogJyArXG4gICAgICAgICAgICB0b2tlbnNbeF0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwb2ludGVyICE9IHRleHQxLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVsdGEgbGVuZ3RoICgnICsgcG9pbnRlciArXG4gICAgICAnKSBkb2VzIG5vdCBlcXVhbCBzb3VyY2UgdGV4dCBsZW5ndGggKCcgKyB0ZXh0MS5sZW5ndGggKyAnKS4nKTtcbiAgfVxuICByZXR1cm4gZGlmZnM7XG59O1xuXG5cbi8vICBNQVRDSCBGVU5DVElPTlNcblxuXG4vKipcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb2MgVGhlIGxvY2F0aW9uIHRvIHNlYXJjaCBhcm91bmRcbiAqIEByZXR1cm4ge251bWJlcj99IEJlc3QgbWF0Y2ggaW5kZXggb3IgbnVsbFxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24gKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsb2MsIHRleHQubGVuZ3RoIC0gcGF0dGVybi5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT0gcGF0dGVybikge1xuICAgIC8vIFNob3J0Y3V0IChwb3RlbnRpYWxseSBub3QgZ3VhcmFudGVlZCBieSB0aGUgYWxnb3JpdGhtKVxuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gTm90aGluZyB0byBtYXRjaC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0ZXh0LnN1YnN0cmluZyhsb2MsIGxvYyArIHBhdHRlcm4ubGVuZ3RoKSA9PSBwYXR0ZXJuKSB7XG4gICAgLy8gUGVyZmVjdCBtYXRjaCBhdCB0aGUgcGVyZmVjdCBzcG90ISAgKEluY2x1ZGVzIGNhc2Ugb2YgbnVsbCBwYXR0ZXJuKVxuICAgIHJldHVybiBsb2M7XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gYSBmdXp6eSBjb21wYXJlLlxuICAgIHJldHVybiB0aGlzLm1hdGNoX2JpdGFwKHRleHQsIHBhdHRlcm4sIGxvYyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMb2NhdGUgdGhlIGJlc3QgaW5zdGFuY2Ugb2YgJ3BhdHRlcm4nIGluICd0ZXh0JyBuZWFyICdsb2MnIHVzaW5nIHRoZVxuICogQml0YXAgYWxnb3JpdGhtLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kXG4gKiBAcmV0dXJuIHtudW1iZXI/fSBCZXN0IG1hdGNoIGluZGV4IG9yIG51bGxcbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2JpdGFwID0gZnVuY3Rpb24gKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdHRlcm4gdG9vIGxvbmcgZm9yIHRoaXMgYnJvd3Nlci4nKTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpc2UgdGhlIGFscGhhYmV0LlxuICB2YXIgcyA9IHRoaXMubWF0Y2hfYWxwaGFiZXQocGF0dGVybik7XG5cbiAgdmFyIHNjb3JlX3RleHRfbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gIC8vIENvZXJjZSB0aGUgdGV4dCBsZW5ndGggYmV0d2VlbiByZWFzb25hYmxlIG1heGltdW1zIGFuZCBtaW5pbXVtcy5cbiAgc2NvcmVfdGV4dF9sZW5ndGggPSBNYXRoLm1heChzY29yZV90ZXh0X2xlbmd0aCwgdGhpcy5NYXRjaF9NaW5MZW5ndGgpO1xuICBzY29yZV90ZXh0X2xlbmd0aCA9IE1hdGgubWluKHNjb3JlX3RleHRfbGVuZ3RoLCB0aGlzLk1hdGNoX01heExlbmd0aCk7XG5cbiAgdmFyIGRtcCA9IHRoaXM7ICAvLyAndGhpcycgYmVjb21lcyAnd2luZG93JyBpbiBhIGNsb3N1cmUuXG5cbiAgLyoqXG4gICAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc2NvcmUgZm9yIGEgbWF0Y2ggd2l0aCBlIGVycm9ycyBhbmQgeCBsb2NhdGlvbi5cbiAgICogQWNjZXNzZXMgbG9jLCBzY29yZV90ZXh0X2xlbmd0aCBhbmQgcGF0dGVybiB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgTnVtYmVyIG9mIGVycm9ycyBpbiBtYXRjaFxuICAgKiBAcGFyYW0ge251bWJlcn0geCBMb2NhdGlvbiBvZiBtYXRjaFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE92ZXJhbGwgc2NvcmUgZm9yIG1hdGNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaF9iaXRhcFNjb3JlKGUsIHgpIHtcbiAgICB2YXIgZCA9IE1hdGguYWJzKGxvYyAtIHgpO1xuICAgIHJldHVybiAoZSAvIHBhdHRlcm4ubGVuZ3RoIC8gZG1wLk1hdGNoX0JhbGFuY2UpICtcbiAgICAgIChkIC8gc2NvcmVfdGV4dF9sZW5ndGggLyAoMS4wIC0gZG1wLk1hdGNoX0JhbGFuY2UpKTtcbiAgfVxuXG4gIC8vIEhpZ2hlc3Qgc2NvcmUgYmV5b25kIHdoaWNoIHdlIGdpdmUgdXAuXG4gIHZhciBzY29yZV90aHJlc2hvbGQgPSB0aGlzLk1hdGNoX1RocmVzaG9sZDtcbiAgLy8gSXMgdGhlcmUgYSBuZWFyYnkgZXhhY3QgbWF0Y2g/IChzcGVlZHVwKVxuICB2YXIgYmVzdF9sb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgbG9jKTtcbiAgaWYgKGJlc3RfbG9jICE9IC0xKSB7XG4gICAgc2NvcmVfdGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gIH1cbiAgLy8gV2hhdCBhYm91dCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uPyAoc3BlZWR1cClcbiAgYmVzdF9sb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIGxvYyArIHBhdHRlcm4ubGVuZ3RoKTtcbiAgaWYgKGJlc3RfbG9jICE9IC0xKSB7XG4gICAgc2NvcmVfdGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gIH1cblxuICAvLyBJbml0aWFsaXNlIHRoZSBiaXQgYXJyYXlzLlxuICB2YXIgbWF0Y2htYXNrID0gMSA8PCAocGF0dGVybi5sZW5ndGggLSAxKTtcbiAgYmVzdF9sb2MgPSBudWxsO1xuXG4gIHZhciBiaW5fbWluLCBiaW5fbWlkO1xuICB2YXIgYmluX21heCA9IE1hdGgubWF4KGxvYyArIGxvYywgdGV4dC5sZW5ndGgpO1xuICB2YXIgbGFzdF9yZDtcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBwYXR0ZXJuLmxlbmd0aDsgZCsrKSB7XG4gICAgLy8gU2NhbiBmb3IgdGhlIGJlc3QgbWF0Y2g7IGVhY2ggaXRlcmF0aW9uIGFsbG93cyBmb3Igb25lIG1vcmUgZXJyb3IuXG4gICAgdmFyIHJkID0gQXJyYXkodGV4dC5sZW5ndGgpO1xuXG4gICAgLy8gUnVuIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgaG93IGZhciBmcm9tICdsb2MnIHdlIGNhbiBzdHJheSBhdCB0aGlzXG4gICAgLy8gZXJyb3IgbGV2ZWwuXG4gICAgYmluX21pbiA9IGxvYztcbiAgICBiaW5fbWlkID0gYmluX21heDtcbiAgICB3aGlsZSAoYmluX21pbiA8IGJpbl9taWQpIHtcbiAgICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlKGQsIGJpbl9taWQpIDwgc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgIGJpbl9taW4gPSBiaW5fbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgICB9XG4gICAgICBiaW5fbWlkID0gTWF0aC5mbG9vcigoYmluX21heCAtIGJpbl9taW4pIC8gMiArIGJpbl9taW4pO1xuICAgIH1cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5fbWF4ID0gYmluX21pZDtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCBsb2MgLSAoYmluX21pZCAtIGxvYykgLSAxKTtcbiAgICB2YXIgZmluaXNoID0gTWF0aC5taW4odGV4dC5sZW5ndGggLSAxLCBwYXR0ZXJuLmxlbmd0aCArIGJpbl9taWQpO1xuXG4gICAgaWYgKHRleHQuY2hhckF0KGZpbmlzaCkgPT0gcGF0dGVybi5jaGFyQXQocGF0dGVybi5sZW5ndGggLSAxKSkge1xuICAgICAgcmRbZmluaXNoXSA9ICgxIDw8IChkICsgMSkpIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmRbZmluaXNoXSA9ICgxIDw8IGQpIC0gMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IGZpbmlzaCAtIDE7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgLy8gVGhlIGFscGhhYmV0IChzKSBpcyBhIHNwYXJzZSBoYXNoLCBzbyB0aGUgZm9sbG93aW5nIGxpbmVzIGdlbmVyYXRlXG4gICAgICAvLyB3YXJuaW5ncy5cbiAgICAgIGlmIChkID09PSAwKSB7ICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaC5cbiAgICAgICAgcmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgc1t0ZXh0LmNoYXJBdChqKV07XG4gICAgICB9IGVsc2UgeyAgLy8gU3Vic2VxdWVudCBwYXNzZXM6IGZ1enp5IG1hdGNoLlxuICAgICAgICByZFtqXSA9ICgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBzW3RleHQuY2hhckF0KGopXSB8XG4gICAgICAgICAgKChsYXN0X3JkW2ogKyAxXSA8PCAxKSB8IDEpIHwgKChsYXN0X3JkW2pdIDw8IDEpIHwgMSkgfFxuICAgICAgICAgIGxhc3RfcmRbaiArIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgIHZhciBzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmUoZCwgaik7XG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgaWYgKHNjb3JlIDw9IHNjb3JlX3RocmVzaG9sZCkge1xuICAgICAgICAgIC8vIFRvbGQgeW91IHNvLlxuICAgICAgICAgIHNjb3JlX3RocmVzaG9sZCA9IHNjb3JlO1xuICAgICAgICAgIGJlc3RfbG9jID0gajtcbiAgICAgICAgICBpZiAoaiA+IGxvYykge1xuICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGxvYywgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gbG9jLlxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBsb2MgLSAoaiAtIGxvYykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHBhc3NlZCBsb2MsIGRvd25oaWxsIGZyb20gaGVyZSBvbiBpbi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBob3BlIGZvciBhIChiZXR0ZXIpIG1hdGNoIGF0IGdyZWF0ZXIgZXJyb3IgbGV2ZWxzLlxuICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlKGQgKyAxLCBsb2MpID4gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdF9yZCA9IHJkO1xuICB9XG4gIHJldHVybiBiZXN0X2xvYztcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXNlIHRoZSBhbHBoYWJldCBmb3IgdGhlIEJpdGFwIGFsZ29yaXRobS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSB0ZXh0IHRvIGVuY29kZVxuICogQHJldHVybiB7T2JqZWN0fSBIYXNoIG9mIGNoYXJhY3RlciBsb2NhdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2FscGhhYmV0ID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgdmFyIHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gaSAtIDEpO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuXG4vLyAgUEFUQ0ggRlVOQ1RJT05TXG5cblxuLyoqXG4gKiBJbmNyZWFzZSB0aGUgY29udGV4dCB1bnRpbCBpdCBpcyB1bmlxdWUsXG4gKiBidXQgZG9uJ3QgbGV0IHRoZSBwYXR0ZXJuIGV4cGFuZCBiZXlvbmQgTWF0Y2hfTWF4Qml0cy5cbiAqIEBwYXJhbSB7cGF0Y2hfb2JqfSBwYXRjaCBUaGUgcGF0Y2ggdG8gZ3Jvd1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU291cmNlIHRleHRcbiAqIEBwcml2YXRlXG4gKi9cbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZENvbnRleHQgPSBmdW5jdGlvbiAocGF0Y2gsIHRleHQpIHtcbiAgdmFyIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEpO1xuICB2YXIgcGFkZGluZyA9IDA7XG4gIHdoaWxlICh0ZXh0LmluZGV4T2YocGF0dGVybikgIT0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuKSAmJlxuICAgIHBhdHRlcm4ubGVuZ3RoIDwgdGhpcy5NYXRjaF9NYXhCaXRzIC0gdGhpcy5QYXRjaF9NYXJnaW5cbiAgICAtIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XG4gICAgcGFkZGluZyArPSB0aGlzLlBhdGNoX01hcmdpbjtcbiAgICBwYXR0ZXJuID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZyxcbiAgICAgIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgfVxuICAvLyBBZGQgb25lIGNodW5rIGZvciBnb29kIGx1Y2suXG4gIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XG4gIC8vIEFkZCB0aGUgcHJlZml4LlxuICB2YXIgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyKTtcbiAgaWYgKHByZWZpeCAhPT0gJycpIHtcbiAgICBwYXRjaC5kaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBwcmVmaXhdKTtcbiAgfVxuICAvLyBBZGQgdGhlIHN1ZmZpeC5cbiAgdmFyIHN1ZmZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEsXG4gICAgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xuICBpZiAoc3VmZml4ICE9PSAnJykge1xuICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHN1ZmZpeF0pO1xuICB9XG5cbiAgLy8gUm9sbCBiYWNrIHRoZSBzdGFydCBwb2ludHMuXG4gIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXgubGVuZ3RoO1xuICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcbiAgLy8gRXh0ZW5kIHRoZSBsZW5ndGhzLlxuICBwYXRjaC5sZW5ndGgxICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xuICBwYXRjaC5sZW5ndGgyICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgYSBsaXN0IG9mIHBhdGNoZXMgdG8gdHVybiB0ZXh0MSBpbnRvIHRleHQyLlxuICogVXNlIGRpZmZzIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgY29tcHV0ZSBpdCBvdXJzZWx2ZXMuXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uOlxuICogTWV0aG9kIDE6XG4gKiBhID0gT2xkIHRleHQsIGIgPSBOZXcgdGV4dCwgYyA9IGFycmF5IG9mIGRpZmYgdHVwbGxlIGZvciBhIHRvIGJcbiAqIE1ldGhvZCAyOlxuICogYSA9IEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0IDEgdG8gdGV4dCAyLCBiIGFuZCBjIHVuZGVmaW5lZFxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPEFycmF5LjwqPj59IGEgT2xkIHRleHQgKG1ldGhvZCAxKSBvciBBcnJheSBvZiBkaWZmXG4gKiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMilcbiAqIEBwYXJhbSB7c3RyaW5nP30gYiBOZXcgdGV4dCAobWV0aG9kIDEpXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48Kj4+fSBjIE9wdGlvbmFsIGFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MlxuICogKG1ldGhvZCAxKVxuICogQHJldHVybiB7QXJyYXkuPHBhdGNoX29iaj59IEFycmF5IG9mIHBhdGNoIG9iamVjdHNcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfbWFrZSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gIHZhciB0ZXh0MSwgdGV4dDIsIGRpZmZzO1xuICBpZiAodHlwZW9mIGIgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkaWZmcyA9IGE7XG4gICAgdGV4dDEgPSB0aGlzLmRpZmZfdGV4dDEoZGlmZnMpO1xuICAgIHRleHQyID0gJyc7ICAvLyB0ZXh0MiBpcyBub3QgYWN0dWFsbHkgdXNlZC5cbiAgfSBlbHNlIHtcbiAgICB0ZXh0MSA9IGE7XG4gICAgdGV4dDIgPSBiO1xuICAgIGlmICh0eXBlb2YgYyAhPSAndW5kZWZpbmVkJykge1xuICAgICAgZGlmZnMgPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgdHJ1ZSk7XG4gICAgICBpZiAoZGlmZnMubGVuZ3RoID4gMikge1xuICAgICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcbiAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdOyAgLy8gR2V0IHJpZCBvZiB0aGUgbnVsbCBjYXNlLlxuICB9XG4gIHZhciBwYXRjaGVzID0gW107XG4gIHZhciBwYXRjaCA9IG5ldyBwYXRjaF9vYmooKTtcbiAgdmFyIHBhdGNoRGlmZkxlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gIHZhciBjaGFyX2NvdW50MSA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MSBzdHJpbmcuXG4gIHZhciBjaGFyX2NvdW50MiA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MiBzdHJpbmcuXG4gIHZhciBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7ICAvLyBSZWNyZWF0ZSB0aGUgcGF0Y2hlcyB0byBkZXRlcm1pbmUgY29udGV4dCBpbmZvLlxuICB2YXIgcG9zdHBhdGNoX3RleHQgPSB0ZXh0MTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBkaWZmX3R5cGUgPSBkaWZmc1t4XVswXTtcbiAgICB2YXIgZGlmZl90ZXh0ID0gZGlmZnNbeF1bMV07XG5cbiAgICBpZiAoIXBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmX3R5cGUgIT09IERJRkZfRVFVQUwpIHtcbiAgICAgIC8vIEEgbmV3IHBhdGNoIHN0YXJ0cyBoZXJlLlxuICAgICAgcGF0Y2guc3RhcnQxID0gY2hhcl9jb3VudDE7XG4gICAgICBwYXRjaC5zdGFydDIgPSBjaGFyX2NvdW50MjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGRpZmZfdHlwZSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICsgZGlmZl90ZXh0ICtcbiAgICAgICAgICBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgIHBvc3RwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKDAsIGNoYXJfY291bnQyKSArXG4gICAgICAgICAgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyICsgZGlmZl90ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA8PSAyICogdGhpcy5QYXRjaF9NYXJnaW4gJiZcbiAgICAgICAgICBwYXRjaERpZmZMZW5ndGggJiYgZGlmZnMubGVuZ3RoICE9IHggKyAxKSB7XG4gICAgICAgICAgLy8gU21hbGwgZXF1YWxpdHkgaW5zaWRlIGEgcGF0Y2guXG4gICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmX3RleHQubGVuZ3RoID49IDIgKiB0aGlzLlBhdGNoX01hcmdpbikge1xuICAgICAgICAgIC8vIFRpbWUgZm9yIGEgbmV3IHBhdGNoLlxuICAgICAgICAgIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucGF0Y2hfYWRkQ29udGV4dChwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggPSAwO1xuICAgICAgICAgICAgcHJlcGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNvdW50LlxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjaGFyX2NvdW50MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgY2hhcl9jb3VudDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gUGljayB1cCB0aGUgbGVmdG92ZXIgcGF0Y2ggaWYgbm90IGVtcHR5LlxuICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0KHBhdGNoLCBwcmVwYXRjaF90ZXh0KTtcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGNoZXM7XG59O1xuXG5cbi8qKlxuICogTWVyZ2UgYSBzZXQgb2YgcGF0Y2hlcyBvbnRvIHRoZSB0ZXh0LiAgUmV0dXJuIGEgcGF0Y2hlZCB0ZXh0LCBhcyB3ZWxsXG4gKiBhcyBhIGxpc3Qgb2YgdHJ1ZS9mYWxzZSB2YWx1ZXMgaW5kaWNhdGluZyB3aGljaCBwYXRjaGVzIHdlcmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0c1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgT2xkIHRleHRcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmd8QXJyYXkuPGJvb2xlYW4+Pn0gVHdvIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgIG5ldyB0ZXh0IGFuZCBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlc1xuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hcHBseSA9IGZ1bmN0aW9uIChwYXRjaGVzLCB0ZXh0KSB7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIFt0ZXh0LCBbXV07XG4gIH1cblxuICAvLyBEZWVwIGNvcHkgdGhlIHBhdGNoZXMgc28gdGhhdCBubyBjaGFuZ2VzIGFyZSBtYWRlIHRvIG9yaWdpbmFscy5cbiAgdmFyIHBhdGNoZXNDb3B5ID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHZhciBwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgdmFyIHBhdGNoQ29weSA9IG5ldyBwYXRjaF9vYmooKTtcbiAgICBwYXRjaENvcHkuZGlmZnMgPSBwYXRjaC5kaWZmcy5zbGljZSgpO1xuICAgIHBhdGNoQ29weS5zdGFydDEgPSBwYXRjaC5zdGFydDE7XG4gICAgcGF0Y2hDb3B5LnN0YXJ0MiA9IHBhdGNoLnN0YXJ0MjtcbiAgICBwYXRjaENvcHkubGVuZ3RoMSA9IHBhdGNoLmxlbmd0aDE7XG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDIgPSBwYXRjaC5sZW5ndGgyO1xuICAgIHBhdGNoZXNDb3B5W3hdID0gcGF0Y2hDb3B5O1xuICB9XG4gIHBhdGNoZXMgPSBwYXRjaGVzQ29weTtcblxuICB2YXIgbnVsbFBhZGRpbmcgPSB0aGlzLnBhdGNoX2FkZFBhZGRpbmcocGF0Y2hlcyk7XG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZztcblxuICB0aGlzLnBhdGNoX3NwbGl0TWF4KHBhdGNoZXMpO1xuICAvLyBkZWx0YSBrZWVwcyB0cmFjayBvZiB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGV4cGVjdGVkIGFuZCBhY3R1YWwgbG9jYXRpb25cbiAgLy8gb2YgdGhlIHByZXZpb3VzIHBhdGNoLiAgSWYgdGhlcmUgYXJlIHBhdGNoZXMgZXhwZWN0ZWQgYXQgcG9zaXRpb25zIDEwIGFuZFxuICAvLyAyMCwgYnV0IHRoZSBmaXJzdCBwYXRjaCB3YXMgZm91bmQgYXQgMTIsIGRlbHRhIGlzIDIgYW5kIHRoZSBzZWNvbmQgcGF0Y2hcbiAgLy8gaGFzIGFuIGVmZmVjdGl2ZSBleHBlY3RlZCBwb3NpdGlvbiBvZiAyMi5cbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGV4cGVjdGVkX2xvYyA9IHBhdGNoZXNbeF0uc3RhcnQyICsgZGVsdGE7XG4gICAgdmFyIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKHBhdGNoZXNbeF0uZGlmZnMpO1xuICAgIHZhciBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYyk7XG4gICAgaWYgKHN0YXJ0X2xvYyA9PT0gbnVsbCkge1xuICAgICAgLy8gTm8gbWF0Y2ggZm91bmQuICA6KFxuICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3VuZCBhIG1hdGNoLiAgOilcbiAgICAgIHJlc3VsdHNbeF0gPSB0cnVlO1xuICAgICAgZGVsdGEgPSBzdGFydF9sb2MgLSBleHBlY3RlZF9sb2M7XG4gICAgICB2YXIgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcbiAgICAgICAgLy8gUGVyZmVjdCBtYXRjaCwganVzdCBzaG92ZSB0aGUgcmVwbGFjZW1lbnQgdGV4dCBpbi5cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYykgK1xuICAgICAgICAgIHRoaXMuZGlmZl90ZXh0MihwYXRjaGVzW3hdLmRpZmZzKSArXG4gICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEltcGVyZmVjdCBtYXRjaC4gIFJ1biBhIGRpZmYgdG8gZ2V0IGEgZnJhbWV3b3JrIG9mIGVxdWl2YWxlbnRcbiAgICAgICAgLy8gaW5kaWNpZXMuXG4gICAgICAgIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UpO1xuICAgICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICB2YXIgaW5kZXgxID0gMDtcbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaGVzW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgdmFyIG1vZCA9IHBhdGNoZXNbeF0uZGlmZnNbeV07XG4gICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5kaWZmX3hJbmRleChkaWZmcywgaW5kZXgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZFswXSA9PT0gRElGRl9JTlNFUlQpIHsgIC8vIEluc2VydGlvblxuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgKyBtb2RbMV0gK1xuICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyBpbmRleDIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobW9kWzBdID09PSBESUZGX0RFTEVURSkgeyAgLy8gRGVsZXRpb25cbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICtcbiAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGhpcy5kaWZmX3hJbmRleChkaWZmcyxcbiAgICAgICAgICAgICAgICBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfREVMRVRFKSB7XG4gICAgICAgICAgICBpbmRleDEgKz0gbW9kWzFdLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gU3RyaXAgdGhlIHBhZGRpbmcgb2ZmLlxuICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCk7XG4gIHJldHVybiBbdGV4dCwgcmVzdWx0c107XG59O1xuXG5cbi8qKlxuICogQWRkIHNvbWUgcGFkZGluZyBvbiB0ZXh0IHN0YXJ0IGFuZCBlbmQgc28gdGhhdCBlZGdlcyBjYW4gbWF0Y2ggc29tZXRoaW5nLlxuICogQHBhcmFtIHtBcnJheS48cGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBwYXRjaCBvYmplY3RzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkaW5nIHN0cmluZyBhZGRlZCB0byBlYWNoIHNpZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRQYWRkaW5nID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgdmFyIG51bGxQYWRkaW5nID0gJyc7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5QYXRjaF9NYXJnaW47IHgrKykge1xuICAgIG51bGxQYWRkaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gIH1cblxuICAvLyBCdW1wIGFsbCB0aGUgcGF0Y2hlcyBmb3J3YXJkLlxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MSArPSBudWxsUGFkZGluZy5sZW5ndGg7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDIgKz0gbnVsbFBhZGRpbmcubGVuZ3RoO1xuICB9XG5cbiAgLy8gQWRkIHNvbWUgcGFkZGluZyBvbiBzdGFydCBvZiBmaXJzdCBkaWZmLlxuICB2YXIgcGF0Y2ggPSBwYXRjaGVzWzBdO1xuICB2YXIgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PSAwIHx8IGRpZmZzWzBdWzBdICE9IERJRkZfRVFVQUwpIHtcbiAgICAvLyBBZGQgbnVsbFBhZGRpbmcgZXF1YWxpdHkuXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKTtcbiAgICBwYXRjaC5zdGFydDEgLT0gbnVsbFBhZGRpbmcubGVuZ3RoOyAgLy8gU2hvdWxkIGJlIDAuXG4gICAgcGF0Y2guc3RhcnQyIC09IG51bGxQYWRkaW5nLmxlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxuICAgIHBhdGNoLmxlbmd0aDEgKz0gbnVsbFBhZGRpbmcubGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gbnVsbFBhZGRpbmcubGVuZ3RoO1xuICB9IGVsc2UgaWYgKG51bGxQYWRkaW5nLmxlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xuICAgIC8vIEdyb3cgZmlyc3QgZXF1YWxpdHkuXG4gICAgdmFyIGV4dHJhTGVuZ3RoID0gbnVsbFBhZGRpbmcubGVuZ3RoIC0gZGlmZnNbMF1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzWzBdWzFdID0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKGRpZmZzWzBdWzFdLmxlbmd0aCkgKyBkaWZmc1swXVsxXTtcbiAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gZW5kIG9mIGxhc3QgZGlmZi5cbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XG4gIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVswXSAhPSBESUZGX0VRVUFMKSB7XG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XG4gICAgcGF0Y2gubGVuZ3RoMSArPSBudWxsUGFkZGluZy5sZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBudWxsUGFkZGluZy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAobnVsbFBhZGRpbmcubGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgLy8gR3JvdyBsYXN0IGVxdWFsaXR5LlxuICAgIHZhciBleHRyYUxlbmd0aCA9IG51bGxQYWRkaW5nLmxlbmd0aCAtIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSArPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoMCwgZXh0cmFMZW5ndGgpO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBudWxsUGFkZGluZztcbn07XG5cblxuLyoqXG4gKiBMb29rIHRocm91Z2ggdGhlIHBhdGNoZXMgYW5kIGJyZWFrIHVwIGFueSB3aGljaCBhcmUgbG9uZ2VyIHRoYW4gdGhlIG1heGltdW1cbiAqIGxpbWl0IG9mIHRoZSBtYXRjaCBhbGdvcml0aG0uXG4gKiBAcGFyYW0ge0FycmF5LjxwYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIHBhdGNoIG9iamVjdHNcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfc3BsaXRNYXggPSBmdW5jdGlvbiAocGF0Y2hlcykge1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAocGF0Y2hlc1t4XS5sZW5ndGgxID4gdGhpcy5NYXRjaF9NYXhCaXRzKSB7XG4gICAgICB2YXIgYmlncGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgICAgLy8gUmVtb3ZlIHRoZSBiaWcgb2xkIHBhdGNoLlxuICAgICAgcGF0Y2hlcy5zcGxpY2UoeCwgMSk7XG4gICAgICB2YXIgcGF0Y2hfc2l6ZSA9IHRoaXMuTWF0Y2hfTWF4Qml0cztcbiAgICAgIHZhciBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDE7XG4gICAgICB2YXIgc3RhcnQyID0gYmlncGF0Y2guc3RhcnQyO1xuICAgICAgdmFyIHByZWNvbnRleHQgPSAnJztcbiAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gQ3JlYXRlIG9uZSBvZiBzZXZlcmFsIHNtYWxsZXIgcGF0Y2hlcy5cbiAgICAgICAgdmFyIHBhdGNoID0gbmV3IHBhdGNoX29iaigpO1xuICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICBwYXRjaC5zdGFydDEgPSBzdGFydDEgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgcGF0Y2guc3RhcnQyID0gc3RhcnQyIC0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChwcmVjb250ZXh0ICE9PSAnJykge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcHJlY29udGV4dF0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxIDwgcGF0Y2hfc2l6ZSAtIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XG4gICAgICAgICAgdmFyIGRpZmZfdHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICAgIHZhciBkaWZmX3RleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXTtcbiAgICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0aW9ucyBhcmUgaGFybWxlc3MuXG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goYmlncGF0Y2guZGlmZnMuc2hpZnQoKSk7XG4gICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGlvbiBvciBlcXVhbGl0eS4gIE9ubHkgdGFrZSBhcyBtdWNoIGFzIHdlIGNhbiBzdG9tYWNoLlxuICAgICAgICAgICAgZGlmZl90ZXh0ID0gZGlmZl90ZXh0LnN1YnN0cmluZygwLCBwYXRjaF9zaXplIC0gcGF0Y2gubGVuZ3RoMSAtXG4gICAgICAgICAgICAgIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XG4gICAgICAgICAgICBpZiAoZGlmZl90ZXh0ID09IGJpZ3BhdGNoLmRpZmZzWzBdWzFdKSB7XG4gICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXSA9XG4gICAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0uc3Vic3RyaW5nKGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBoZWFkIGNvbnRleHQgZm9yIHRoZSBuZXh0IHBhdGNoLlxuICAgICAgICBwcmVjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQyKHBhdGNoLmRpZmZzKTtcbiAgICAgICAgcHJlY29udGV4dCA9XG4gICAgICAgICAgcHJlY29udGV4dC5zdWJzdHJpbmcocHJlY29udGV4dC5sZW5ndGggLSB0aGlzLlBhdGNoX01hcmdpbik7XG4gICAgICAgIC8vIEFwcGVuZCB0aGUgZW5kIGNvbnRleHQgZm9yIHRoaXMgcGF0Y2guXG4gICAgICAgIHZhciBwb3N0Y29udGV4dCA9IHRoaXMuZGlmZl90ZXh0MShiaWdwYXRjaC5kaWZmcylcbiAgICAgICAgICAuc3Vic3RyaW5nKDAsIHRoaXMuUGF0Y2hfTWFyZ2luKTtcbiAgICAgICAgaWYgKHBvc3Rjb250ZXh0ICE9PSAnJykge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgIGlmIChwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVsxXSArPSBwb3N0Y29udGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcG9zdGNvbnRleHRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgIHBhdGNoZXMuc3BsaWNlKHgrKywgMCwgcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogVGFrZSBhIGxpc3Qgb2YgcGF0Y2hlcyBhbmQgcmV0dXJuIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPHBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgcGF0Y2ggb2JqZWN0c1xuICogQHJldHVybiB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXNcbiAqL1xuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfdG9UZXh0ID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgdmFyIHRleHQgPSBbXTtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogUGFyc2UgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgcGF0Y2ggb2JqZWN0cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0bGluZSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXNcbiAqIEByZXR1cm4ge0FycmF5LjxwYXRjaF9vYmo+fSBBcnJheSBvZiBwYXRjaCBvYmplY3RzXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaW52YWxpZCBpbnB1dFxuICovXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9mcm9tVGV4dCA9IGZ1bmN0aW9uICh0ZXh0bGluZSkge1xuICB2YXIgcGF0Y2hlcyA9IFtdO1xuICBpZiAoIXRleHRsaW5lKSB7XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBkZWNvZGUgY2hhciAwLlxuICB0ZXh0bGluZSA9IHRleHRsaW5lLnJlcGxhY2UoLyUwMC9nLCAnXFwwJyk7XG4gIHZhciB0ZXh0ID0gdGV4dGxpbmUuc3BsaXQoJ1xcbicpO1xuICB2YXIgdGV4dFBvaW50ZXIgPSAwO1xuICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBtID0gdGV4dFt0ZXh0UG9pbnRlcl0ubWF0Y2goL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLyk7XG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggc3RyaW5nOiAnICsgdGV4dFt0ZXh0UG9pbnRlcl0pO1xuICAgIH1cbiAgICB2YXIgcGF0Y2ggPSBuZXcgcGF0Y2hfb2JqKCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICBwYXRjaC5zdGFydDEgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgaWYgKG1bMl0gPT09ICcnKSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAxO1xuICAgIH0gZWxzZSBpZiAobVsyXSA9PSAnMCcpIHtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaC5zdGFydDEtLTtcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgfVxuXG4gICAgcGF0Y2guc3RhcnQyID0gcGFyc2VJbnQobVszXSwgMTApO1xuICAgIGlmIChtWzRdID09PSAnJykge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMTtcbiAgICB9IGVsc2UgaWYgKG1bNF0gPT0gJzAnKSB7XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gcGFyc2VJbnQobVs0XSwgMTApO1xuICAgIH1cbiAgICB0ZXh0UG9pbnRlcisrO1xuXG4gICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciBzaWduID0gdGV4dFt0ZXh0UG9pbnRlcl0uY2hhckF0KDApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxpbmUgPSBkZWNvZGVVUkkodGV4dFt0ZXh0UG9pbnRlcl0uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gcGF0Y2hfZnJvbVRleHQ6ICcgKyBsaW5lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduID09ICctJykge1xuICAgICAgICAvLyBEZWxldGlvbi5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9ERUxFVEUsIGxpbmVdKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnKycpIHtcbiAgICAgICAgLy8gSW5zZXJ0aW9uLlxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0lOU0VSVCwgbGluZV0pO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICcgJykge1xuICAgICAgICAvLyBNaW5vciBlcXVhbGl0eS5cbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbGluZV0pO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09ICdAJykge1xuICAgICAgICAvLyBTdGFydCBvZiBuZXh0IHBhdGNoLlxuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gJycpIHtcbiAgICAgICAgLy8gQmxhbmsgbGluZT8gIFdoYXRldmVyLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV1RGP1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicgKyBzaWduICsgJ1wiIGluOiAnICsgbGluZSk7XG4gICAgICB9XG4gICAgICB0ZXh0UG9pbnRlcisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn07XG5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIHBhdGNoIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBwYXRjaF9vYmooKSB7XG4gIHRoaXMuZGlmZnMgPSBbXTtcbiAgLyoqIEB0eXBlIHtudW1iZXI/fSAqL1xuICB0aGlzLnN0YXJ0MSA9IG51bGw7XG4gIC8qKiBAdHlwZSB7bnVtYmVyP30gKi9cbiAgdGhpcy5zdGFydDIgPSBudWxsO1xuICB0aGlzLmxlbmd0aDEgPSAwO1xuICB0aGlzLmxlbmd0aDIgPSAwO1xufVxuXG5cbi8qKlxuICogRW1tdWxhdGUgR05VIGRpZmYncyBmb3JtYXQuXG4gKiBIZWFkZXI6IEBAIC0zODIsOCArNDgxLDkgQEBcbiAqIEluZGljaWVzIGFyZSBwcmludGVkIGFzIDEtYmFzZWQsIG5vdCAwLWJhc2VkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgR05VIGRpZmYgc3RyaW5nXG4gKi9cbnBhdGNoX29iai5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb29yZHMxLCBjb29yZHMyO1xuICBpZiAodGhpcy5sZW5ndGgxID09PSAwKSB7XG4gICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgJywwJztcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDEgPT0gMSkge1xuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIDE7XG4gIH0gZWxzZSB7XG4gICAgY29vcmRzMSA9ICh0aGlzLnN0YXJ0MSArIDEpICsgJywnICsgdGhpcy5sZW5ndGgxO1xuICB9XG4gIGlmICh0aGlzLmxlbmd0aDIgPT09IDApIHtcbiAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAnLDAnO1xuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoMiA9PSAxKSB7XG4gICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgMTtcbiAgfSBlbHNlIHtcbiAgICBjb29yZHMyID0gKHRoaXMuc3RhcnQyICsgMSkgKyAnLCcgKyB0aGlzLmxlbmd0aDI7XG4gIH1cbiAgdmFyIHR4dCA9IFsnQEAgLScgKyBjb29yZHMxICsgJyArJyArIGNvb3JkczIgKyAnIEBAXFxuJ107XG4gIHZhciBvcDtcbiAgLy8gRXNjYXBlIHRoZSBib2R5IG9mIHRoZSBwYXRjaCB3aXRoICV4eCBub3RhdGlvbi5cbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgc3dpdGNoICh0aGlzLmRpZmZzW3hdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBvcCA9ICcrJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBvcCA9ICctJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIG9wID0gJyAnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdHh0W3ggKyAxXSA9IG9wICsgZW5jb2RlVVJJKHRoaXMuZGlmZnNbeF1bMV0pICsgJ1xcbic7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBrbm93IGhvdyB0byBlbmNvZGUgY2hhciAwLlxuICByZXR1cm4gdHh0LmpvaW4oJycpLnJlcGxhY2UoL1xcMC9nLCAnJTAwJykucmVwbGFjZSgvJTIwL2csICcgJyk7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gIHdpbmRvdy5kaWZmX21hdGNoX3BhdGNoID0gZGlmZl9tYXRjaF9wYXRjaDtcblxufSkuY2FsbCh0aGlzKTsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuNC4zXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMCwgSm9obiBSZXNpZ1xuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICogQ29weXJpZ2h0IDIwMTAsIFRoZSBEb2pvIEZvdW5kYXRpb25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQsIEJTRCwgYW5kIEdQTCBMaWNlbnNlcy5cbiAqXG4gKiBEYXRlOiBUaHUgT2N0IDE0IDIzOjEwOjA2IDIwMTAgLTA0MDBcbiAqL1xuXG4oZnVuY3Rpb24gKHdpbmRvdywgdW5kZWZpbmVkKSB7XG5cbiAgICAvLyBVc2UgdGhlIGNvcnJlY3QgZG9jdW1lbnQgYWNjb3JkaW5nbHkgd2l0aCB3aW5kb3cgYXJndW1lbnQgKHNhbmRib3gpXG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgIHZhciBqUXVlcnkgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG4gICAgICAgIHZhciBqUXVlcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdChzZWxlY3RvciwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgICAgICAgICAgX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cbiAgICAgICAgICAgIC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgICAgICAgICBfJCA9IHdpbmRvdy4kLFxuXG4gICAgICAgICAgICAvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbiAgICAgICAgICAgIHJvb3RqUXVlcnksXG5cbiAgICAgICAgICAgIC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzIG9yIElEIHN0cmluZ3NcbiAgICAgICAgICAgIC8vIChib3RoIG9mIHdoaWNoIHdlIG9wdGltaXplIGZvcilcbiAgICAgICAgICAgIHF1aWNrRXhwciA9IC9eKD86W148XSooPFtcXHdcXFddKz4pW14+XSokfCMoW1xcd1xcLV0rKSQpLyxcblxuICAgICAgICAgICAgLy8gSXMgaXQgYSBzaW1wbGUgc2VsZWN0b3JcbiAgICAgICAgICAgIGlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvLFxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhIHN0cmluZyBoYXMgYSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgaW4gaXRcbiAgICAgICAgICAgIHJub3R3aGl0ZSA9IC9cXFMvLFxuICAgICAgICAgICAgcndoaXRlID0gL1xccy8sXG5cbiAgICAgICAgICAgIC8vIFVzZWQgZm9yIHRyaW1taW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHRyaW1MZWZ0ID0gL15cXHMrLyxcbiAgICAgICAgICAgIHRyaW1SaWdodCA9IC9cXHMrJC8sXG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBub24td29yZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBybm9ud29yZCA9IC9cXFcvLFxuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZGlnaXRzXG4gICAgICAgICAgICByZGlnaXQgPSAvXFxkLyxcblxuICAgICAgICAgICAgLy8gTWF0Y2ggYSBzdGFuZGFsb25lIHRhZ1xuICAgICAgICAgICAgcnNpbmdsZVRhZyA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+KT8kLyxcblxuICAgICAgICAgICAgLy8gSlNPTiBSZWdFeHBcbiAgICAgICAgICAgIHJ2YWxpZGNoYXJzID0gL15bXFxdLDp7fVxcc10qJC8sXG4gICAgICAgICAgICBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nLFxuICAgICAgICAgICAgcnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLFxuICAgICAgICAgICAgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLFxuXG4gICAgICAgICAgICAvLyBVc2VyYWdlbnQgUmVnRXhwXG4gICAgICAgICAgICByd2Via2l0ID0gLyh3ZWJraXQpWyBcXC9dKFtcXHcuXSspLyxcbiAgICAgICAgICAgIHJvcGVyYSA9IC8ob3BlcmEpKD86Lip2ZXJzaW9uKT9bIFxcL10oW1xcdy5dKykvLFxuICAgICAgICAgICAgcm1zaWUgPSAvKG1zaWUpIChbXFx3Ll0rKS8sXG4gICAgICAgICAgICBybW96aWxsYSA9IC8obW96aWxsYSkoPzouKj8gcnY6KFtcXHcuXSspKT8vLFxuXG4gICAgICAgICAgICAvLyBLZWVwIGEgVXNlckFnZW50IHN0cmluZyBmb3IgdXNlIHdpdGggalF1ZXJ5LmJyb3dzZXJcbiAgICAgICAgICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG5cbiAgICAgICAgICAgIC8vIEZvciBtYXRjaGluZyB0aGUgZW5naW5lIGFuZCB2ZXJzaW9uIG9mIHRoZSBicm93c2VyXG4gICAgICAgICAgICBicm93c2VyTWF0Y2gsXG5cbiAgICAgICAgICAgIC8vIEhhcyB0aGUgcmVhZHkgZXZlbnRzIGFscmVhZHkgYmVlbiBib3VuZD9cbiAgICAgICAgICAgIHJlYWR5Qm91bmQgPSBmYWxzZSxcblxuICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9ucyB0byBleGVjdXRlIG9uIERPTSByZWFkeVxuICAgICAgICAgICAgcmVhZHlMaXN0ID0gW10sXG5cbiAgICAgICAgICAgIC8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBET01Db250ZW50TG9hZGVkLFxuXG4gICAgICAgICAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHNvbWUgY29yZSBtZXRob2RzXG4gICAgICAgICAgICB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgICAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgICAgICAgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoLFxuICAgICAgICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICAgICAgICB0cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltLFxuICAgICAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLFxuXG4gICAgICAgICAgICAvLyBbW0NsYXNzXV0gLT4gdHlwZSBwYWlyc1xuICAgICAgICAgICAgY2xhc3MydHlwZSA9IHt9O1xuXG4gICAgICAgIGpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2gsIGVsZW0sIHJldCwgZG9jO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlICQoXCJcIiksICQobnVsbCksIG9yICQodW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlICQoRE9NRWxlbWVudClcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3Iubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoZSBib2R5IGVsZW1lbnQgb25seSBleGlzdHMgb25jZSwgb3B0aW1pemUgZmluZGluZyBpdFxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gXCJib2R5XCIgJiYgIWNvbnRleHQgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1swXSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSBcImJvZHlcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcmUgd2UgZGVhbGluZyB3aXRoIEhUTUwgc3RyaW5nIG9yIGFuIElEP1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHF1aWNrRXhwci5leGVjKHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgYSBtYXRjaCwgYW5kIHRoYXQgbm8gY29udGV4dCB3YXMgc3BlY2lmaWVkIGZvciAjaWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSAoY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzaW5nbGUgc3RyaW5nIGlzIHBhc3NlZCBpbiBhbmQgaXQncyBhIHNpbmdsZSB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGRvIGEgY3JlYXRlRWxlbWVudCBhbmQgc2tpcCB0aGUgcmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHJzaW5nbGVUYWcuZXhlYyhzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNQbGFpbk9iamVjdChjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBbZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyZXRbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5mbi5hdHRyLmNhbGwoc2VsZWN0b3IsIGNvbnRleHQsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IFtkb2MuY3JlYXRlRWxlbWVudChyZXRbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoW21hdGNoWzFdXSwgW2RvY10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IChyZXQuY2FjaGVhYmxlID8gcmV0LmZyYWdtZW50LmNsb25lTm9kZSh0cnVlKSA6IHJldC5mcmFnbWVudCkuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKHRoaXMsIHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChcIiNpZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMl0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSBhbmQgT3BlcmEgcmV0dXJuIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5pZCAhPT0gbWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb290alF1ZXJ5LmZpbmQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBpbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0gPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKFwiVEFHXCIpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbnRleHQgJiYgIXJub253b3JkLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSh0aGlzLCBzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY29udGV4dCB8fCByb290alF1ZXJ5KS5maW5kKHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkoY29udGV4dCkuZmluZChzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb290alF1ZXJ5LnJlYWR5KHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3Iuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoc2VsZWN0b3IsIHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuICAgICAgICAgICAgc2VsZWN0b3I6IFwiXCIsXG5cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcbiAgICAgICAgICAgIGpxdWVyeTogXCIxLjQuM1wiLFxuXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcbiAgICAgICAgICAgIGxlbmd0aDogMCxcblxuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcbiAgICAgICAgICAgIHNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcywgMCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bSA9PSBudWxsID9cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYSAnY2xlYW4nIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9BcnJheSgpIDpcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4ganVzdCB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIChudW0gPCAwID8gdGhpcy5zbGljZShudW0pWzBdIDogdGhpc1tudW1dKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcbiAgICAgICAgICAgIC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuICAgICAgICAgICAgcHVzaFN0YWNrOiBmdW5jdGlvbiAoZWxlbXMsIG5hbWUsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0galF1ZXJ5KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkoZWxlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmV0LCBlbGVtcyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2UocmV0LCBlbGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcbiAgICAgICAgICAgICAgICByZXQucHJldk9iamVjdCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICByZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcImZpbmRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yICsgKHRoaXMuc2VsZWN0b3IgPyBcIiBcIiA6IFwiXCIpICsgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgKyBcIi5cIiArIG5hbWUgKyBcIihcIiArIHNlbGVjdG9yICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cbiAgICAgICAgICAgIC8vIChZb3UgY2FuIHNlZWQgdGhlIGFyZ3VtZW50cyB3aXRoIGFuIGFycmF5IG9mIGFyZ3MsIGJ1dCB0aGlzIGlzXG4gICAgICAgICAgICAvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXG4gICAgICAgICAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LmVhY2godGhpcywgY2FsbGJhY2ssIGFyZ3MpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVhZHk6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmJpbmRSZWFkeSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIERPTSBpcyBhbHJlYWR5IHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGZ1bmN0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoZG9jdW1lbnQsIGpRdWVyeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCByZW1lbWJlciB0aGUgZnVuY3Rpb24gZm9yIGxhdGVyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWFkeUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBmdW5jdGlvbiB0byB0aGUgd2FpdCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5TGlzdC5wdXNoKGZuKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVxOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpID09PSAtMSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpY2UoaSkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWNlKGksICtpICsgMSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmaXJzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKDApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbGFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKC0xKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNsaWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIFwic2xpY2VcIiwgc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG1hcDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoZWxlbSwgaSwgZWxlbSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCBqUXVlcnkobnVsbCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICAgICAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cbiAgICAgICAgICAgIHB1c2g6IHB1c2gsXG4gICAgICAgICAgICBzb3J0OiBbXS5zb3J0LFxuICAgICAgICAgICAgc3BsaWNlOiBbXS5zcGxpY2VcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG4gICAgICAgIGpRdWVyeS5mbi5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuICAgICAgICBqUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvcHkgcmVmZXJlbmNlIHRvIHRhcmdldCBvYmplY3RcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBkZWVwID0gZmFsc2UsIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICBpID0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IGkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBqUXVlcnkuZXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgICAgICBub0NvbmZsaWN0OiBmdW5jdGlvbiAoZGVlcCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy4kID0gXyQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cbiAgICAgICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG4gICAgICAgICAgICAvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuICAgICAgICAgICAgcmVhZHlXYWl0OiAxLFxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG4gICAgICAgICAgICByZWFkeTogZnVuY3Rpb24gKHdhaXQpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHRoaXJkLXBhcnR5IGlzIHB1c2hpbmcgdGhlIHJlYWR5IGV2ZW50IGZvcndhcmRzXG4gICAgICAgICAgICAgICAgaWYgKHdhaXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5V2FpdC0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBET00gaXMgbm90IGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkucmVhZHlXYWl0IHx8ICh3YWl0ICE9PSB0cnVlICYmICFqUXVlcnkuaXNSZWFkeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGJvZHkgZXhpc3RzLCBhdCBsZWFzdCwgaW4gY2FzZSBJRSBnZXRzIGEgbGl0dGxlIG92ZXJ6ZWFsb3VzICh0aWNrZXQgIzU0NDMpLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGpRdWVyeS5yZWFkeSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5TGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBhbGwgb2YgdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuLCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZm4gPSByZWFkeUxpc3RbaSsrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKGRvY3VtZW50LCBqUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgbGlzdCBvZiBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5TGlzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcInJlYWR5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmluZFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5Qm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlYWR5Qm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChqUXVlcnkucmVhZHksIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1vemlsbGEsIE9wZXJhIGFuZCB3ZWJraXQgbmlnaHRsaWVzIGN1cnJlbnRseSBzdXBwb3J0IHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgalF1ZXJ5LnJlYWR5LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgSUUgZXZlbnQgbW9kZWwgaXMgdXNlZFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGZpcmluZyBiZWZvcmUgb25sb2FkLFxuICAgICAgICAgICAgICAgICAgICAvLyBtYXliZSBsYXRlIGJ1dCBzYWZlIGFsc28gZm9yIGlmcmFtZXNcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgRE9NQ29udGVudExvYWRlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KFwib25sb2FkXCIsIGpRdWVyeS5yZWFkeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgSUUgYW5kIG5vdCBhIGZyYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcGxldmVsID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGxldmVsID0gd2luZG93LmZyYW1lRWxlbWVudCA9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICYmIHRvcGxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb1Njcm9sbENoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBTZWUgdGVzdC91bml0L2NvcmUuanMgZm9yIGRldGFpbHMgY29uY2VybmluZyBpc0Z1bmN0aW9uLlxuICAgICAgICAgICAgLy8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydFxuICAgICAgICAgICAgLy8gYXJlbid0IHN1cHBvcnRlZC4gVGhleSByZXR1cm4gZmFsc2Ugb24gSUUgKCMyOTY4KS5cbiAgICAgICAgICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiYXJyYXlcIjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEEgY3J1ZGUgd2F5IG9mIGRldGVybWluaW5nIGlmIGFuIG9iamVjdCBpcyBhIHdpbmRvd1xuICAgICAgICAgICAgaXNXaW5kb3c6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgXCJzZXRJbnRlcnZhbFwiIGluIG9iajtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzTmFOOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiA9PSBudWxsIHx8ICFyZGlnaXQudGVzdChvYmopIHx8IGlzTmFOKG9iaik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nKG9iaikgOlxuICAgICAgICAgICAgICAgICAgICBjbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXCJvYmplY3RcIjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAvLyBNdXN0IGJlIGFuIE9iamVjdC5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXMgd2VsbFxuICAgICAgICAgICAgICAgIGlmICghb2JqIHx8IGpRdWVyeS50eXBlKG9iaikgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyhvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duLmNhbGwob2JqLCBcImNvbnN0cnVjdG9yXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICFoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuICAgICAgICAgICAgICAgIC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duLlxuXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHsgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKG9iaiwga2V5KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBtc2c7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXJzZUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiIHx8ICFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZCAoSUUgY2FuJ3QgaGFuZGxlIGl0KVxuICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkudHJpbShkYXRhKTtcblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5jb21pbmcgZGF0YSBpcyBhY3R1YWwgSlNPTlxuICAgICAgICAgICAgICAgIC8vIExvZ2ljIGJvcnJvd2VkIGZyb20gaHR0cDovL2pzb24ub3JnL2pzb24yLmpzXG4gICAgICAgICAgICAgICAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgXCJAXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgXCJcIikpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHVzZSB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuSlNPTiAmJiB3aW5kb3cuSlNPTi5wYXJzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuSlNPTi5wYXJzZShkYXRhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAobmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgZGF0YSkpKCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoXCJJbnZhbGlkIEpTT046IFwiICsgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbm9vcDogZnVuY3Rpb24gKCkgeyB9LFxuXG4gICAgICAgICAgICAvLyBFdmFsdWxhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcbiAgICAgICAgICAgIGdsb2JhbEV2YWw6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgcm5vdHdoaXRlLnRlc3QoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zcGlyZWQgYnkgY29kZSBieSBBbmRyZWEgR2lhbW1hcmNoaVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd2VicmVmbGVjdGlvbi5ibG9nc3BvdC5jb20vMjAwNy8wOC9nbG9iYWwtc2NvcGUtZXZhbHVhdGlvbi1hbmQtZG9tLmh0bWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5zdXBwb3J0LnNjcmlwdEV2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudGV4dCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgYXBwZW5kQ2hpbGQgdG8gY2lyY3VtdmVudCBhbiBJRTYgYnVnLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFyaXNlcyB3aGVuIGEgYmFzZSBub2RlIGlzIHVzZWQgKCMyNzA5KS5cbiAgICAgICAgICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbm9kZU5hbWU6IGZ1bmN0aW9uIChlbGVtLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICAgICAgICBlYWNoOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaywgYXJncykge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lLCBpID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaXNPYmogPSBsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmFwcGx5KG9iamVjdFtuYW1lXSwgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5hcHBseShvYmplY3RbaSsrXSwgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqZWN0W25hbWVdLCBuYW1lLCBvYmplY3RbbmFtZV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2YWx1ZSA9IG9iamVjdFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIDwgbGVuZ3RoICYmIGNhbGxiYWNrLmNhbGwodmFsdWUsIGksIHZhbHVlKSAhPT0gZmFsc2U7IHZhbHVlID0gb2JqZWN0WysraV0pIHsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgU3RyaW5nLnRyaW0gZnVuY3Rpb24gd2hlcmV2ZXIgcG9zc2libGVcbiAgICAgICAgICAgIHRyaW06IHRyaW0gP1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltLmNhbGwodGV4dCk7XG4gICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIG91ciBvd24gdHJpbW1pbmcgZnVuY3Rpb25hbGl0eVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnRvU3RyaW5nKCkucmVwbGFjZSh0cmltTGVmdCwgXCJcIikucmVwbGFjZSh0cmltUmlnaHQsIFwiXCIpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcbiAgICAgICAgICAgIG1ha2VBcnJheTogZnVuY3Rpb24gKGFycmF5LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJyYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd2luZG93LCBzdHJpbmdzIChhbmQgZnVuY3Rpb25zKSBhbHNvIGhhdmUgJ2xlbmd0aCdcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4dHJhIHR5cGVvZiBmdW5jdGlvbiBjaGVjayBpcyB0byBwcmV2ZW50IGNyYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gU2FmYXJpIDIgKFNlZTogIzMwMzkpXG4gICAgICAgICAgICAgICAgICAgIC8vIFR3ZWFrZWQgbG9naWMgc2xpZ2h0bHkgdG8gaGFuZGxlIEJsYWNrYmVycnkgNC43IFJlZ0V4cCBpc3N1ZXMgIzY5MzBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBqUXVlcnkudHlwZShhcnJheSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGUgPT09IFwicmVnZXhwXCIgfHwgalF1ZXJ5LmlzV2luZG93KGFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKHJldCwgYXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHJldCwgYXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGluQXJyYXk6IGZ1bmN0aW9uIChlbGVtLCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBmaXJzdC5sZW5ndGgsIGogPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmQubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBzZWNvbmQubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFtpKytdID0gc2Vjb25kW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2Vjb25kW2pdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0W2krK10gPSBzZWNvbmRbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpcnN0Lmxlbmd0aCA9IGk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBncmVwOiBmdW5jdGlvbiAoZWxlbXMsIGNhbGxiYWNrLCBpbnYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW10sIHJldFZhbDtcbiAgICAgICAgICAgICAgICBpbnYgPSAhIWludjtcblxuICAgICAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSAhIWNhbGxiYWNrKGVsZW1zW2ldLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludiAhPT0gcmV0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChlbGVtc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgICAgICAgICBtYXA6IGZ1bmN0aW9uIChlbGVtcywgY2FsbGJhY2ssIGFyZykge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXSwgdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXJcbiAgICAgICAgICAgICAgICAvLyBuZXcgdmFsdWUgKG9yIHZhbHVlcykuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbXNbaV0sIGksIGFyZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldC5jb25jYXQuYXBwbHkoW10sIHJldCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcbiAgICAgICAgICAgIGd1aWQ6IDEsXG5cbiAgICAgICAgICAgIHByb3h5OiBmdW5jdGlvbiAoZm4sIHByb3h5LCB0aGlzT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm94eSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc09iamVjdCA9IGZuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSB0aGlzT2JqZWN0W3Byb3h5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJveHkgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHByb3h5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc09iamVjdCA9IHByb3h5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByb3h5ICYmIGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNPYmplY3QgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IHByb3h5Lmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTbyBwcm94eSBjYW4gYmUgZGVjbGFyZWQgYXMgYW4gYXJndW1lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBNdXRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIHRvIGEgY29sbGVjdGlvblxuICAgICAgICAgICAgLy8gVGhlIHZhbHVlL3MgY2FuIGJlIG9wdGlvbmFsbHkgYnkgZXhlY3V0ZWQgaWYgaXRzIGEgZnVuY3Rpb25cbiAgICAgICAgICAgIGFjY2VzczogZnVuY3Rpb24gKGVsZW1zLCBrZXksIHZhbHVlLCBleGVjLCBmbiwgcGFzcykge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIG1hbnkgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYWNjZXNzKGVsZW1zLCBrLCBrZXlba10sIGV4ZWMsIGZuLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgb25lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsbHksIGZ1bmN0aW9uIHZhbHVlcyBnZXQgZXhlY3V0ZWQgaWYgZXhlYyBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGV4ZWMgPSAhcGFzcyAmJiBleGVjICYmIGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbihlbGVtc1tpXSwga2V5LCBleGVjID8gdmFsdWUuY2FsbChlbGVtc1tpXSwgaSwgZm4oZWxlbXNbaV0sIGtleSkpIDogdmFsdWUsIHBhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldHRpbmcgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGZuKGVsZW1zWzBdLCBrZXkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbm93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBVc2Ugb2YgalF1ZXJ5LmJyb3dzZXIgaXMgZnJvd25lZCB1cG9uLlxuICAgICAgICAgICAgLy8gTW9yZSBkZXRhaWxzOiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1V0aWxpdGllcy9qUXVlcnkuYnJvd3NlclxuICAgICAgICAgICAgdWFNYXRjaDogZnVuY3Rpb24gKHVhKSB7XG4gICAgICAgICAgICAgICAgdWEgPSB1YS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcndlYmtpdC5leGVjKHVhKSB8fFxuICAgICAgICAgICAgICAgICAgICByb3BlcmEuZXhlYyh1YSkgfHxcbiAgICAgICAgICAgICAgICAgICAgcm1zaWUuZXhlYyh1YSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdWEuaW5kZXhPZihcImNvbXBhdGlibGVcIikgPCAwICYmIHJtb3ppbGxhLmV4ZWModWEpIHx8XG4gICAgICAgICAgICAgICAgICAgIFtdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYnJvd3NlcjogbWF0Y2hbMV0gfHwgXCJcIiwgdmVyc2lvbjogbWF0Y2hbMl0gfHwgXCIwXCIgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJyb3dzZXI6IHt9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuICAgICAgICBqUXVlcnkuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3RcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG4gICAgICAgICAgICBjbGFzczJ0eXBlW1wiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIl0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyb3dzZXJNYXRjaCA9IGpRdWVyeS51YU1hdGNoKHVzZXJBZ2VudCk7XG4gICAgICAgIGlmIChicm93c2VyTWF0Y2guYnJvd3Nlcikge1xuICAgICAgICAgICAgalF1ZXJ5LmJyb3dzZXJbYnJvd3Nlck1hdGNoLmJyb3dzZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGpRdWVyeS5icm93c2VyLnZlcnNpb24gPSBicm93c2VyTWF0Y2gudmVyc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlcHJlY2F0ZWQsIHVzZSBqUXVlcnkuYnJvd3Nlci53ZWJraXQgaW5zdGVhZFxuICAgICAgICBpZiAoalF1ZXJ5LmJyb3dzZXIud2Via2l0KSB7XG4gICAgICAgICAgICBqUXVlcnkuYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4T2YpIHtcbiAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5ID0gZnVuY3Rpb24gKGVsZW0sIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChhcnJheSwgZWxlbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgXFxzIG1hdGNoZXMgbm9uLWJyZWFraW5nIHNwYWNlc1xuICAgICAgICAvLyAoSUUgZmFpbHMgb24gdGhpcyB0ZXN0KVxuICAgICAgICBpZiAoIXJ3aGl0ZS50ZXN0KFwiXFx4QTBcIikpIHtcbiAgICAgICAgICAgIHRyaW1MZWZ0ID0gL15bXFxzXFx4QTBdKy87XG4gICAgICAgICAgICB0cmltUmlnaHQgPSAvW1xcc1xceEEwXSskLztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbCBqUXVlcnkgb2JqZWN0cyBzaG91bGQgcG9pbnQgYmFjayB0byB0aGVzZVxuICAgICAgICByb290alF1ZXJ5ID0galF1ZXJ5KGRvY3VtZW50KTtcblxuICAgICAgICAvLyBDbGVhbnVwIGZ1bmN0aW9ucyBmb3IgdGhlIGRvY3VtZW50IHJlYWR5IG1ldGhvZFxuICAgICAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgRE9NQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBET01Db250ZW50TG9hZGVkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlYWR5KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIERPTUNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGJvZHkgZXhpc3RzLCBhdCBsZWFzdCwgaW4gY2FzZSBJRSBnZXRzIGEgbGl0dGxlIG92ZXJ6ZWFsb3VzICh0aWNrZXQgIzU0NDMpLlxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZGV0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgRE9NQ29udGVudExvYWRlZCk7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgRE9NIHJlYWR5IGNoZWNrIGZvciBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgICBmdW5jdGlvbiBkb1Njcm9sbENoZWNrKCkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIElmIElFIGlzIHVzZWQsIHVzZSB0aGUgdHJpY2sgYnkgRGllZ28gUGVyaW5pXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC9cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwoXCJsZWZ0XCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZG9TY3JvbGxDaGVjaywgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhbmQgZXhlY3V0ZSBhbnkgd2FpdGluZyBmdW5jdGlvbnNcbiAgICAgICAgICAgIGpRdWVyeS5yZWFkeSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwb3NlIGpRdWVyeSB0byB0aGUgZ2xvYmFsIG9iamVjdFxuICAgICAgICByZXR1cm4gKHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeSk7XG5cbiAgICB9KSgpO1xuXG5cbiAgICAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGpRdWVyeS5zdXBwb3J0ID0ge307XG5cbiAgICAgICAgdmFyIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLFxuICAgICAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgIGlkID0gXCJzY3JpcHRcIiArIGpRdWVyeS5ub3coKTtcblxuICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCIgICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnIHN0eWxlPSdjb2xvcjpyZWQ7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41NTsnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+XCI7XG5cbiAgICAgICAgdmFyIGFsbCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIiksXG4gICAgICAgICAgICBhID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKVswXSxcbiAgICAgICAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXG4gICAgICAgICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSk7XG5cbiAgICAgICAgLy8gQ2FuJ3QgZ2V0IGJhc2ljIHRlc3Qgc3VwcG9ydFxuICAgICAgICBpZiAoIWFsbCB8fCAhYWxsLmxlbmd0aCB8fCAhYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgalF1ZXJ5LnN1cHBvcnQgPSB7XG4gICAgICAgICAgICAvLyBJRSBzdHJpcHMgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZW4gLmlubmVySFRNTCBpcyB1c2VkXG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZTogZGl2LmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMsXG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRib2R5IGVsZW1lbnRzIGFyZW4ndCBhdXRvbWF0aWNhbGx5IGluc2VydGVkXG4gICAgICAgICAgICAvLyBJRSB3aWxsIGluc2VydCB0aGVtIGludG8gZW1wdHkgdGFibGVzXG4gICAgICAgICAgICB0Ym9keTogIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCxcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MXG4gICAgICAgICAgICAvLyBUaGlzIHJlcXVpcmVzIGEgd3JhcHBlciBlbGVtZW50IGluIElFXG4gICAgICAgICAgICBodG1sU2VyaWFsaXplOiAhIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIikubGVuZ3RoLFxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHN0eWxlIGluZm9ybWF0aW9uIGZyb20gZ2V0QXR0cmlidXRlXG4gICAgICAgICAgICAvLyAoSUUgdXNlcyAuY3NzVGV4dCBpbnN0ZWQpXG4gICAgICAgICAgICBzdHlsZTogL3JlZC8udGVzdChhLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSxcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgVVJMcyBhcmVuJ3QgbWFuaXB1bGF0ZWRcbiAgICAgICAgICAgIC8vIChJRSBub3JtYWxpemVzIGl0IGJ5IGRlZmF1bHQpXG4gICAgICAgICAgICBocmVmTm9ybWFsaXplZDogYS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIi9hXCIsXG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGVsZW1lbnQgb3BhY2l0eSBleGlzdHNcbiAgICAgICAgICAgIC8vIChJRSB1c2VzIGZpbHRlciBpbnN0ZWFkKVxuICAgICAgICAgICAgLy8gVXNlIGEgcmVnZXggdG8gd29yayBhcm91bmQgYSBXZWJLaXQgaXNzdWUuIFNlZSAjNTE0NVxuICAgICAgICAgICAgb3BhY2l0eTogL14wLjU1JC8udGVzdChhLnN0eWxlLm9wYWNpdHkpLFxuXG4gICAgICAgICAgICAvLyBWZXJpZnkgc3R5bGUgZmxvYXQgZXhpc3RlbmNlXG4gICAgICAgICAgICAvLyAoSUUgdXNlcyBzdHlsZUZsb2F0IGluc3RlYWQgb2YgY3NzRmxvYXQpXG4gICAgICAgICAgICBjc3NGbG9hdDogISFhLnN0eWxlLmNzc0Zsb2F0LFxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBpZiBubyB2YWx1ZSBpcyBzcGVjaWZpZWQgZm9yIGEgY2hlY2tib3hcbiAgICAgICAgICAgIC8vIHRoYXQgaXQgZGVmYXVsdHMgdG8gXCJvblwiLlxuICAgICAgICAgICAgLy8gKFdlYktpdCBkZWZhdWx0cyB0byBcIlwiIGluc3RlYWQpXG4gICAgICAgICAgICBjaGVja09uOiBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXS52YWx1ZSA9PT0gXCJvblwiLFxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIHNlbGVjdGVkLWJ5LWRlZmF1bHQgb3B0aW9uIGhhcyBhIHdvcmtpbmcgc2VsZWN0ZWQgcHJvcGVydHkuXG4gICAgICAgICAgICAvLyAoV2ViS2l0IGRlZmF1bHRzIHRvIGZhbHNlIGluc3RlYWQgb2YgdHJ1ZSwgSUUgdG9vLCBpZiBpdCdzIGluIGFuIG9wdGdyb3VwKVxuICAgICAgICAgICAgb3B0U2VsZWN0ZWQ6IG9wdC5zZWxlY3RlZCxcblxuICAgICAgICAgICAgLy8gV2lsbCBiZSBkZWZpbmVkIGxhdGVyXG4gICAgICAgICAgICBvcHREaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBjaGVja0Nsb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHNjcmlwdEV2YWw6IGZhbHNlLFxuICAgICAgICAgICAgbm9DbG9uZUV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgYm94TW9kZWw6IG51bGwsXG4gICAgICAgICAgICBpbmxpbmVCbG9ja05lZWRzTGF5b3V0OiBmYWxzZSxcbiAgICAgICAgICAgIHNocmlua1dyYXBCbG9ja3M6IGZhbHNlLFxuICAgICAgICAgICAgcmVsaWFibGVIaWRkZW5PZmZzZXRzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIG9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlbid0IG1hcmtlZCBhcyBkaXNhYmxlZFxuICAgICAgICAvLyAoV2ViS2l0IG1hcmtzIHRoZW0gYXMgZGlhYmxlZClcbiAgICAgICAgc2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgalF1ZXJ5LnN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG4gICAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIndpbmRvdy5cIiArIGlkICsgXCI9MTtcIikpO1xuICAgICAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgICAgICByb290Lmluc2VydEJlZm9yZShzY3JpcHQsIHJvb3QuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGV4ZWN1dGlvbiBvZiBjb2RlIHdvcmtzIGJ5IGluamVjdGluZyBhIHNjcmlwdFxuICAgICAgICAvLyB0YWcgd2l0aCBhcHBlbmRDaGlsZC9jcmVhdGVUZXh0Tm9kZVxuICAgICAgICAvLyAoSUUgZG9lc24ndCBzdXBwb3J0IHRoaXMsIGZhaWxzLCBhbmQgdXNlcyAudGV4dCBpbnN0ZWFkKVxuICAgICAgICBpZiAod2luZG93W2lkXSkge1xuICAgICAgICAgICAgalF1ZXJ5LnN1cHBvcnQuc2NyaXB0RXZhbCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGUgd2luZG93W2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblxuICAgICAgICBpZiAoZGl2LmF0dGFjaEV2ZW50ICYmIGRpdi5maXJlRXZlbnQpIHtcbiAgICAgICAgICAgIGRpdi5hdHRhY2hFdmVudChcIm9uY2xpY2tcIiwgZnVuY3Rpb24gY2xpY2soKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvbmluZyBhIG5vZGUgc2hvdWxkbid0IGNvcHkgb3ZlciBhbnlcbiAgICAgICAgICAgICAgICAvLyBib3VuZCBldmVudCBoYW5kbGVycyAoSUUgZG9lcyB0aGlzKVxuICAgICAgICAgICAgICAgIGpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpdi5kZXRhY2hFdmVudChcIm9uY2xpY2tcIiwgY2xpY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXYuY2xvbmVOb2RlKHRydWUpLmZpcmVFdmVudChcIm9uY2xpY2tcIik7XG4gICAgICAgIH1cblxuICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQgdHlwZT0ncmFkaW8nIG5hbWU9J3JhZGlvdGVzdCcgY2hlY2tlZD0nY2hlY2tlZCcvPlwiO1xuXG4gICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgIC8vIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuICAgICAgICBqUXVlcnkuc3VwcG9ydC5jaGVja0Nsb25lID0gZnJhZ21lbnQuY2xvbmVOb2RlKHRydWUpLmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIHRoZSBXM0MgYm94IG1vZGVsIHdvcmtzIGFzIGV4cGVjdGVkXG4gICAgICAgIC8vIGRvY3VtZW50LmJvZHkgbXVzdCBleGlzdCBiZWZvcmUgd2UgY2FuIGRvIHRoaXNcbiAgICAgICAgalF1ZXJ5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIxcHhcIjtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgalF1ZXJ5LmJveE1vZGVsID0galF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDI7XG5cbiAgICAgICAgICAgIGlmIChcInpvb21cIiBpbiBkaXYuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBuYXRpdmVseSBibG9jay1sZXZlbCBlbGVtZW50cyBhY3QgbGlrZSBpbmxpbmUtYmxvY2tcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyB3aGVuIHNldHRpbmcgdGhlaXIgZGlzcGxheSB0byAnaW5saW5lJyBhbmQgZ2l2aW5nXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBsYXlvdXRcbiAgICAgICAgICAgICAgICAvLyAoSUUgPCA4IGRvZXMgdGhpcylcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLnpvb20gPSAxO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgPSBkaXYub2Zmc2V0V2lkdGggPT09IDI7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50cyB3aXRoIGxheW91dCBzaHJpbmstd3JhcCB0aGVpciBjaGlsZHJlblxuICAgICAgICAgICAgICAgIC8vIChJRSA2IGRvZXMgdGhpcylcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGRpdiBzdHlsZT0nd2lkdGg6NHB4Oyc+PC9kaXY+XCI7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnN1cHBvcnQuc2hyaW5rV3JhcEJsb2NrcyA9IGRpdi5vZmZzZXRXaWR0aCAhPT0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPHRhYmxlPjx0cj48dGQgc3R5bGU9J3BhZGRpbmc6MDtkaXNwbGF5Om5vbmUnPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT5cIjtcbiAgICAgICAgICAgIHZhciB0ZHMgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZFwiKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB0aGV5IGFyZSBzZXRcbiAgICAgICAgICAgIC8vIHRvIGRpc3BsYXk6bm9uZSBhbmQgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHZpc2libGUgdGFibGUgY2VsbHMgaW4gYVxuICAgICAgICAgICAgLy8gdGFibGUgcm93OyBpZiBzbywgb2Zmc2V0V2lkdGgvSGVpZ2h0IGFyZSBub3QgcmVsaWFibGUgZm9yIHVzZSB3aGVuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmluZyBpZiBhbiBlbGVtZW50IGhhcyBiZWVuIGhpZGRlbiBkaXJlY3RseSB1c2luZ1xuICAgICAgICAgICAgLy8gZGlzcGxheTpub25lIChpdCBpcyBzdGlsbCBzYWZlIHRvIHVzZSBvZmZzZXRzIGlmIGEgcGFyZW50IGVsZW1lbnQgaXNcbiAgICAgICAgICAgIC8vIGhpZGRlbjsgZG9uIHNhZmV0eSBnb2dnbGVzIGFuZCBzZWUgYnVnICM0NTEyIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cbiAgICAgICAgICAgIC8vIChvbmx5IElFIDggZmFpbHMgdGhpcyB0ZXN0KVxuICAgICAgICAgICAgalF1ZXJ5LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzID0gdGRzWzBdLm9mZnNldEhlaWdodCA9PT0gMDtcblxuICAgICAgICAgICAgdGRzWzBdLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgICAgdGRzWzFdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZW1wdHkgdGFibGUgY2VsbHMgc3RpbGwgaGF2ZSBvZmZzZXRXaWR0aC9IZWlnaHRcbiAgICAgICAgICAgIC8vIChJRSA8IDggZmFpbCB0aGlzIHRlc3QpXG4gICAgICAgICAgICBqUXVlcnkuc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMgPSBqUXVlcnkuc3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMgJiYgdGRzWzBdLm9mZnNldEhlaWdodCA9PT0gMDtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgZGl2ID0gdGRzID0gbnVsbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGVjaG5pcXVlIGZyb20gSnVyaXkgWmF5dHNldlxuICAgICAgICAvLyBodHRwOi8vdGhpbmt3ZWIyLmNvbS9wcm9qZWN0cy9wcm90b3R5cGUvZGV0ZWN0aW5nLWV2ZW50LXN1cHBvcnQtd2l0aG91dC1icm93c2VyLXNuaWZmaW5nL1xuICAgICAgICB2YXIgZXZlbnRTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvblwiICsgZXZlbnROYW1lO1xuXG4gICAgICAgICAgICB2YXIgaXNTdXBwb3J0ZWQgPSAoZXZlbnROYW1lIGluIGVsKTtcbiAgICAgICAgICAgIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCBcInJldHVybjtcIik7XG4gICAgICAgICAgICAgICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxbZXZlbnROYW1lXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgalF1ZXJ5LnN1cHBvcnQuc3VibWl0QnViYmxlcyA9IGV2ZW50U3VwcG9ydGVkKFwic3VibWl0XCIpO1xuICAgICAgICBqUXVlcnkuc3VwcG9ydC5jaGFuZ2VCdWJibGVzID0gZXZlbnRTdXBwb3J0ZWQoXCJjaGFuZ2VcIik7XG5cbiAgICAgICAgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcbiAgICAgICAgcm9vdCA9IHNjcmlwdCA9IGRpdiA9IGFsbCA9IGEgPSBudWxsO1xuICAgIH0pKCk7XG5cbiAgICBqUXVlcnkucHJvcHMgPSB7XG4gICAgICAgIFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuICAgICAgICBcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG4gICAgICAgIHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgIG1heGxlbmd0aDogXCJtYXhMZW5ndGhcIixcbiAgICAgICAgY2VsbHNwYWNpbmc6IFwiY2VsbFNwYWNpbmdcIixcbiAgICAgICAgcm93c3BhbjogXCJyb3dTcGFuXCIsXG4gICAgICAgIGNvbHNwYW46IFwiY29sU3BhblwiLFxuICAgICAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxuICAgICAgICB1c2VtYXA6IFwidXNlTWFwXCIsXG4gICAgICAgIGZyYW1lYm9yZGVyOiBcImZyYW1lQm9yZGVyXCJcbiAgICB9O1xuXG5cblxuXG4gICAgdmFyIHdpbmRvd0RhdGEgPSB7fSxcbiAgICAgICAgcmJyYWNlID0gL14oPzpcXHsuKlxcfXxcXFsuKlxcXSkkLztcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBjYWNoZToge30sXG5cbiAgICAgICAgLy8gUGxlYXNlIHVzZSB3aXRoIGNhdXRpb25cbiAgICAgICAgdXVpZDogMCxcblxuICAgICAgICAvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2VcdFxuICAgICAgICBleHBhbmRvOiBcImpRdWVyeVwiICsgalF1ZXJ5Lm5vdygpLFxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZWxlbWVudHMgdGhyb3cgdW5jYXRjaGFibGUgZXhjZXB0aW9ucyBpZiB5b3VcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBhZGQgZXhwYW5kbyBwcm9wZXJ0aWVzIHRvIHRoZW0uXG4gICAgICAgIG5vRGF0YToge1xuICAgICAgICAgICAgXCJlbWJlZFwiOiB0cnVlLFxuICAgICAgICAgICAgLy8gQmFuIGFsbCBvYmplY3RzIGV4Y2VwdCBmb3IgRmxhc2ggKHdoaWNoIGhhbmRsZSBleHBhbmRvcylcbiAgICAgICAgICAgIFwib2JqZWN0XCI6IFwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCIsXG4gICAgICAgICAgICBcImFwcGxldFwiOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YTogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghalF1ZXJ5LmFjY2VwdERhdGEoZWxlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW0gPSBlbGVtID09IHdpbmRvdyA/XG4gICAgICAgICAgICAgICAgd2luZG93RGF0YSA6XG4gICAgICAgICAgICAgICAgZWxlbTtcblxuICAgICAgICAgICAgdmFyIGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG4gICAgICAgICAgICAgICAgaWQgPSBpc05vZGUgPyBlbGVtW2pRdWVyeS5leHBhbmRvXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgY2FjaGUgPSBqUXVlcnkuY2FjaGUsIHRoaXNDYWNoZTtcblxuICAgICAgICAgICAgaWYgKGlzTm9kZSAmJiAhaWQgJiYgdHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgb2JqZWN0IGRpcmVjdGx5XG4gICAgICAgICAgICBpZiAoIWlzTm9kZSkge1xuICAgICAgICAgICAgICAgIGNhY2hlID0gZWxlbTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYSB1bmlxdWUgSUQgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgIGVsZW1balF1ZXJ5LmV4cGFuZG9dID0gaWQgPSArK2pRdWVyeS51dWlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdm9pZCBnZW5lcmF0aW5nIGEgbmV3IGNhY2hlIHVubGVzcyBub25lIGV4aXN0cyBhbmQgd2VcbiAgICAgICAgICAgIC8vIHdhbnQgdG8gbWFuaXB1bGF0ZSBpdC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVbaWRdID0galF1ZXJ5LmV4dGVuZChjYWNoZVtpZF0sIG5hbWUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZChjYWNoZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZSAmJiAhY2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVbaWRdID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNDYWNoZSA9IGlzTm9kZSA/IGNhY2hlW2lkXSA6IGNhY2hlO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgdGhlIG5hbWVkIGNhY2hlIHdpdGggdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNDYWNoZVtuYW1lXSA9IGRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IHRoaXNDYWNoZVtuYW1lXSA6IHRoaXNDYWNoZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKCFqUXVlcnkuYWNjZXB0RGF0YShlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbSA9IGVsZW0gPT0gd2luZG93ID9cbiAgICAgICAgICAgICAgICB3aW5kb3dEYXRhIDpcbiAgICAgICAgICAgICAgICBlbGVtO1xuXG4gICAgICAgICAgICB2YXIgaXNOb2RlID0gZWxlbS5ub2RlVHlwZSxcbiAgICAgICAgICAgICAgICBpZCA9IGlzTm9kZSA/IGVsZW1balF1ZXJ5LmV4cGFuZG9dIDogZWxlbSxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IGpRdWVyeS5jYWNoZSxcbiAgICAgICAgICAgICAgICB0aGlzQ2FjaGUgPSBpc05vZGUgPyBjYWNoZVtpZF0gOiBpZDtcblxuICAgICAgICAgICAgLy8gSWYgd2Ugd2FudCB0byByZW1vdmUgYSBzcGVjaWZpYyBzZWN0aW9uIG9mIHRoZSBlbGVtZW50J3MgZGF0YVxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VjdGlvbiBvZiBjYWNoZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzQ2FjaGVbbmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgcmVtb3ZlZCBhbGwgdGhlIGRhdGEsIHJlbW92ZSB0aGUgZWxlbWVudCdzIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGUgJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QodGhpc0NhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZURhdGEoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHdhbnQgdG8gcmVtb3ZlIGFsbCBvZiB0aGUgZWxlbWVudCdzIGRhdGFcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZSAmJiBqUXVlcnkuc3VwcG9ydC5kZWxldGVFeHBhbmRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtW2pRdWVyeS5leHBhbmRvXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoalF1ZXJ5LmV4cGFuZG8pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlbHkgcmVtb3ZlIHRoZSBkYXRhIGNhY2hlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2lkXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGZpZWxkcyBmcm9tIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuIGluIGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtW25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEEgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIERPTSBub2RlIGNhbiBoYW5kbGUgdGhlIGRhdGEgZXhwYW5kb1xuICAgICAgICBhY2NlcHREYXRhOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBqUXVlcnkubm9EYXRhW2VsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEobWF0Y2ggPT09IHRydWUgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc2lkXCIpICE9PSBtYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA/IGpRdWVyeS5kYXRhKHRoaXNbMF0pIDogbnVsbDtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKHRoaXMsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGtleS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICBwYXJ0c1sxXSA9IHBhcnRzWzFdID8gXCIuXCIgKyBwYXJ0c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnRyaWdnZXJIYW5kbGVyKFwiZ2V0RGF0YVwiICsgcGFydHNbMV0gKyBcIiFcIiwgW3BhcnRzWzBdXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZmV0Y2ggYW55IGludGVybmFsbHkgc3RvcmVkIGRhdGEgZmlyc3RcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkICYmIHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkuZGF0YSh0aGlzWzBdLCBrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgdGhpc1swXS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXNbMF0uZ2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFqUXVlcnkuaXNOYU4oZGF0YSkgPyBwYXJzZUZsb2F0KGRhdGEpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJicmFjZS50ZXN0KGRhdGEpID8galF1ZXJ5LnBhcnNlSlNPTihkYXRhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBwYXJ0c1sxXSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YShwYXJ0c1swXSkgOlxuICAgICAgICAgICAgICAgICAgICBkYXRhO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSBqUXVlcnkodGhpcyksIGFyZ3MgPSBbcGFydHNbMF0sIHZhbHVlXTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VySGFuZGxlcihcInNldERhdGFcIiArIHBhcnRzWzFdICsgXCIhXCIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlckhhbmRsZXIoXCJjaGFuZ2VEYXRhXCIgKyBwYXJ0c1sxXSArIFwiIVwiLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlRGF0YSh0aGlzLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBxdWV1ZTogZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHlwZSA9ICh0eXBlIHx8IFwiZnhcIikgKyBcInF1ZXVlXCI7XG4gICAgICAgICAgICB2YXIgcSA9IGpRdWVyeS5kYXRhKGVsZW0sIHR5cGUpO1xuXG4gICAgICAgICAgICAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcSB8fCBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFxIHx8IGpRdWVyeS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcSA9IGpRdWVyeS5kYXRhKGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24gKGVsZW0sIHR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKGVsZW0sIHR5cGUpLCBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcbiAgICAgICAgICAgIGlmIChmbiA9PT0gXCJpbnByb2dyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcbiAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZnhcIikge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmbi5jYWxsKGVsZW0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoZWxlbSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBxdWV1ZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBcImZ4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnF1ZXVlKHRoaXNbMF0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSh0aGlzLCB0eXBlLCBkYXRhKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZXF1ZXVlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgdHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4gICAgICAgIC8vIGh0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbiAgICAgICAgZGVsYXk6IGZ1bmN0aW9uICh0aW1lLCB0eXBlKSB7XG4gICAgICAgICAgICB0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1t0aW1lXSB8fCB0aW1lIDogdGltZTtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUodHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUoZWxlbSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUodHlwZSB8fCBcImZ4XCIsIFtdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4gICAgdmFyIHJjbGFzcyA9IC9bXFxuXFx0XS9nLFxuICAgICAgICByc3BhY2VzID0gL1xccysvLFxuICAgICAgICBycmV0dXJuID0gL1xcci9nLFxuICAgICAgICByc3BlY2lhbHVybCA9IC9eKD86aHJlZnxzcmN8c3R5bGUpJC8sXG4gICAgICAgIHJ0eXBlID0gL14oPzpidXR0b258aW5wdXQpJC9pLFxuICAgICAgICByZm9jdXNhYmxlID0gL14oPzpidXR0b258aW5wdXR8b2JqZWN0fHNlbGVjdHx0ZXh0YXJlYSkkL2ksXG4gICAgICAgIHJjbGlja2FibGUgPSAvXmEoPzpyZWEpPyQvaSxcbiAgICAgICAgcnJhZGlvY2hlY2sgPSAvXig/OnJhZGlvfGNoZWNrYm94KSQvaTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuYWNjZXNzKHRoaXMsIG5hbWUsIHZhbHVlLCB0cnVlLCBqUXVlcnkuYXR0cik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuYXR0cih0aGlzLCBuYW1lLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRDbGFzcyh2YWx1ZS5jYWxsKHRoaXMsIGksIHNlbGYuYXR0cihcImNsYXNzXCIpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9ICh2YWx1ZSB8fCBcIlwiKS5zcGxpdChyc3BhY2VzKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW0uY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiLCBzZXRDbGFzcyA9IGVsZW0uY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwLCBjbCA9IGNsYXNzTmFtZXMubGVuZ3RoOyBjIDwgY2w7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoXCIgXCIgKyBjbGFzc05hbWVzW2NdICsgXCIgXCIpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q2xhc3MgKz0gXCIgXCIgKyBjbGFzc05hbWVzW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0galF1ZXJ5LnRyaW0oc2V0Q2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVDbGFzcyh2YWx1ZS5jYWxsKHRoaXMsIGksIHNlbGYuYXR0cihcImNsYXNzXCIpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAodmFsdWUgfHwgXCJcIikuc3BsaXQocnNwYWNlcyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IChcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGNsID0gY2xhc3NOYW1lcy5sZW5ndGg7IGMgPCBjbDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5yZXBsYWNlKFwiIFwiICsgY2xhc3NOYW1lc1tjXSArIFwiIFwiLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0galF1ZXJ5LnRyaW0oY2xhc3NOYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiAodmFsdWUsIHN0YXRlVmFsKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSwgaXNCb29sID0gdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIjtcblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudG9nZ2xlQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBpLCBzZWxmLmF0dHIoXCJjbGFzc1wiKSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUsIGkgPSAwLCBzZWxmID0galF1ZXJ5KHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgPSB2YWx1ZS5zcGxpdChyc3BhY2VzKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaSsrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBlcmF0ZWQgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBpc0Jvb2wgPyBzdGF0ZSA6ICFzZWxmLmhhc0NsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmW3N0YXRlID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXShjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdG9nZ2xlIHdob2xlIGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/IFwiXCIgOiBqUXVlcnkuZGF0YSh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIikgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwib3B0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzLnZhbHVlIGlzIHVuZGVmaW5lZCBpbiBCbGFja2JlcnJ5IDQuNyBidXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZXMgLnZhbHVlLiBTZWUgIzY5MzJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLmF0dHJpYnV0ZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXZhbCB8fCB2YWwuc3BlY2lmaWVkID8gZWxlbS52YWx1ZSA6IGVsZW0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIHNlbGVjdCBib3hlcyBzcGVjaWFsXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJzZWxlY3RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgd2FzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvbmUgPyBpbmRleCA6IDAsIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICYmIChqUXVlcnkuc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT09IG51bGwpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIWpRdWVyeS5ub2RlTmFtZShvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KG9wdGlvbikudmFsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBpbiBXZWJraXQgXCJcIiBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIHZhbHVlIGlzbid0IHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICBpZiAocnJhZGlvY2hlY2sudGVzdChlbGVtLnR5cGUpICYmICFqUXVlcnkuc3VwcG9ydC5jaGVja09uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSwgd2UganVzdCBncmFiIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW0udmFsdWUgfHwgXCJcIikucmVwbGFjZShycmV0dXJuLCBcIlwiKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyksIHZhbCA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlLmNhbGwodGhpcywgaSwgc2VsZi52YWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpRdWVyeS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkodmFsKSAmJiBycmFkaW9jaGVjay50ZXN0KHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoc2VsZi52YWwoKSwgdmFsKSA+PSAwO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqUXVlcnkubm9kZU5hbWUodGhpcywgXCJzZWxlY3RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkodmFsKTtcblxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoXCJvcHRpb25cIiwgdGhpcykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0galF1ZXJ5LmluQXJyYXkoalF1ZXJ5KHRoaXMpLnZhbCgpLCB2YWx1ZXMpID49IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGpRdWVyeS5leHRlbmQoe1xuICAgICAgICBhdHRyRm46IHtcbiAgICAgICAgICAgIHZhbDogdHJ1ZSxcbiAgICAgICAgICAgIGNzczogdHJ1ZSxcbiAgICAgICAgICAgIGh0bWw6IHRydWUsXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxuICAgICAgICAgICAgZGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIHdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgaGVpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIHZhbHVlLCBwYXNzKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBzZXQgYXR0cmlidXRlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhc3MgJiYgbmFtZSBpbiBqUXVlcnkuYXR0ckZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeShlbGVtKVtuYW1lXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBub3R4bWwgPSBlbGVtLm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoZWxlbSksXG4gICAgICAgICAgICAgICAgLy8gV2hldGhlciB3ZSBhcmUgc2V0dGluZyAob3IgZ2V0dGluZylcbiAgICAgICAgICAgICAgICBzZXQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAvLyBUcnkgdG8gbm9ybWFsaXplL2ZpeCB0aGUgbmFtZVxuICAgICAgICAgICAgbmFtZSA9IG5vdHhtbCAmJiBqUXVlcnkucHJvcHNbbmFtZV0gfHwgbmFtZTtcblxuICAgICAgICAgICAgLy8gT25seSBkbyBhbGwgdGhlIGZvbGxvd2luZyBpZiB0aGlzIGlzIGEgbm9kZSAoZmFzdGVyIGZvciBzdHlsZSlcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXR0cmlidXRlcyByZXF1aXJlIHNwZWNpYWwgdHJlYXRtZW50XG4gICAgICAgICAgICAgICAgdmFyIHNwZWNpYWwgPSByc3BlY2lhbHVybC50ZXN0KG5hbWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIG1pcy1yZXBvcnRzIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHByb3BlcnR5IG9mIGFuIG9wdGlvblxuICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGUgcGFyZW50J3Mgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eSBmaXhlcyBpdFxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcInNlbGVjdGVkXCIgJiYgIWpRdWVyeS5zdXBwb3J0Lm9wdFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBpdCBhbHNvIHdvcmtzIHdpdGggb3B0Z3JvdXBzLCBzZWUgIzU3MDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBhcHBsaWNhYmxlLCBhY2Nlc3MgdGhlIGF0dHJpYnV0ZSB2aWEgdGhlIERPTSAwIHdheVxuICAgICAgICAgICAgICAgIC8vICdpbicgY2hlY2tzIGZhaWwgaW4gQmxhY2tiZXJyeSA0LjcgIzY5MzFcbiAgICAgICAgICAgICAgICBpZiAoKG5hbWUgaW4gZWxlbSB8fCBlbGVtW25hbWVdICE9PSB1bmRlZmluZWQpICYmIG5vdHhtbCAmJiAhc3BlY2lhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBhbGxvdyB0aGUgdHlwZSBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkIChzaW5jZSBpdCBjYXVzZXMgcHJvYmxlbXMgaW4gSUUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJ0eXBlXCIgJiYgcnR5cGUudGVzdChlbGVtLm5vZGVOYW1lKSAmJiBlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoXCJ0eXBlIHByb3BlcnR5IGNhbid0IGJlIGNoYW5nZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycyBpbmRleCBlbGVtZW50cyBieSBpZC9uYW1lIG9uIGZvcm1zLCBnaXZlIHByaW9yaXR5IHRvIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJmb3JtXCIpICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcInRhYkluZGV4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOb2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwidGFiSW5kZXhcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVOb2RlICYmIGF0dHJpYnV0ZU5vZGUuc3BlY2lmaWVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOb2RlLnZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZm9jdXNhYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkgfHwgcmNsaWNrYWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpICYmIGVsZW0uaHJlZiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWpRdWVyeS5zdXBwb3J0LnN0eWxlICYmIG5vdHhtbCAmJiBuYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5jc3NUZXh0ID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHZhbHVlIHRvIGEgc3RyaW5nIChhbGwgYnJvd3NlcnMgZG8gdGhpcyBidXQgSUUpIHNlZSAjMTA3MFxuICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IG1pc3NpbmcgYXR0cmlidXRlcyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgLy8gQmxhY2tiZXJyeSA0LjcgcmV0dXJucyBcIlwiIGZyb20gZ2V0QXR0cmlidXRlICM2OTM4XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtLmF0dHJpYnV0ZXNbbmFtZV0gJiYgKGVsZW0uaGFzQXR0cmlidXRlICYmICFlbGVtLmhhc0F0dHJpYnV0ZShuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9ICFqUXVlcnkuc3VwcG9ydC5ocmVmTm9ybWFsaXplZCAmJiBub3R4bWwgJiYgc3BlY2lhbCA/XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgYXR0cmlidXRlcyByZXF1aXJlIGEgc3BlY2lhbCBjYWxsIG9uIElFXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUsIDIpIDpcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyID09PSBudWxsID8gdW5kZWZpbmVkIDogYXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4gICAgdmFyIHJuYW1lc3BhY2VzID0gL1xcLiguKikkLyxcbiAgICAgICAgcmZvcm1FbGVtcyA9IC9eKD86dGV4dGFyZWF8aW5wdXR8c2VsZWN0KSQvaSxcbiAgICAgICAgcnBlcmlvZCA9IC9cXC4vZyxcbiAgICAgICAgcnNwYWNlID0gLyAvZyxcbiAgICAgICAgcmVzY2FwZSA9IC9bXlxcd1xccy58YF0vZyxcbiAgICAgICAgZmNsZWFudXAgPSBmdW5jdGlvbiAobm0pIHtcbiAgICAgICAgICAgIHJldHVybiBubS5yZXBsYWNlKHJlc2NhcGUsIFwiXFxcXCQmXCIpO1xuICAgICAgICB9LFxuICAgICAgICBmb2N1c0NvdW50cyA9IHsgZm9jdXNpbjogMCwgZm9jdXNvdXQ6IDAgfTtcblxuICAgIC8qXG4gICAgICogQSBudW1iZXIgb2YgaGVscGVyIGZ1bmN0aW9ucyB1c2VkIGZvciBtYW5hZ2luZyBldmVudHMuXG4gICAgICogTWFueSBvZiB0aGUgaWRlYXMgYmVoaW5kIHRoaXMgY29kZSBvcmlnaW5hdGVkIGZyb21cbiAgICAgKiBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkuXG4gICAgICovXG4gICAgalF1ZXJ5LmV2ZW50ID0ge1xuXG4gICAgICAgIC8vIEJpbmQgYW4gZXZlbnQgdG8gYW4gZWxlbWVudFxuICAgICAgICAvLyBPcmlnaW5hbCBieSBEZWFuIEVkd2FyZHNcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciB3aGF0ZXZlciByZWFzb24sIElFIGhhcyB0cm91YmxlIHBhc3NpbmcgdGhlIHdpbmRvdyBvYmplY3RcbiAgICAgICAgICAgIC8vIGFyb3VuZCwgY2F1c2luZyBpdCB0byBiZSBjbG9uZWQgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNXaW5kb3coZWxlbSkgJiYgKGVsZW0gIT09IHdpbmRvdyAmJiAhZWxlbS5mcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZWxlbSA9IHdpbmRvdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IHJldHVybkZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqSW4sIGhhbmRsZU9iajtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIuaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGZ1bmN0aW9uIGJlaW5nIGV4ZWN1dGVkIGhhcyBhIHVuaXF1ZSBJRFxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmd1aWQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlXG4gICAgICAgICAgICB2YXIgZWxlbURhdGEgPSBqUXVlcnkuZGF0YShlbGVtKTtcblxuICAgICAgICAgICAgLy8gSWYgbm8gZWxlbURhdGEgaXMgZm91bmQgdGhlbiB3ZSBtdXN0IGJlIHRyeWluZyB0byBiaW5kIHRvIG9uZSBvZiB0aGVcbiAgICAgICAgICAgIC8vIGJhbm5lZCBub0RhdGEgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghZWxlbURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIGtleSBsZXNzIGxpa2VseSB0byByZXN1bHQgaW4gY29sbGlzaW9ucyBmb3IgcGxhaW4gSlMgb2JqZWN0cy5cbiAgICAgICAgICAgIC8vIEZpeGVzIGJ1ZyAjNzE1MC5cbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGVsZW0ubm9kZVR5cGUgPyBcImV2ZW50c1wiIDogXCJfX2V2ZW50c19fXCIsXG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZWxlbURhdGFbZXZlbnRLZXldLFxuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gcGxhaW4gb2JqZWN0cyBldmVudHMgaXMgYSBmbiB0aGF0IGhvbGRzIHRoZSB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHByZXZlbnRzIHRoaXMgZGF0YSBmcm9tIGJlaW5nIEpTT04gc2VyaWFsaXplZFxuICAgICAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCwgaXQganVzdCBjb250YWlucyB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlID0gZXZlbnRzLmhhbmRsZTtcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuZXZlbnRzO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW0ubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT24gcGxhaW4gb2JqZWN0cywgY3JlYXRlIGEgZm4gdGhhdCBhY3RzIGFzIHRoZSBob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHZhbHVlcyB0byBhdm9pZCBKU09OIHNlcmlhbGl6YXRpb24gb2YgZXZlbnQgZGF0YVxuICAgICAgICAgICAgICAgICAgICBlbGVtRGF0YVtldmVudEtleV0gPSBlbGVtRGF0YSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtRGF0YS5ldmVudHMgPSBldmVudHMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFldmVudEhhbmRsZSkge1xuICAgICAgICAgICAgICAgIGVsZW1EYXRhLmhhbmRsZSA9IGV2ZW50SGFuZGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIHNlY29uZCBldmVudCBvZiBhIHRyaWdnZXIgYW5kIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgIWpRdWVyeS5ldmVudC50cmlnZ2VyZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmhhbmRsZS5hcHBseShldmVudEhhbmRsZS5lbGVtLCBhcmd1bWVudHMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgZWxlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBoYW5kbGUgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBhIG1lbW9yeSBsZWFrIHdpdGggbm9uLW5hdGl2ZSBldmVudHMgaW4gSUUuXG4gICAgICAgICAgICBldmVudEhhbmRsZS5lbGVtID0gZWxlbTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuICAgICAgICAgICAgLy8galF1ZXJ5KC4uLikuYmluZChcIm1vdXNlb3ZlciBtb3VzZW91dFwiLCBmbik7XG4gICAgICAgICAgICB0eXBlcyA9IHR5cGVzLnNwbGl0KFwiIFwiKTtcblxuICAgICAgICAgICAgdmFyIHR5cGUsIGkgPSAwLCBuYW1lc3BhY2VzO1xuXG4gICAgICAgICAgICB3aGlsZSAoKHR5cGUgPSB0eXBlc1tpKytdKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZU9iakluID9cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh7fSwgaGFuZGxlT2JqSW4pIDpcbiAgICAgICAgICAgICAgICAgICAgeyBoYW5kbGVyOiBoYW5kbGVyLCBkYXRhOiBkYXRhIH07XG5cbiAgICAgICAgICAgICAgICAvLyBOYW1lc3BhY2VkIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaW5kZXhPZihcIi5cIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLnNsaWNlKDApLnNvcnQoKS5qb2luKFwiLlwiKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLm5hbWVzcGFjZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlT2JqLmd1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGxpc3Qgb2YgZnVuY3Rpb25zIGJvdW5kIHRvIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0sXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWVcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgc3BlY2lhbCBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIvYXR0YWNoRXZlbnQgaWYgdGhlIHNwZWNpYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpbmQgdGhlIGdsb2JhbCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgZXZlbnRIYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuYWRkLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGZ1bmN0aW9uIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVPYmopO1xuXG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBiZWVuIHVzZWQsIGZvciBnbG9iYWwgdHJpZ2dlcmluZ1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5nbG9iYWxbdHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOdWxsaWZ5IGVsZW0gdG8gcHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcbiAgICAgICAgICAgIGVsZW0gPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdsb2JhbDoge30sXG5cbiAgICAgICAgLy8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBwb3MpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gcmV0dXJuRmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQsIHR5cGUsIGZuLCBqLCBpID0gMCwgYWxsLCBuYW1lc3BhY2VzLCBuYW1lc3BhY2UsIHNwZWNpYWwsIGV2ZW50VHlwZSwgaGFuZGxlT2JqLCBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICBldmVudEtleSA9IGVsZW0ubm9kZVR5cGUgPyBcImV2ZW50c1wiIDogXCJfX2V2ZW50c19fXCIsXG4gICAgICAgICAgICAgICAgZWxlbURhdGEgPSBqUXVlcnkuZGF0YShlbGVtKSxcbiAgICAgICAgICAgICAgICBldmVudHMgPSBlbGVtRGF0YSAmJiBlbGVtRGF0YVtldmVudEtleV07XG5cbiAgICAgICAgICAgIGlmICghZWxlbURhdGEgfHwgIWV2ZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZXZlbnRzO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5ldmVudHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHR5cGVzIGlzIGFjdHVhbGx5IGFuIGV2ZW50IG9iamVjdCBoZXJlXG4gICAgICAgICAgICBpZiAodHlwZXMgJiYgdHlwZXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSB0eXBlcy5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHR5cGVzID0gdHlwZXMudHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVW5iaW5kIGFsbCBldmVudHMgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIXR5cGVzIHx8IHR5cGVvZiB0eXBlcyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlcy5jaGFyQXQoMCkgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMgPSB0eXBlcyB8fCBcIlwiO1xuXG4gICAgICAgICAgICAgICAgZm9yICh0eXBlIGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKGVsZW0sIHR5cGUgKyB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG4gICAgICAgICAgICAvLyBqUXVlcnkoLi4uKS51bmJpbmQoXCJtb3VzZW92ZXIgbW91c2VvdXRcIiwgZm4pO1xuICAgICAgICAgICAgdHlwZXMgPSB0eXBlcy5zcGxpdChcIiBcIik7XG5cbiAgICAgICAgICAgIHdoaWxlICgodHlwZSA9IHR5cGVzW2krK10pKSB7XG4gICAgICAgICAgICAgICAgb3JpZ1R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYWxsID0gdHlwZS5pbmRleE9mKFwiLlwiKSA8IDA7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmFtZXNwYWNlZCBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlID0gbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tYXAobmFtZXNwYWNlcy5zbGljZSgwKS5zb3J0KCksIGZjbGVhbnVwKS5qb2luKFwiXFxcXC4oPzouKlxcXFwuKT9cIikgKyBcIihcXFxcLnwkKVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBldmVudHNbdHlwZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGV2ZW50VHlwZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gZXZlbnRUeXBlW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsIHx8IG5hbWVzcGFjZS50ZXN0KGhhbmRsZU9iai5uYW1lc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCBvcmlnVHlwZSwgaGFuZGxlT2JqLmhhbmRsZXIsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IHBvcyB8fCAwOyBqIDwgZXZlbnRUeXBlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGV2ZW50VHlwZVtqXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBnaXZlbiBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbCB8fCBuYW1lc3BhY2UudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwucmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZS5sZW5ndGggPT09IDAgfHwgcG9zICE9IG51bGwgJiYgZXZlbnRUeXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKGVsZW0sIG5hbWVzcGFjZXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNFbXB0eU9iamVjdChldmVudHMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5lbGVtID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgZWxlbURhdGEuZXZlbnRzO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1EYXRhID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZURhdGEoZWxlbSwgZXZlbnRLZXkpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqUXVlcnkuaXNFbXB0eU9iamVjdChlbGVtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZURhdGEoZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGJ1YmJsaW5nIGlzIGludGVybmFsXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudCwgZGF0YSwgZWxlbSAvKiwgYnViYmxpbmcgKi8pIHtcbiAgICAgICAgICAgIC8vIEV2ZW50IG9iamVjdCBvciBldmVudCB0eXBlXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQsXG4gICAgICAgICAgICAgICAgYnViYmxpbmcgPSBhcmd1bWVudHNbM107XG5cbiAgICAgICAgICAgIGlmICghYnViYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiA/XG4gICAgICAgICAgICAgICAgICAgIC8vIGpRdWVyeS5FdmVudCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRbalF1ZXJ5LmV4cGFuZG9dID8gZXZlbnQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoalF1ZXJ5LkV2ZW50KHR5cGUpLCBldmVudCkgOlxuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHRoZSBldmVudCB0eXBlIChzdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5FdmVudCh0eXBlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCIhXCIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IHR5cGUgPSB0eXBlLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZXhjbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYSBnbG9iYWwgdHJpZ2dlclxuICAgICAgICAgICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBidWJibGUgY3VzdG9tIGV2ZW50cyB3aGVuIGdsb2JhbCAodG8gYXZvaWQgdG9vIG11Y2ggb3ZlcmhlYWQpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdHJpZ2dlciBpZiB3ZSd2ZSBldmVyIGJvdW5kIGFuIGV2ZW50IGZvciBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmV2ZW50Lmdsb2JhbFt0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goalF1ZXJ5LmNhY2hlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKGV2ZW50LCBkYXRhLCB0aGlzLmhhbmRsZS5lbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0cmlnZ2VyaW5nIGEgc2luZ2xlIGVsZW1lbnRcblxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIGluIGNhc2UgaXQgaXMgcmV1c2VkXG4gICAgICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGVsZW07XG5cbiAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgaW5jb21pbmcgZGF0YSwgaWYgYW55XG4gICAgICAgICAgICAgICAgZGF0YSA9IGpRdWVyeS5tYWtlQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgZGF0YS51bnNoaWZ0KGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IGVsZW07XG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGV2ZW50LCBpdCBpcyBhc3N1bWVkIHRoYXQgXCJoYW5kbGVcIiBpcyBhIGZ1bmN0aW9uXG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZWxlbS5ub2RlVHlwZSA/XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEoZWxlbSwgXCJoYW5kbGVcIikgOlxuICAgICAgICAgICAgICAgIChqUXVlcnkuZGF0YShlbGVtLCBcIl9fZXZlbnRzX19cIikgfHwge30pLmhhbmRsZTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZS5hcHBseShlbGVtLCBkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSB8fCBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYW4gaW5saW5lIGJvdW5kIHNjcmlwdFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIShlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgalF1ZXJ5Lm5vRGF0YVtlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbVtcIm9uXCIgKyB0eXBlXSAmJiBlbGVtW1wib25cIiArIHR5cGVdLmFwcGx5KGVsZW0sIGRhdGEpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBJRSBmcm9tIHRocm93aW5nIGFuIGVycm9yIGZvciBzb21lIGVsZW1lbnRzIHdpdGggc29tZSBldmVudCB0eXBlcywgc2VlICMzNTMzXG4gICAgICAgICAgICB9IGNhdGNoIChpbmxpbmVFcnJvcikgeyB9XG5cbiAgICAgICAgICAgIGlmICghZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSAmJiBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihldmVudCwgZGF0YSwgcGFyZW50LCB0cnVlKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0LCBvbGQsIHRhcmdldFR5cGUgPSB0eXBlLnJlcGxhY2Uocm5hbWVzcGFjZXMsIFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICBpc0NsaWNrID0galF1ZXJ5Lm5vZGVOYW1lKHRhcmdldCwgXCJhXCIpICYmIHRhcmdldFR5cGUgPT09IFwiY2xpY2tcIixcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3RhcmdldFR5cGVdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmNhbGwoZWxlbSwgZXZlbnQpID09PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzQ2xpY2sgJiYgISh0YXJnZXQgJiYgdGFyZ2V0Lm5vZGVOYW1lICYmIGpRdWVyeS5ub0RhdGFbdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W3RhcmdldFR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHJlLXRyaWdnZXIgdGhlIG9uRk9PIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCA9IHRhcmdldFtcIm9uXCIgKyB0YXJnZXRUeXBlXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W1wib25cIiArIHRhcmdldFR5cGVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbdGFyZ2V0VHlwZV0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBJRSBmcm9tIHRocm93aW5nIGFuIGVycm9yIGZvciBzb21lIGVsZW1lbnRzIHdpdGggc29tZSBldmVudCB0eXBlcywgc2VlICMzNTMzXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHRyaWdnZXJFcnJvcikgeyB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W1wib25cIiArIHRhcmdldFR5cGVdID0gb2xkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGFsbCwgaGFuZGxlcnMsIG5hbWVzcGFjZXMsIG5hbWVzcGFjZV9zb3J0ID0gW10sIG5hbWVzcGFjZV9yZSwgZXZlbnRzLCBhcmdzID0galF1ZXJ5Lm1ha2VBcnJheShhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBldmVudCA9IGFyZ3NbMF0gPSBqUXVlcnkuZXZlbnQuZml4KGV2ZW50IHx8IHdpbmRvdy5ldmVudCk7XG4gICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gTmFtZXNwYWNlZCBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgYWxsID0gZXZlbnQudHlwZS5pbmRleE9mKFwiLlwiKSA8IDAgJiYgIWV2ZW50LmV4Y2x1c2l2ZTtcblxuICAgICAgICAgICAgaWYgKCFhbGwpIHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gZXZlbnQudHlwZS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2Vfc29ydCA9IG5hbWVzcGFjZXMuc2xpY2UoMCkuc29ydCgpO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZV9yZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZV9zb3J0LmpvaW4oXCJcXFxcLig/Oi4qXFxcXC4pP1wiKSArIFwiKFxcXFwufCQpXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudC5uYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgfHwgbmFtZXNwYWNlX3NvcnQuam9pbihcIi5cIik7XG5cbiAgICAgICAgICAgIGV2ZW50cyA9IGpRdWVyeS5kYXRhKHRoaXMsIHRoaXMubm9kZVR5cGUgPyBcImV2ZW50c1wiIDogXCJfX2V2ZW50c19fXCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmV2ZW50cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlcnMgPSAoZXZlbnRzIHx8IHt9KVtldmVudC50eXBlXTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50cyAmJiBoYW5kbGVycykge1xuICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSBoYW5kbGVycyB0byBwcmV2ZW50IG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlT2JqID0gaGFuZGxlcnNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBmdW5jdGlvbnMgYnkgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbCB8fCBuYW1lc3BhY2VfcmUudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBpbiBhIHJlZmVyZW5jZSB0byB0aGUgaGFuZGxlciBmdW5jdGlvbiBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvIHRoYXQgd2UgY2FuIGxhdGVyIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFuZGxlciA9IGhhbmRsZU9iai5oYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvcHM6IFwiYWx0S2V5IGF0dHJDaGFuZ2UgYXR0ck5hbWUgYnViYmxlcyBidXR0b24gY2FuY2VsYWJsZSBjaGFyQ29kZSBjbGllbnRYIGNsaWVudFkgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRhdGEgZGV0YWlsIGV2ZW50UGhhc2UgZnJvbUVsZW1lbnQgaGFuZGxlciBrZXlDb2RlIGxheWVyWCBsYXllclkgbWV0YUtleSBuZXdWYWx1ZSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgcHJldlZhbHVlIHJlbGF0ZWROb2RlIHJlbGF0ZWRUYXJnZXQgc2NyZWVuWCBzY3JlZW5ZIHNoaWZ0S2V5IHNyY0VsZW1lbnQgdGFyZ2V0IHRvRWxlbWVudCB2aWV3IHdoZWVsRGVsdGEgd2hpY2hcIi5zcGxpdChcIiBcIiksXG5cbiAgICAgICAgZml4OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFtqUXVlcnkuZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAvLyBhbmQgXCJjbG9uZVwiIHRvIHNldCByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIGV2ZW50ID0galF1ZXJ5LkV2ZW50KG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wcm9wcy5sZW5ndGgsIHByb3A7IGk7KSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IHRoaXMucHJvcHNbLS1pXTtcbiAgICAgICAgICAgICAgICBldmVudFtwcm9wXSA9IG9yaWdpbmFsRXZlbnRbcHJvcF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpeCB0YXJnZXQgcHJvcGVydHksIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50OyAvLyBGaXhlcyAjMTkyNSB3aGVyZSBzcmNFbGVtZW50IG1pZ2h0IG5vdCBiZSBkZWZpbmVkIGVpdGhlclxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0YXJnZXQgaXMgYSB0ZXh0bm9kZSAoc2FmYXJpKVxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgcmVsYXRlZFRhcmdldCwgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZXZlbnQuZnJvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZiAoZXZlbnQucGFnZVggPT0gbnVsbCAmJiBldmVudC5jbGllbnRYICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICBldmVudC5wYWdlWCA9IGV2ZW50LmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgICAgICAgICAgICBldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcbiAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PSBudWxsICYmIChldmVudC5jaGFyQ29kZSAhPSBudWxsIHx8IGV2ZW50LmtleUNvZGUgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC53aGljaCA9IGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBtZXRhS2V5IHRvIG5vbi1NYWMgYnJvd3NlcnMgKHVzZSBjdHJsIGZvciBQQydzIGFuZCBNZXRhIGZvciBNYWNzKVxuICAgICAgICAgICAgaWYgKCFldmVudC5tZXRhS2V5ICYmIGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5tZXRhS2V5ID0gZXZlbnQuY3RybEtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuICAgICAgICAgICAgLy8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcbiAgICAgICAgICAgIGlmICghZXZlbnQud2hpY2ggJiYgZXZlbnQuYnV0dG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudC53aGljaCA9IChldmVudC5idXR0b24gJiAxID8gMSA6IChldmVudC5idXR0b24gJiAyID8gMyA6IChldmVudC5idXR0b24gJiA0ID8gMiA6IDApKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBEZXByZWNhdGVkLCB1c2UgalF1ZXJ5Lmd1aWQgaW5zdGVhZFxuICAgICAgICBndWlkOiAxRTgsXG5cbiAgICAgICAgLy8gRGVwcmVjYXRlZCwgdXNlIGpRdWVyeS5wcm94eSBpbnN0ZWFkXG4gICAgICAgIHByb3h5OiBqUXVlcnkucHJveHksXG5cbiAgICAgICAgc3BlY2lhbDoge1xuICAgICAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHJlYWR5IGV2ZW50IGlzIHNldHVwXG4gICAgICAgICAgICAgICAgc2V0dXA6IGpRdWVyeS5iaW5kUmVhZHksXG4gICAgICAgICAgICAgICAgdGVhcmRvd246IGpRdWVyeS5ub29wXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBsaXZlOiB7XG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAoaGFuZGxlT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdmVDb252ZXJ0KGhhbmRsZU9iai5vcmlnVHlwZSwgaGFuZGxlT2JqLnNlbGVjdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoe30sIGhhbmRsZU9iaiwgeyBoYW5kbGVyOiBsaXZlSGFuZGxlciwgZ3VpZDogaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCB9KSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGhhbmRsZU9iaikge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKHRoaXMsIGxpdmVDb252ZXJ0KGhhbmRsZU9iai5vcmlnVHlwZSwgaGFuZGxlT2JqLnNlbGVjdG9yKSwgaGFuZGxlT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBiZWZvcmV1bmxvYWQ6IHtcbiAgICAgICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24gKGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBkbyB0aGlzIHNwZWNpYWwgY2FzZSBvbiB3aW5kb3dzXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNXaW5kb3codGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25iZWZvcmV1bmxvYWQgPSBldmVudEhhbmRsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uYmVmb3JldW5sb2FkID09PSBldmVudEhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmJlZm9yZXVubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgalF1ZXJ5LnJlbW92ZUV2ZW50ID0gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciA/XG4gICAgICAgIGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBoYW5kbGUpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgaGFuZGxlKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5kZXRhY2hFdmVudCkge1xuICAgICAgICAgICAgICAgIGVsZW0uZGV0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIGpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgICAgIGlmICghdGhpcy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoc3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZW50IG9iamVjdFxuICAgICAgICBpZiAoc3JjICYmIHNyYy50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcbiAgICAgICAgICAgIC8vIEV2ZW50IHR5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWVTdGFtcCBpcyBidWdneSBmb3Igc29tZSBldmVudHMgb24gRmlyZWZveCgjMzg0MylcbiAgICAgICAgLy8gU28gd2Ugd29uJ3QgcmVseSBvbiB0aGUgbmF0aXZlIHZhbHVlXG4gICAgICAgIHRoaXMudGltZVN0YW1wID0galF1ZXJ5Lm5vdygpO1xuXG4gICAgICAgIC8vIE1hcmsgaXQgYXMgZml4ZWRcbiAgICAgICAgdGhpc1tqUXVlcnkuZXhwYW5kb10gPSB0cnVlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgICBqUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCB0aGUgcmV0dXJuVmFsdWUgcHJvcGVydHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGZhbHNlIChJRSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgICAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgdGhlIGNhbmNlbEJ1YmJsZSBwcm9wZXJ0eSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gdHJ1ZSAoSUUpXG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICAgICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxuICAgIH07XG5cbiAgICAvLyBDaGVja3MgaWYgYW4gZXZlbnQgaGFwcGVuZWQgb24gYW4gZWxlbWVudCB3aXRoaW4gYW5vdGhlciBlbGVtZW50XG4gICAgLy8gVXNlZCBpbiBqUXVlcnkuZXZlbnQuc3BlY2lhbC5tb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlIGhhbmRsZXJzXG4gICAgdmFyIHdpdGhpbkVsZW1lbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbW91c2Uob3ZlcnxvdXQpIGFyZSBzdGlsbCB3aXRoaW4gdGhlIHNhbWUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgdmFyIHBhcmVudCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgYXNzaWducyByZWxhdGVkVGFyZ2V0IGEgWFVMIGVsZW1lbnRcbiAgICAgICAgLy8gd2hpY2ggd2UgY2Fubm90IGFjY2VzcyB0aGUgcGFyZW50Tm9kZSBwcm9wZXJ0eSBvZlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJhdmVyc2UgdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIGNvcnJlY3QgZXZlbnQgdHlwZVxuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBldmVudC5kYXRhO1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGV2ZW50IGlmIHdlIGFjdHVhbGx5IGp1c3QgbW91c2VkIG9uIHRvIGEgbm9uIHN1Yi1lbGVtZW50XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmhhbmRsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhc3N1bWluZyB3ZSd2ZSBsZWZ0IHRoZSBlbGVtZW50IHNpbmNlIHdlIG1vc3QgbGlrZWx5IG1vdXNlZG92ZXIgYSB4dWwgZWxlbWVudFxuICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICB9LFxuXG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZXZlbnQgZGVsZWdhdGlvbiwgd2Ugb25seSBuZWVkIHRvIHJlbmFtZSB0aGUgZXZlbnQudHlwZSxcbiAgICAgICAgLy8gbGl2ZUhhbmRsZXIgd2lsbCB0YWtlIGNhcmUgb2YgdGhlIHJlc3QuXG4gICAgICAgIGRlbGVnYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50eXBlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5oYW5kbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgIC8vIENyZWF0ZSBtb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlIGV2ZW50c1xuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgICAgICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG4gICAgfSwgZnVuY3Rpb24gKG9yaWcsIGZpeCkge1xuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtvcmlnXSA9IHtcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcywgZml4LCBkYXRhICYmIGRhdGEuc2VsZWN0b3IgPyBkZWxlZ2F0ZSA6IHdpdGhpbkVsZW1lbnQsIG9yaWcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUodGhpcywgZml4LCBkYXRhICYmIGRhdGEuc2VsZWN0b3IgPyBkZWxlZ2F0ZSA6IHdpdGhpbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gc3VibWl0IGRlbGVnYXRpb25cbiAgICBpZiAoIWpRdWVyeS5zdXBwb3J0LnN1Ym1pdEJ1YmJsZXMpIHtcblxuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7XG4gICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24gKGRhdGEsIG5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImZvcm1cIikge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKHRoaXMsIFwiY2xpY2suc3BlY2lhbFN1Ym1pdFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlLnRhcmdldCwgdHlwZSA9IGVsZW0udHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlID09PSBcInN1Ym1pdFwiIHx8IHR5cGUgPT09IFwiaW1hZ2VcIikgJiYgalF1ZXJ5KGVsZW0pLmNsb3Nlc3QoXCJmb3JtXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUubGl2ZUZpcmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmlnZ2VyKFwic3VibWl0XCIsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcywgXCJrZXlwcmVzcy5zcGVjaWFsU3VibWl0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGUudGFyZ2V0LCB0eXBlID0gZWxlbS50eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHR5cGUgPT09IFwidGV4dFwiIHx8IHR5cGUgPT09IFwicGFzc3dvcmRcIikgJiYgalF1ZXJ5KGVsZW0pLmNsb3Nlc3QoXCJmb3JtXCIpLmxlbmd0aCAmJiBlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5saXZlRmlyZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXIoXCJzdWJtaXRcIiwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uIChuYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSh0aGlzLCBcIi5zcGVjaWFsU3VibWl0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIGRlbGVnYXRpb24sIGhhcHBlbnMgaGVyZSBzbyB3ZSBoYXZlIGJpbmQuXG4gICAgaWYgKCFqUXVlcnkuc3VwcG9ydC5jaGFuZ2VCdWJibGVzKSB7XG5cbiAgICAgICAgdmFyIGNoYW5nZUZpbHRlcnMsXG5cbiAgICAgICAgICAgIGdldFZhbCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBlbGVtLnR5cGUsIHZhbCA9IGVsZW0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBlbGVtLmNoZWNrZWQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic2VsZWN0LW11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZWxlbS5zZWxlY3RlZEluZGV4ID4gLTEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcChlbGVtLm9wdGlvbnMsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiLVwiKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlwiO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZWxlbS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0ZXN0Q2hhbmdlID0gZnVuY3Rpb24gdGVzdENoYW5nZShlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlLnRhcmdldCwgZGF0YSwgdmFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZm9ybUVsZW1zLnRlc3QoZWxlbS5ub2RlTmFtZSkgfHwgZWxlbS5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YSA9IGpRdWVyeS5kYXRhKGVsZW0sIFwiX2NoYW5nZV9kYXRhXCIpO1xuICAgICAgICAgICAgICAgIHZhbCA9IGdldFZhbChlbGVtKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGRhdGEgd2lsbCBiZSBhbHNvIHJldHJpZXZlZCBieSBiZWZvcmVhY3RpdmF0ZVxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgIT09IFwiZm9jdXNvdXRcIiB8fCBlbGVtLnR5cGUgIT09IFwicmFkaW9cIikge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YShlbGVtLCBcIl9jaGFuZ2VfZGF0YVwiLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsIHx8IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBlLnR5cGUgPSBcImNoYW5nZVwiO1xuICAgICAgICAgICAgICAgICAgICBlLmxpdmVGaXJlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKGUsIGFyZ3VtZW50c1sxXSwgZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5jaGFuZ2UgPSB7XG4gICAgICAgICAgICBmaWx0ZXJzOiB7XG4gICAgICAgICAgICAgICAgZm9jdXNvdXQ6IHRlc3RDaGFuZ2UsXG5cbiAgICAgICAgICAgICAgICBiZWZvcmVkZWFjdGl2YXRlOiB0ZXN0Q2hhbmdlLFxuXG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZS50YXJnZXQsIHR5cGUgPSBlbGVtLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicmFkaW9cIiB8fCB0eXBlID09PSBcImNoZWNrYm94XCIgfHwgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVzdENoYW5nZS5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBoYXMgdG8gYmUgY2FsbGVkIGJlZm9yZSBzdWJtaXRcbiAgICAgICAgICAgICAgICAvLyBLZXlkb3duIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBrZXlwcmVzcywgd2hpY2ggaXMgdXNlZCBpbiBzdWJtaXQtZXZlbnQgZGVsZWdhdGlvblxuICAgICAgICAgICAgICAgIGtleWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZS50YXJnZXQsIHR5cGUgPSBlbGVtLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChlLmtleUNvZGUgPT09IDEzICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJ0ZXh0YXJlYVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGUua2V5Q29kZSA9PT0gMzIgJiYgKHR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0eXBlID09PSBcInJhZGlvXCIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCJzZWxlY3QtbXVsdGlwbGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlc3RDaGFuZ2UuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyBCZWZvcmVhY3RpdmF0ZSBoYXBwZW5zIGFsc28gYmVmb3JlIHRoZSBwcmV2aW91cyBlbGVtZW50IGlzIGJsdXJyZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoIHRoaXMgZXZlbnQgeW91IGNhbid0IHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQsIGJ1dCB5b3UgY2FuIHN0b3JlXG4gICAgICAgICAgICAgICAgLy8gaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBiZWZvcmVhY3RpdmF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmRhdGEoZWxlbSwgXCJfY2hhbmdlX2RhdGFcIiwgZ2V0VmFsKGVsZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24gKGRhdGEsIG5hbWVzcGFjZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBjaGFuZ2VGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcywgdHlwZSArIFwiLnNwZWNpYWxDaGFuZ2VcIiwgY2hhbmdlRmlsdGVyc1t0eXBlXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJmb3JtRWxlbXMudGVzdCh0aGlzLm5vZGVOYW1lKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAobmFtZXNwYWNlcykge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUodGhpcywgXCIuc3BlY2lhbENoYW5nZVwiKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZm9ybUVsZW1zLnRlc3QodGhpcy5ub2RlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2hhbmdlRmlsdGVycyA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLmNoYW5nZS5maWx0ZXJzO1xuXG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBpbnB1dCBpcyAuZm9jdXMoKSdkXG4gICAgICAgIGNoYW5nZUZpbHRlcnMuZm9jdXMgPSBjaGFuZ2VGaWx0ZXJzLmJlZm9yZWFjdGl2YXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaWdnZXIodHlwZSwgZWxlbSwgYXJncykge1xuICAgICAgICBhcmdzWzBdLnR5cGUgPSB0eXBlO1xuICAgICAgICByZXR1cm4galF1ZXJ5LmV2ZW50LmhhbmRsZS5hcHBseShlbGVtLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xuICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGpRdWVyeS5lYWNoKHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24gKG9yaWcsIGZpeCkge1xuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNwZWNpYWxbZml4XSA9IHtcbiAgICAgICAgICAgICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNDb3VudHNbZml4XSsrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG9yaWcsIGhhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLS1mb2N1c0NvdW50c1tmaXhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG9yaWcsIGhhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGpRdWVyeS5ldmVudC5maXgoZSk7XG4gICAgICAgICAgICAgICAgZS50eXBlID0gZml4O1xuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlcihlLCBudWxsLCBlLnRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGpRdWVyeS5lYWNoKFtcImJpbmRcIiwgXCJvbmVcIl0sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG4gICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBmbikge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG9iamVjdCBsaXRlcmFsc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tuYW1lXShrZXksIGRhdGEsIHR5cGVba2V5XSwgZm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGRhdGEpIHx8IGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gbmFtZSA9PT0gXCJvbmVcIiA/IGpRdWVyeS5wcm94eShmbiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnVuYmluZChldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KSA6IGZuO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJ1bmxvYWRcIiAmJiBuYW1lICE9PSBcIm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmUodHlwZSwgZGF0YSwgZm4pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZCh0aGlzW2ldLCB0eXBlLCBoYW5kbGVyLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgb2JqZWN0IGxpdGVyYWxzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgIXR5cGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYmluZChrZXksIHR5cGVba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSh0aGlzW2ldLCB0eXBlLCBmbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxlZ2F0ZTogZnVuY3Rpb24gKHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpdmUodHlwZXMsIGRhdGEsIGZuLCBzZWxlY3Rvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5kZWxlZ2F0ZTogZnVuY3Rpb24gKHNlbGVjdG9yLCB0eXBlcywgZm4pIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5iaW5kKFwibGl2ZVwiKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaWUodHlwZXMsIG51bGwsIGZuLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpc1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IGpRdWVyeS5FdmVudCh0eXBlKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKGV2ZW50LCBkYXRhLCB0aGlzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHJlZmVyZW5jZSB0byBhcmd1bWVudHMgZm9yIGFjY2VzcyBpbiBjbG9zdXJlXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cywgaSA9IDE7XG5cbiAgICAgICAgICAgIC8vIGxpbmsgYWxsIHRoZSBmdW5jdGlvbnMsIHNvIGFueSBvZiB0aGVtIGNhbiB1bmJpbmQgdGhpcyBjbGljayBoYW5kbGVyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnByb3h5KGZuLCBhcmdzW2krK10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGljayhqUXVlcnkucHJveHkoZm4sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgICAgICAgICAgICAgIHZhciBsYXN0VG9nZ2xlID0gKGpRdWVyeS5kYXRhKHRoaXMsIFwibGFzdFRvZ2dsZVwiICsgZm4uZ3VpZCkgfHwgMCkgJSBpO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKHRoaXMsIFwibGFzdFRvZ2dsZVwiICsgZm4uZ3VpZCwgbGFzdFRvZ2dsZSArIDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY2xpY2tzIHN0b3BcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gYW5kIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbbGFzdFRvZ2dsZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBmYWxzZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcblxuICAgICAgICBob3ZlcjogZnVuY3Rpb24gKGZuT3ZlciwgZm5PdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoZm5PdmVyKS5tb3VzZWxlYXZlKGZuT3V0IHx8IGZuT3Zlcik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBsaXZlTWFwID0ge1xuICAgICAgICBmb2N1czogXCJmb2N1c2luXCIsXG4gICAgICAgIGJsdXI6IFwiZm9jdXNvdXRcIixcbiAgICAgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgICAgICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG4gICAgfTtcblxuICAgIGpRdWVyeS5lYWNoKFtcImxpdmVcIiwgXCJkaWVcIl0sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG4gICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uICh0eXBlcywgZGF0YSwgZm4sIG9yaWdTZWxlY3RvciAvKiBJbnRlcm5hbCBVc2UgT25seSAqLykge1xuICAgICAgICAgICAgdmFyIHR5cGUsIGkgPSAwLCBtYXRjaCwgbmFtZXNwYWNlcywgcHJlVHlwZSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IG9yaWdTZWxlY3RvciB8fCB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBvcmlnU2VsZWN0b3IgPyB0aGlzIDogalF1ZXJ5KHRoaXMuY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgJiYgIXR5cGVzLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRbbmFtZV0oa2V5LCBkYXRhLCB0eXBlc1trZXldLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihkYXRhKSkge1xuICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0eXBlcyA9ICh0eXBlcyB8fCBcIlwiKS5zcGxpdChcIiBcIik7XG5cbiAgICAgICAgICAgIHdoaWxlICgodHlwZSA9IHR5cGVzW2krK10pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHJuYW1lc3BhY2VzLmV4ZWModHlwZSk7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZS5yZXBsYWNlKHJuYW1lc3BhY2VzLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJob3ZlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goXCJtb3VzZWVudGVyXCIgKyBuYW1lc3BhY2VzLCBcIm1vdXNlbGVhdmVcIiArIG5hbWVzcGFjZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmVUeXBlID0gdHlwZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZvY3VzXCIgfHwgdHlwZSA9PT0gXCJibHVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaChsaXZlTWFwW3R5cGVdICsgbmFtZXNwYWNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlICsgbmFtZXNwYWNlcztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAobGl2ZU1hcFt0eXBlXSB8fCB0eXBlKSArIG5hbWVzcGFjZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibGl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbmQgbGl2ZSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gY29udGV4dC5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoY29udGV4dFtqXSwgXCJsaXZlLlwiICsgbGl2ZUNvbnZlcnQodHlwZSwgc2VsZWN0b3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZGF0YTogZGF0YSwgc2VsZWN0b3I6IHNlbGVjdG9yLCBoYW5kbGVyOiBmbiwgb3JpZ1R5cGU6IHR5cGUsIG9yaWdIYW5kbGVyOiBmbiwgcHJlVHlwZTogcHJlVHlwZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5iaW5kIGxpdmUgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnVuYmluZChcImxpdmUuXCIgKyBsaXZlQ29udmVydCh0eXBlLCBzZWxlY3RvciksIGZuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbGl2ZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIHN0b3AsIG1heExldmVsLCBlbGVtcyA9IFtdLCBzZWxlY3RvcnMgPSBbXSxcbiAgICAgICAgICAgIHJlbGF0ZWQsIG1hdGNoLCBoYW5kbGVPYmosIGVsZW0sIGosIGksIGwsIGRhdGEsIGNsb3NlLCBuYW1lc3BhY2UsIHJldCxcbiAgICAgICAgICAgIGV2ZW50cyA9IGpRdWVyeS5kYXRhKHRoaXMsIHRoaXMubm9kZVR5cGUgPyBcImV2ZW50c1wiIDogXCJfX2V2ZW50c19fXCIpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5ldmVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXG4gICAgICAgIGlmIChldmVudC5saXZlRmlyZWQgPT09IHRoaXMgfHwgIWV2ZW50cyB8fCAhZXZlbnRzLmxpdmUgfHwgZXZlbnQuYnV0dG9uICYmIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50Lm5hbWVzcGFjZSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgZXZlbnQubmFtZXNwYWNlLnNwbGl0KFwiLlwiKS5qb2luKFwiXFxcXC4oPzouKlxcXFwuKT9cIikgKyBcIihcXFxcLnwkKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LmxpdmVGaXJlZCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxpdmUgPSBldmVudHMubGl2ZS5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGl2ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaGFuZGxlT2JqID0gbGl2ZVtqXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZU9iai5vcmlnVHlwZS5yZXBsYWNlKHJuYW1lc3BhY2VzLCBcIlwiKSA9PT0gZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKGhhbmRsZU9iai5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGl2ZS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoID0galF1ZXJ5KGV2ZW50LnRhcmdldCkuY2xvc2VzdChzZWxlY3RvcnMsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBtYXRjaC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNsb3NlID0gbWF0Y2hbaV07XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsaXZlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gbGl2ZVtqXTtcblxuICAgICAgICAgICAgICAgIGlmIChjbG9zZS5zZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yICYmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZS50ZXN0KGhhbmRsZU9iai5uYW1lc3BhY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtID0gY2xvc2UuZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhvc2UgdHdvIGV2ZW50cyByZXF1aXJlIGFkZGl0aW9uYWwgY2hlY2tpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZU9iai5wcmVUeXBlID09PSBcIm1vdXNlZW50ZXJcIiB8fCBoYW5kbGVPYmoucHJlVHlwZSA9PT0gXCJtb3VzZWxlYXZlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoucHJlVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQgPSBqUXVlcnkoZXZlbnQucmVsYXRlZFRhcmdldCkuY2xvc2VzdChoYW5kbGVPYmouc2VsZWN0b3IpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxhdGVkIHx8IHJlbGF0ZWQgIT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zLnB1c2goeyBlbGVtOiBlbGVtLCBoYW5kbGVPYmo6IGhhbmRsZU9iaiwgbGV2ZWw6IGNsb3NlLmxldmVsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVsZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbWF0Y2ggPSBlbGVtc1tpXTtcblxuICAgICAgICAgICAgaWYgKG1heExldmVsICYmIG1hdGNoLmxldmVsID4gbWF4TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoLmVsZW07XG4gICAgICAgICAgICBldmVudC5kYXRhID0gbWF0Y2guaGFuZGxlT2JqLmRhdGE7XG4gICAgICAgICAgICBldmVudC5oYW5kbGVPYmogPSBtYXRjaC5oYW5kbGVPYmo7XG5cbiAgICAgICAgICAgIHJldCA9IG1hdGNoLmhhbmRsZU9iai5vcmlnSGFuZGxlci5hcHBseShtYXRjaC5lbGVtLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSB8fCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgICAgbWF4TGV2ZWwgPSBtYXRjaC5sZXZlbDtcblxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXZlQ29udmVydCh0eXBlLCBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gKHR5cGUgJiYgdHlwZSAhPT0gXCIqXCIgPyB0eXBlICsgXCIuXCIgOiBcIlwiKSArIHNlbGVjdG9yLnJlcGxhY2UocnBlcmlvZCwgXCJgXCIpLnJlcGxhY2UocnNwYWNlLCBcIiZcIik7XG4gICAgfVxuXG4gICAgalF1ZXJ5LmVhY2goKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuICAgICAgICBcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcbiAgICAgICAgXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yXCIpLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcbiAgICAgICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICAgICAgICAgICAgICAgIGlmIChmbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kKG5hbWUsIGRhdGEsIGZuKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuYW1lKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkuYXR0ckZuKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmF0dHJGbltuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy8gUHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUVcbiAgICAvLyBXaW5kb3cgaXNuJ3QgaW5jbHVkZWQgc28gYXMgbm90IHRvIHVuYmluZCBleGlzdGluZyB1bmxvYWQgZXZlbnRzXG4gICAgLy8gTW9yZSBpbmZvOlxuICAgIC8vICAtIGh0dHA6Ly9pc2FhY3NjaGx1ZXRlci5jb20vMjAwNi8xMC9tc2llLW1lbW9yeS1sZWFrcy9cbiAgICBpZiAod2luZG93LmF0dGFjaEV2ZW50ICYmICF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBqUXVlcnkod2luZG93KS5iaW5kKFwidW5sb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGpRdWVyeS5jYWNoZSkge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuY2FjaGVbaWRdLmhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkvQ2F0Y2ggaXMgdG8gaGFuZGxlIGlmcmFtZXMgYmVpbmcgdW5sb2FkZWQsIHNlZSAjNDI4MFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShqUXVlcnkuY2FjaGVbaWRdLmhhbmRsZS5lbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qIVxuICAgICAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIC0gdjEuMFxuICAgICAqICBDb3B5cmlnaHQgMjAwOSwgVGhlIERvam8gRm91bmRhdGlvblxuICAgICAqICBSZWxlYXNlZCB1bmRlciB0aGUgTUlULCBCU0QsIGFuZCBHUEwgTGljZW5zZXMuXG4gICAgICogIE1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gICAgICovXG4gICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgY2h1bmtlciA9IC8oKD86XFwoKD86XFwoW14oKV0rXFwpfFteKCldKykrXFwpfFxcWyg/OlxcW1teXFxbXFxdXSpcXF18WydcIl1bXidcIl0qWydcIl18W15cXFtcXF0nXCJdKykrXFxdfFxcXFwufFteID4rfiwoXFxbXFxcXF0rKSt8Wz4rfl0pKFxccyosXFxzKik/KCg/Oi58XFxyfFxcbikqKS9nLFxuICAgICAgICAgICAgZG9uZSA9IDAsXG4gICAgICAgICAgICB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSBmYWxzZSxcbiAgICAgICAgICAgIGJhc2VIYXNEdXBsaWNhdGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIEhlcmUgd2UgY2hlY2sgaWYgdGhlIEphdmFTY3JpcHQgZW5naW5lIGlzIHVzaW5nIHNvbWUgc29ydCBvZlxuICAgICAgICAvLyBvcHRpbWl6YXRpb24gd2hlcmUgaXQgZG9lcyBub3QgYWx3YXlzIGNhbGwgb3VyIGNvbXBhcmlzaW9uXG4gICAgICAgIC8vIGZ1bmN0aW9uLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCBkaXNjYXJkIHRoZSBoYXNEdXBsaWNhdGUgdmFsdWUuXG4gICAgICAgIC8vICAgVGh1cyBmYXIgdGhhdCBpbmNsdWRlcyBHb29nbGUgQ2hyb21lLlxuICAgICAgICBbMCwgMF0uc29ydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBiYXNlSGFzRHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIFNpenpsZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICAgICAgdmFyIG9yaWdDb250ZXh0ID0gY29udGV4dDtcblxuICAgICAgICAgICAgaWYgKGNvbnRleHQubm9kZVR5cGUgIT09IDEgJiYgY29udGV4dC5ub2RlVHlwZSAhPT0gOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcnRzID0gW10sIG0sIHNldCwgY2hlY2tTZXQsIGV4dHJhLCBwcnVuZSA9IHRydWUsIGNvbnRleHRYTUwgPSBTaXp6bGUuaXNYTUwoY29udGV4dCksXG4gICAgICAgICAgICAgICAgc29GYXIgPSBzZWxlY3RvciwgcmV0LCBjdXIsIHBvcCwgaTtcblxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjaHVua2VyIHJlZ2V4cCAoc3RhcnQgZnJvbSBoZWFkKVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNodW5rZXIuZXhlYyhcIlwiKTtcbiAgICAgICAgICAgICAgICBtID0gY2h1bmtlci5leGVjKHNvRmFyKTtcblxuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvRmFyID0gbVszXTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKG1bMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYSA9IG1bM107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG0pO1xuXG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBvcmlnUE9TLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMiAmJiBFeHByLnJlbGF0aXZlW3BhcnRzWzBdXSkge1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSBwb3NQcm9jZXNzKHBhcnRzWzBdICsgcGFydHNbMV0sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IEV4cHIucmVsYXRpdmVbcGFydHNbMF1dID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb250ZXh0XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUocGFydHMuc2hpZnQoKSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRXhwci5yZWxhdGl2ZVtzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciArPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgPSBwb3NQcm9jZXNzKHNlbGVjdG9yLCBzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICAgICAgICAgIC8vIChidXQgbm90IGlmIGl0J2xsIGJlIGZhc3RlciBpZiB0aGUgaW5uZXIgc2VsZWN0b3IgaXMgYW4gSUQpXG4gICAgICAgICAgICAgICAgaWYgKCFzZWVkICYmIHBhcnRzLmxlbmd0aCA+IDEgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiAhY29udGV4dFhNTCAmJlxuICAgICAgICAgICAgICAgICAgICBFeHByLm1hdGNoLklELnRlc3QocGFydHNbMF0pICYmICFFeHByLm1hdGNoLklELnRlc3QocGFydHNbcGFydHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IFNpenpsZS5maW5kKHBhcnRzLnNoaWZ0KCksIGNvbnRleHQsIGNvbnRleHRYTUwpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gcmV0LmV4cHIgPyBTaXp6bGUuZmlsdGVyKHJldC5leHByLCByZXQuc2V0KVswXSA6IHJldC5zZXRbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gc2VlZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICB7IGV4cHI6IHBhcnRzLnBvcCgpLCBzZXQ6IG1ha2VBcnJheShzZWVkKSB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5maW5kKHBhcnRzLnBvcCgpLCBwYXJ0cy5sZW5ndGggPT09IDEgJiYgKHBhcnRzWzBdID09PSBcIn5cIiB8fCBwYXJ0c1swXSA9PT0gXCIrXCIpICYmIGNvbnRleHQucGFyZW50Tm9kZSA/IGNvbnRleHQucGFyZW50Tm9kZSA6IGNvbnRleHQsIGNvbnRleHRYTUwpO1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSByZXQuZXhwciA/IFNpenpsZS5maWx0ZXIocmV0LmV4cHIsIHJldC5zZXQpIDogcmV0LnNldDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXQgPSBtYWtlQXJyYXkoc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBydW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcCA9IGN1cjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFFeHByLnJlbGF0aXZlW2N1cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3AgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgRXhwci5yZWxhdGl2ZVtjdXJdKGNoZWNrU2V0LCBwb3AsIGNvbnRleHRYTUwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXQgPSBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGVja1NldCkge1xuICAgICAgICAgICAgICAgIGNoZWNrU2V0ID0gc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoZWNrU2V0KSB7XG4gICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKGN1ciB8fCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b1N0cmluZy5jYWxsKGNoZWNrU2V0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcnVuZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgY2hlY2tTZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGNoZWNrU2V0W2ldICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrU2V0W2ldICYmIChjaGVja1NldFtpXSA9PT0gdHJ1ZSB8fCBjaGVja1NldFtpXS5ub2RlVHlwZSA9PT0gMSAmJiBTaXp6bGUuY29udGFpbnMoY29udGV4dCwgY2hlY2tTZXRbaV0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzZXRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgY2hlY2tTZXRbaV0gIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tTZXRbaV0gJiYgY2hlY2tTZXRbaV0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc2V0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFrZUFycmF5KGNoZWNrU2V0LCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgU2l6emxlKGV4dHJhLCBvcmlnQ29udGV4dCwgcmVzdWx0cywgc2VlZCk7XG4gICAgICAgICAgICAgICAgU2l6emxlLnVuaXF1ZVNvcnQocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChzb3J0T3JkZXIpIHtcbiAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSBiYXNlSGFzRHVwbGljYXRlO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMuc29ydChzb3J0T3JkZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldID09PSByZXN1bHRzW2kgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24gKGV4cHIsIHNldCkge1xuICAgICAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBudWxsLCBudWxsLCBzZXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAobm9kZSwgZXhwcikge1xuICAgICAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBudWxsLCBudWxsLCBbbm9kZV0pLmxlbmd0aCA+IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgU2l6emxlLmZpbmQgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCwgaXNYTUwpIHtcbiAgICAgICAgICAgIHZhciBzZXQ7XG5cbiAgICAgICAgICAgIGlmICghZXhwcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBFeHByLm9yZGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gRXhwci5vcmRlcltpXSwgbWF0Y2g7XG5cbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gRXhwci5sZWZ0TWF0Y2hbdHlwZV0uZXhlYyhleHByKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guc3BsaWNlKDEsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LnN1YnN0cihsZWZ0Lmxlbmd0aCAtIDEpICE9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0gPSAobWF0Y2hbMV0gfHwgXCJcIikucmVwbGFjZSgvXFxcXC9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IEV4cHIuZmluZFt0eXBlXShtYXRjaCwgY29udGV4dCwgaXNYTUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IGV4cHIucmVwbGFjZShFeHByLm1hdGNoW3R5cGVdLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICAgICAgICBzZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgc2V0OiBzZXQsIGV4cHI6IGV4cHIgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBTaXp6bGUuZmlsdGVyID0gZnVuY3Rpb24gKGV4cHIsIHNldCwgaW5wbGFjZSwgbm90KSB7XG4gICAgICAgICAgICB2YXIgb2xkID0gZXhwciwgcmVzdWx0ID0gW10sIGN1ckxvb3AgPSBzZXQsIG1hdGNoLCBhbnlGb3VuZCxcbiAgICAgICAgICAgICAgICBpc1hNTEZpbHRlciA9IHNldCAmJiBzZXRbMF0gJiYgU2l6emxlLmlzWE1MKHNldFswXSk7XG5cbiAgICAgICAgICAgIHdoaWxlIChleHByICYmIHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIEV4cHIuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSBFeHByLmxlZnRNYXRjaFt0eXBlXS5leGVjKGV4cHIpKSAhPSBudWxsICYmIG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gRXhwci5maWx0ZXJbdHlwZV0sIGZvdW5kLCBpdGVtLCBsZWZ0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBhbnlGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5zcGxpY2UoMSwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LnN1YnN0cihsZWZ0Lmxlbmd0aCAtIDEpID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyTG9vcCA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChFeHByLnByZUZpbHRlclt0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gRXhwci5wcmVGaWx0ZXJbdHlwZV0obWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90LCBpc1hNTEZpbHRlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueUZvdW5kID0gZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgKGl0ZW0gPSBjdXJMb29wW2ldKSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZmlsdGVyKGl0ZW0sIG1hdGNoLCBpLCBjdXJMb29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXNzID0gbm90IF4gISFmb3VuZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucGxhY2UgJiYgZm91bmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFueUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMb29wW2ldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5wbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMb29wID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoRXhwci5tYXRjaFt0eXBlXSwgXCJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFueUZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEltcHJvcGVyIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBpZiAoZXhwciA9PT0gb2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbnlGb3VuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9sZCA9IGV4cHI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjdXJMb29wO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNpenpsZS5lcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIHRocm93IFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2c7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuICAgICAgICAgICAgb3JkZXI6IFtcIklEXCIsIFwiTkFNRVwiLCBcIlRBR1wiXSxcbiAgICAgICAgICAgIG1hdGNoOiB7XG4gICAgICAgICAgICAgICAgSUQ6IC8jKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspLyxcbiAgICAgICAgICAgICAgICBDTEFTUzogL1xcLigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKS8sXG4gICAgICAgICAgICAgICAgTkFNRTogL1xcW25hbWU9WydcIl0qKCg/OltcXHdcXHUwMGMwLVxcdUZGRkZcXC1dfFxcXFwuKSspWydcIl0qXFxdLyxcbiAgICAgICAgICAgICAgICBBVFRSOiAvXFxbXFxzKigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKVxccyooPzooXFxTPz0pXFxzKihbJ1wiXSopKC4qPylcXDN8KVxccypcXF0vLFxuICAgICAgICAgICAgICAgIFRBRzogL14oKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcKlxcLV18XFxcXC4pKykvLFxuICAgICAgICAgICAgICAgIENISUxEOiAvOihvbmx5fG50aHxsYXN0fGZpcnN0KS1jaGlsZCg/OlxcKChldmVufG9kZHxbXFxkbitcXC1dKilcXCkpPy8sXG4gICAgICAgICAgICAgICAgUE9TOiAvOihudGh8ZXF8Z3R8bHR8Zmlyc3R8bGFzdHxldmVufG9kZCkoPzpcXCgoXFxkKilcXCkpPyg/PVteXFwtXXwkKS8sXG4gICAgICAgICAgICAgICAgUFNFVURPOiAvOigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKSg/OlxcKChbJ1wiXT8pKCg/OlxcKFteXFwpXStcXCl8W15cXChcXCldKikrKVxcMlxcKSk/L1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlZnRNYXRjaDoge30sXG4gICAgICAgICAgICBhdHRyTWFwOiB7XG4gICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICAgICAgICAgIFwiZm9yXCI6IFwiaHRtbEZvclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXR0ckhhbmRsZToge1xuICAgICAgICAgICAgICAgIGhyZWY6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICAgICAgXCIrXCI6IGZ1bmN0aW9uIChjaGVja1NldCwgcGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQYXJ0U3RyID0gdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RhZyA9IGlzUGFydFN0ciAmJiAhL1xcVy8udGVzdChwYXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFydFN0ck5vdFRhZyA9IGlzUGFydFN0ciAmJiAhaXNUYWc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGgsIGVsZW07IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWxlbSA9IGNoZWNrU2V0W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW0ucHJldmlvdXNTaWJsaW5nKSAmJiBlbGVtLm5vZGVUeXBlICE9PSAxKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU2V0W2ldID0gaXNQYXJ0U3RyTm90VGFnIHx8IGVsZW0gJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBwYXJ0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSB8fCBmYWxzZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPT09IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYXJ0U3RyTm90VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZmlsdGVyKHBhcnQsIGNoZWNrU2V0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCI+XCI6IGZ1bmN0aW9uIChjaGVja1NldCwgcGFydCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNQYXJ0U3RyID0gdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLCBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYXJ0U3RyICYmICEvXFxXLy50ZXN0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjaGVja1NldFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1NldFtpXSA9IHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBwYXJ0ID8gcGFyZW50IDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gY2hlY2tTZXRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXRbaV0gPSBpc1BhcnRTdHIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZSA9PT0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1BhcnRTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZmlsdGVyKHBhcnQsIGNoZWNrU2V0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJcIjogZnVuY3Rpb24gKGNoZWNrU2V0LCBwYXJ0LCBpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZU5hbWUgPSBkb25lKyssIGNoZWNrRm4gPSBkaXJDaGVjaywgbm9kZUNoZWNrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAhL1xcVy8udGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVDaGVjayA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ZuID0gZGlyTm9kZUNoZWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGbihcInBhcmVudE5vZGVcIiwgcGFydCwgZG9uZU5hbWUsIGNoZWNrU2V0LCBub2RlQ2hlY2ssIGlzWE1MKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiflwiOiBmdW5jdGlvbiAoY2hlY2tTZXQsIHBhcnQsIGlzWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb25lTmFtZSA9IGRvbmUrKywgY2hlY2tGbiA9IGRpckNoZWNrLCBub2RlQ2hlY2s7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiICYmICEvXFxXLy50ZXN0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUNoZWNrID0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRm4gPSBkaXJOb2RlQ2hlY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGVja0ZuKFwicHJldmlvdXNTaWJsaW5nXCIsIHBhcnQsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmQ6IHtcbiAgICAgICAgICAgICAgICBJRDogZnVuY3Rpb24gKG1hdGNoLCBjb250ZXh0LCBpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFttXSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBOQU1FOiBmdW5jdGlvbiAobWF0Y2gsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gW10sIHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKG1hdGNoWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZXN1bHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT09IG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBudWxsIDogcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBUQUc6IGZ1bmN0aW9uIChtYXRjaCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZUZpbHRlcjoge1xuICAgICAgICAgICAgICAgIENMQVNTOiBmdW5jdGlvbiAobWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90LCBpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IFwiIFwiICsgbWF0Y2hbMV0ucmVwbGFjZSgvXFxcXC9nLCBcIlwiKSArIFwiIFwiO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gY3VyTG9vcFtpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3QgXiAoZWxlbS5jbGFzc05hbWUgJiYgKFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZSgvW1xcdFxcbl0vZywgXCIgXCIpLmluZGV4T2YobWF0Y2gpID49IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5wbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTG9vcFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIElEOiBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzFdLnJlcGxhY2UoL1xcXFwvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBUQUc6IGZ1bmN0aW9uIChtYXRjaCwgY3VyTG9vcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIENISUxEOiBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSBcIm50aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSBlcXVhdGlvbnMgbGlrZSAnZXZlbicsICdvZGQnLCAnNScsICcybicsICczbisyJywgJzRuLTEnLCAnLW4rNidcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gLygtPykoXFxkKiluKCg/OlxcK3wtKT9cXGQqKS8uZXhlYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9PT0gXCJldmVuXCIgJiYgXCIyblwiIHx8IG1hdGNoWzJdID09PSBcIm9kZFwiICYmIFwiMm4rMVwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIS9cXEQvLnRlc3QobWF0Y2hbMl0pICYmIFwiMG4rXCIgKyBtYXRjaFsyXSB8fCBtYXRjaFsyXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVycyAoZmlyc3QpbisobGFzdCkgaW5jbHVkaW5nIGlmIHRoZXkgYXJlIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9ICh0ZXN0WzFdICsgKHRlc3RbMl0gfHwgMSkpIC0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzNdID0gdGVzdFszXSAtIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRvIG5vcm1hbCBjYWNoaW5nIHN5c3RlbVxuICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSA9IGRvbmUrKztcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBBVFRSOiBmdW5jdGlvbiAobWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90LCBpc1hNTCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG1hdGNoWzFdLnJlcGxhY2UoL1xcXFwvZywgXCJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1hNTCAmJiBFeHByLmF0dHJNYXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdID0gRXhwci5hdHRyTWFwW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzJdID09PSBcIn49XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzRdID0gXCIgXCIgKyBtYXRjaFs0XSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgUFNFVURPOiBmdW5jdGlvbiAobWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gXCJub3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgY29tcGxleCBleHByZXNzaW9uLCBvciBhIHNpbXBsZSBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2h1bmtlci5leGVjKG1hdGNoWzNdKSB8fCBcIlwiKS5sZW5ndGggPiAxIHx8IC9eXFx3Ly50ZXN0KG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzNdID0gU2l6emxlKG1hdGNoWzNdLCBudWxsLCBudWxsLCBjdXJMb29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFNpenpsZS5maWx0ZXIobWF0Y2hbM10sIGN1ckxvb3AsIGlucGxhY2UsIHRydWUgXiBub3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5wbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFeHByLm1hdGNoLlBPUy50ZXN0KG1hdGNoWzBdKSB8fCBFeHByLm1hdGNoLkNISUxELnRlc3QobWF0Y2hbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFBPUzogZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLnVuc2hpZnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyczoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSAmJiBlbGVtLnR5cGUgIT09IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGVja2VkOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5jaGVja2VkID09PSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIWVsZW0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVtcHR5OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVsZW0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24gKGVsZW0sIGksIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIVNpenpsZShtYXRjaFszXSwgZWxlbSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC9oXFxkL2kpLnRlc3QoZWxlbS5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZXh0XCIgPT09IGVsZW0udHlwZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJhZGlvOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyYWRpb1wiID09PSBlbGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaGVja2JveDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY2hlY2tib3hcIiA9PT0gZWxlbS50eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmlsZTogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZmlsZVwiID09PSBlbGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicGFzc3dvcmRcIiA9PT0gZWxlbS50eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3VibWl0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdWJtaXRcIiA9PT0gZWxlbS50eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImltYWdlXCIgPT09IGVsZW0udHlwZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyZXNldFwiID09PSBlbGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBidXR0b246IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJ1dHRvblwiID09PSBlbGVtLnR5cGUgfHwgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24vaSkudGVzdChlbGVtLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0RmlsdGVyczoge1xuICAgICAgICAgICAgICAgIGZpcnN0OiBmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA9PT0gMDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxhc3Q6IGZ1bmN0aW9uIChlbGVtLCBpLCBtYXRjaCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPT09IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBldmVuOiBmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAlIDIgPT09IDA7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvZGQ6IGZ1bmN0aW9uIChlbGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICUgMiA9PT0gMTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGx0OiBmdW5jdGlvbiAoZWxlbSwgaSwgbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBtYXRjaFszXSAtIDA7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBndDogZnVuY3Rpb24gKGVsZW0sIGksIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpID4gbWF0Y2hbM10gLSAwO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbnRoOiBmdW5jdGlvbiAoZWxlbSwgaSwgbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzNdIC0gMCA9PT0gaTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVxOiBmdW5jdGlvbiAoZWxlbSwgaSwgbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzNdIC0gMCA9PT0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgUFNFVURPOiBmdW5jdGlvbiAoZWxlbSwgbWF0Y2gsIGksIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbWF0Y2hbMV0sIGZpbHRlciA9IEV4cHIuZmlsdGVyc1tuYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyKGVsZW0sIGksIG1hdGNoLCBhcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJjb250YWluc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgU2l6emxlLmdldFRleHQoW2VsZW1dKSB8fCBcIlwiKS5pbmRleE9mKG1hdGNoWzNdKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwibm90XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3QgPSBtYXRjaFszXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBub3QubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdFtqXSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIENISUxEOiBmdW5jdGlvbiAoZWxlbSwgbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXSwgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb25seSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaXJzdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZmlyc3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBtYXRjaFsyXSwgbGFzdCA9IG1hdGNoWzNdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmVOYW1lID0gbWF0Y2hbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgKHBhcmVudC5zaXpjYWNoZSAhPT0gZG9uZU5hbWUgfHwgIWVsZW0ubm9kZUluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlSW5kZXggPSArK2NvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5zaXpjYWNoZSA9IGRvbmVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gZWxlbS5ub2RlSW5kZXggLSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBJRDogZnVuY3Rpb24gKGVsZW0sIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IG1hdGNoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgVEFHOiBmdW5jdGlvbiAoZWxlbSwgbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtYXRjaCA9PT0gXCIqXCIgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkgfHwgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBtYXRjaDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIENMQVNTOiBmdW5jdGlvbiAoZWxlbSwgbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIiBcIiArIChlbGVtLmNsYXNzTmFtZSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKSArIFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluZGV4T2YobWF0Y2gpID4gLTE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBBVFRSOiBmdW5jdGlvbiAoZWxlbSwgbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEV4cHIuYXR0ckhhbmRsZVtuYW1lXSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRXhwci5hdHRySGFuZGxlW25hbWVdKGVsZW0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtW25hbWVdICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtW25hbWVdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdCArIFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVjayA9IG1hdGNoWzRdO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcIiE9XCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCI9XCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSBjaGVjayA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCIqPVwiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuaW5kZXhPZihjaGVjaykgPj0gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwifj1cIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCIgXCIgKyB2YWx1ZSArIFwiIFwiKS5pbmRleE9mKGNoZWNrKSA+PSAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFjaGVjayA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgJiYgcmVzdWx0ICE9PSBmYWxzZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCIhPVwiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IGNoZWNrIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCJePVwiID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmluZGV4T2YoY2hlY2spID09PSAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IFwiJD1cIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKHZhbHVlLmxlbmd0aCAtIGNoZWNrLmxlbmd0aCkgPT09IGNoZWNrIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcInw9XCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gY2hlY2sgfHwgdmFsdWUuc3Vic3RyKDAsIGNoZWNrLmxlbmd0aCArIDEpID09PSBjaGVjayArIFwiLVwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBQT1M6IGZ1bmN0aW9uIChlbGVtLCBtYXRjaCwgaSwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFsyXSwgZmlsdGVyID0gRXhwci5zZXRGaWx0ZXJzW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoZWxlbSwgaSwgbWF0Y2gsIGFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb3JpZ1BPUyA9IEV4cHIubWF0Y2guUE9TLFxuICAgICAgICAgICAgZmVzY2FwZSA9IGZ1bmN0aW9uIChhbGwsIG51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIChudW0gLSAwICsgMSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gRXhwci5tYXRjaCkge1xuICAgICAgICAgICAgRXhwci5tYXRjaFt0eXBlXSA9IG5ldyBSZWdFeHAoRXhwci5tYXRjaFt0eXBlXS5zb3VyY2UgKyAoLyg/IVteXFxbXSpcXF0pKD8hW15cXChdKlxcKSkvLnNvdXJjZSkpO1xuICAgICAgICAgICAgRXhwci5sZWZ0TWF0Y2hbdHlwZV0gPSBuZXcgUmVnRXhwKC8oXig/Oi58XFxyfFxcbikqPykvLnNvdXJjZSArIEV4cHIubWF0Y2hbdHlwZV0uc291cmNlLnJlcGxhY2UoL1xcXFwoXFxkKykvZywgZmVzY2FwZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ha2VBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgcmVzdWx0cykge1xuICAgICAgICAgICAgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheSwgMCk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIGFycmF5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBlcmZvcm0gYSBzaW1wbGUgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2ZcbiAgICAgICAgLy8gY29udmVydGluZyBhIE5vZGVMaXN0IHRvIGFuIGFycmF5IHVzaW5nIGJ1aWx0aW4gbWV0aG9kcy5cbiAgICAgICAgLy8gQWxzbyB2ZXJpZmllcyB0aGF0IHRoZSByZXR1cm5lZCBhcnJheSBob2xkcyBET00gbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGlzIG5vdCB0aGUgY2FzZSBpbiB0aGUgQmxhY2tiZXJyeSBicm93c2VyKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNoaWxkTm9kZXMsIDApWzBdLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgZmFsbGJhY2sgbWV0aG9kIGlmIGl0IGRvZXMgbm90IHdvcmtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbWFrZUFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHJlc3VsdHMgfHwgW10sIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmNhbGwoYXJyYXkpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmV0LCBhcnJheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcnJheS5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgYXJyYXlbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvcnRPcmRlciwgc2libGluZ0NoZWNrO1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICAgICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIHx8ICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgNCA/IC0xIDogMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0T3JkZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhcCA9IFtdLCBicCA9IFtdLCBhdXAgPSBhLnBhcmVudE5vZGUsIGJ1cCA9IGIucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gYXVwLCBhbCwgYmw7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZXMgYXJlIGlkZW50aWNhbCwgd2UgY2FuIGV4aXQgZWFybHlcbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzIChvciBpZGVudGljYWwpIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdXAgPT09IGJ1cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2libGluZ0NoZWNrKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIHBhcmVudHMgd2VyZSBmb3VuZCB0aGVuIHRoZSBub2RlcyBhcmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghYXVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJ1cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhleSdyZSBzb21ld2hlcmUgZWxzZSBpbiB0aGUgdHJlZSBzbyB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gYnVpbGQgdXAgYSBmdWxsIGxpc3Qgb2YgdGhlIHBhcmVudE5vZGVzIGZvciBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICBhcC51bnNoaWZ0KGN1cik7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1ciA9IGJ1cDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnAudW5zaGlmdChjdXIpO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhbCA9IGFwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBibCA9IGJwLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHdhbGtpbmcgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbCAmJiBpIDwgYmw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXBbaV0gIT09IGJwW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2libGluZ0NoZWNrKGFwW2ldLCBicFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBlbmRlZCBzb21lcGxhY2UgdXAgdGhlIHRyZWUgc28gZG8gYSBzaWJsaW5nIGNoZWNrXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPT09IGFsID9cbiAgICAgICAgICAgICAgICAgICAgc2libGluZ0NoZWNrKGEsIGJwW2ldLCAtMSkgOlxuICAgICAgICAgICAgICAgICAgICBzaWJsaW5nQ2hlY2soYXBbaV0sIGIsIDEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2libGluZ0NoZWNrID0gZnVuY3Rpb24gKGEsIGIsIHJldCkge1xuICAgICAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN1ciA9IGEubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyZWl2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICAgICAgICBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChlbGVtcykge1xuICAgICAgICAgICAgdmFyIHJldCA9IFwiXCIsIGVsZW07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBlbGVtc1tpXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbSA9IGVsZW1zW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0ZXh0IGZyb20gdGV4dCBub2RlcyBhbmQgQ0RBVEEgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCArPSBlbGVtLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBldmVyeXRoaW5nIGVsc2UsIGV4Y2VwdCBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtLm5vZGVUeXBlICE9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCArPSBTaXp6bGUuZ2V0VGV4dChlbGVtLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lIHdoZW5cbiAgICAgICAgLy8gcXVlcnlpbmcgYnkgZ2V0RWxlbWVudEJ5SWQgKGFuZCBwcm92aWRlIGEgd29ya2Fyb3VuZClcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGluamVjdCBhIGZha2UgaW5wdXQgZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIG5hbWVcbiAgICAgICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgICAgICBpZCA9IFwic2NyaXB0XCIgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgZm9ybS5pbm5lckhUTUwgPSBcIjxhIG5hbWU9J1wiICsgaWQgKyBcIicvPlwiO1xuXG4gICAgICAgICAgICAvLyBJbmplY3QgaXQgaW50byB0aGUgcm9vdCBlbGVtZW50LCBjaGVjayBpdHMgc3RhdHVzLCBhbmQgcmVtb3ZlIGl0IHF1aWNrbHlcbiAgICAgICAgICAgIHZhciByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcm9vdC5pbnNlcnRCZWZvcmUoZm9ybSwgcm9vdC5maXJzdENoaWxkKTtcblxuICAgICAgICAgICAgLy8gVGhlIHdvcmthcm91bmQgaGFzIHRvIGRvIGFkZGl0aW9uYWwgY2hlY2tzIGFmdGVyIGEgZ2V0RWxlbWVudEJ5SWRcbiAgICAgICAgICAgIC8vIFdoaWNoIHNsb3dzIHRoaW5ncyBkb3duIGZvciBvdGhlciBicm93c2VycyAoaGVuY2UgdGhlIGJyYW5jaGluZylcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpIHtcbiAgICAgICAgICAgICAgICBFeHByLmZpbmQuSUQgPSBmdW5jdGlvbiAobWF0Y2gsIGNvbnRleHQsIGlzWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbSA/IG0uaWQgPT09IG1hdGNoWzFdIHx8IHR5cGVvZiBtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikubm9kZVZhbHVlID09PSBtYXRjaFsxXSA/IFttXSA6IHVuZGVmaW5lZCA6IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIEV4cHIuZmlsdGVyLklEID0gZnVuY3Rpb24gKGVsZW0sIG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgbm9kZSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChmb3JtKTtcbiAgICAgICAgICAgIHJvb3QgPSBmb3JtID0gbnVsbDsgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcbiAgICAgICAgfSkoKTtcblxuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBicm93c2VyIHJldHVybnMgb25seSBlbGVtZW50c1xuICAgICAgICAgICAgLy8gd2hlbiBkb2luZyBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIilcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG5vIGNvbW1lbnRzIGFyZSBmb3VuZFxuICAgICAgICAgICAgaWYgKGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIEV4cHIuZmluZC5UQUcgPSBmdW5jdGlvbiAobWF0Y2gsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKG1hdGNoWzFdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IHJlc3VsdHNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKHJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhbiBhdHRyaWJ1dGUgcmV0dXJucyBub3JtYWxpemVkIGhyZWYgYXR0cmlidXRlc1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuICAgICAgICAgICAgaWYgKGRpdi5maXJzdENoaWxkICYmIHR5cGVvZiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpICE9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIEV4cHIuYXR0ckhhbmRsZS5ocmVmID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaHJlZlwiLCAyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXYgPSBudWxsOyAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRTaXp6bGUgPSBTaXp6bGUsIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPHAgY2xhc3M9J1RFU1QnPjwvcD5cIjtcblxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBjYW4ndCBoYW5kbGUgdXBwZXJjYXNlIG9yIHVuaWNvZGUgY2hhcmFjdGVycyB3aGVuXG4gICAgICAgICAgICAgICAgLy8gaW4gcXVpcmtzIG1vZGUuXG4gICAgICAgICAgICAgICAgaWYgKGRpdi5xdWVyeVNlbGVjdG9yQWxsICYmIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLlRFU1RcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBTaXp6bGUgPSBmdW5jdGlvbiAocXVlcnksIGNvbnRleHQsIGV4dHJhLCBzZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlIHF1ZXJ5U2VsZWN0b3JBbGwgb24gbm9uLVhNTCBkb2N1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gKElEIHNlbGVjdG9ycyBkb24ndCB3b3JrIGluIG5vbi1IVE1MIGRvY3VtZW50cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVkICYmICFTaXp6bGUuaXNYTUwoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VBcnJheShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLCBleHRyYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAocXNhRXJyb3IpIHsgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3b3JraW5nIHVwIGZyb20gdGhlcmUgKFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGUgdGVjaG5pcXVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm5vZGVUeXBlID09PSAxICYmIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGQgPSBjb250ZXh0LmlkLCBpZCA9IGNvbnRleHQuaWQgPSBcIl9fc2l6emxlX19cIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlQXJyYXkoY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKFwiI1wiICsgaWQgKyBcIiBcIiArIHF1ZXJ5KSwgZXh0cmEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAocHNldWRvRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmlkID0gb2xkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFNpenpsZShxdWVyeSwgY29udGV4dCwgZXh0cmEsIHNlZWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9sZFNpenpsZSkge1xuICAgICAgICAgICAgICAgICAgICBTaXp6bGVbcHJvcF0gPSBvbGRTaXp6bGVbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGl2ID0gbnVsbDsgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cblxuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IGh0bWwubWF0Y2hlc1NlbGVjdG9yIHx8IGh0bWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGh0bWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGh0bWwubXNNYXRjaGVzU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgcHNldWRvV29ya3MgPSBmYWxzZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgLy8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIG1hdGNoZXMuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIFwiOnNpenpsZVwiKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAocHNldWRvRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBwc2V1ZG9Xb3JrcyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChub2RlLCBleHByKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHNldWRvV29ya3MgfHwgIUV4cHIubWF0Y2guUFNFVURPLnRlc3QoZXhwcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKG5vZGUsIGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKGV4cHIsIG51bGwsIG51bGwsIFtub2RlXSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0ndGVzdCBlJz48L2Rpdj48ZGl2IGNsYXNzPSd0ZXN0Jz48L2Rpdj5cIjtcblxuICAgICAgICAgICAgLy8gT3BlcmEgY2FuJ3QgZmluZCBhIHNlY29uZCBjbGFzc25hbWUgKGluIDkuNilcbiAgICAgICAgICAgIC8vIEFsc28sIG1ha2Ugc3VyZSB0aGF0IGdldEVsZW1lbnRzQnlDbGFzc05hbWUgYWN0dWFsbHkgZXhpc3RzXG4gICAgICAgICAgICBpZiAoIWRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lIHx8IGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZVwiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhZmFyaSBjYWNoZXMgY2xhc3MgYXR0cmlidXRlcywgZG9lc24ndCBjYXRjaCBjaGFuZ2VzIChpbiAzLjIpXG4gICAgICAgICAgICBkaXYubGFzdENoaWxkLmNsYXNzTmFtZSA9IFwiZVwiO1xuXG4gICAgICAgICAgICBpZiAoZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJlXCIpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRXhwci5vcmRlci5zcGxpY2UoMSwgMCwgXCJDTEFTU1wiKTtcbiAgICAgICAgICAgIEV4cHIuZmluZC5DTEFTUyA9IGZ1bmN0aW9uIChtYXRjaCwgY29udGV4dCwgaXNYTUwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZGl2ID0gbnVsbDsgLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBmdW5jdGlvbiBkaXJOb2RlQ2hlY2soZGlyLCBjdXIsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGNoZWNrU2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtW2Rpcl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5zaXpjYWNoZSA9PT0gZG9uZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGNoZWNrU2V0W2VsZW0uc2l6c2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWlzWE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zaXpjYWNoZSA9IGRvbmVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2l6c2V0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTZXRbaV0gPSBtYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkaXJDaGVjayhkaXIsIGN1ciwgZG9uZU5hbWUsIGNoZWNrU2V0LCBub2RlQ2hlY2ssIGlzWE1MKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoZWNrU2V0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gY2hlY2tTZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW1bZGlyXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnNpemNhY2hlID09PSBkb25lTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gY2hlY2tTZXRbZWxlbS5zaXpzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNYTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zaXpjYWNoZSA9IGRvbmVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNpenNldCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFNpenpsZS5maWx0ZXIoY3VyLCBbZWxlbV0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtW2Rpcl07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGVja1NldFtpXSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFNpenpsZS5jb250YWlucyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyA/IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoYS5jb250YWlucyA/IGEuY29udGFpbnMoYikgOiB0cnVlKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDE2KTtcbiAgICAgICAgfTtcblxuICAgICAgICBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgICAgICAgICAgLy8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpIFxuICAgICAgICAgICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IChlbGVtID8gZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gOiAwKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwb3NQcm9jZXNzID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdG1wU2V0ID0gW10sIGxhdGVyID0gXCJcIiwgbWF0Y2gsXG4gICAgICAgICAgICAgICAgcm9vdCA9IGNvbnRleHQubm9kZVR5cGUgPyBbY29udGV4dF0gOiBjb250ZXh0O1xuXG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBzZWxlY3RvcnMgbXVzdCBiZSBkb25lIGFmdGVyIHRoZSBmaWx0ZXJcbiAgICAgICAgICAgIC8vIEFuZCBzbyBtdXN0IDpub3QocG9zaXRpb25hbCkgc28gd2UgbW92ZSBhbGwgUFNFVURPcyB0byB0aGUgZW5kXG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gRXhwci5tYXRjaC5QU0VVRE8uZXhlYyhzZWxlY3RvcikpKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXIgKz0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKEV4cHIubWF0Y2guUFNFVURPLCBcIlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0b3IgPSBFeHByLnJlbGF0aXZlW3NlbGVjdG9yXSA/IHNlbGVjdG9yICsgXCIqXCIgOiBzZWxlY3RvcjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByb290Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIFNpenpsZShzZWxlY3Rvciwgcm9vdFtpXSwgdG1wU2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFNpenpsZS5maWx0ZXIobGF0ZXIsIHRtcFNldCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRVhQT1NFXG4gICAgICAgIGpRdWVyeS5maW5kID0gU2l6emxlO1xuICAgICAgICBqUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG4gICAgICAgIGpRdWVyeS5leHByW1wiOlwiXSA9IGpRdWVyeS5leHByLmZpbHRlcnM7XG4gICAgICAgIGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbiAgICAgICAgalF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbiAgICAgICAgalF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xuICAgICAgICBqUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuICAgIH0pKCk7XG5cblxuICAgIHZhciBydW50aWwgPSAvVW50aWwkLyxcbiAgICAgICAgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXZVbnRpbHxwcmV2QWxsKS8sXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgUmVnRXhwIHNob3VsZCBiZSBpbXByb3ZlZCwgb3IgbGlrZWx5IHB1bGxlZCBmcm9tIFNpenpsZVxuICAgICAgICBybXVsdGlzZWxlY3RvciA9IC8sLyxcbiAgICAgICAgaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC8sXG4gICAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgICAgICBQT1MgPSBqUXVlcnkuZXhwci5tYXRjaC5QT1M7XG5cbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICAgICAgZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5wdXNoU3RhY2soXCJcIiwgXCJmaW5kXCIsIHNlbGVjdG9yKSwgbGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJldC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQoc2VsZWN0b3IsIHRoaXNbaV0sIHJldCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHJlc3VsdHMgYXJlIHVuaXF1ZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gbGVuZ3RoOyBuIDwgcmV0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldFtyXSA9PT0gcmV0W25dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5zcGxpY2Uobi0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhczogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBqUXVlcnkodGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmNvbnRhaW5zKHRoaXMsIHRhcmdldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5vdDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sod2lubm93KHRoaXMsIHNlbGVjdG9yLCBmYWxzZSksIFwibm90XCIsIHNlbGVjdG9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciwgdHJ1ZSksIFwiZmlsdGVyXCIsIHNlbGVjdG9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpczogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gISFzZWxlY3RvciAmJiBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCB0aGlzKS5sZW5ndGggPiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIChzZWxlY3RvcnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXSwgaSwgbCwgY3VyID0gdGhpc1swXTtcblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KHNlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2gsIG1hdGNoZXMgPSB7fSwgc2VsZWN0b3IsIGxldmVsID0gMTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXIgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gc2VsZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlc1tzZWxlY3Rvcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW3NlbGVjdG9yXSA9IGpRdWVyeS5leHByLm1hdGNoLlBPUy50ZXN0KHNlbGVjdG9yKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeShzZWxlY3RvciwgY29udGV4dCB8fCB0aGlzLmNvbnRleHQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyICYmIGN1ci5vd25lckRvY3VtZW50ICYmIGN1ciAhPT0gY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzZWxlY3RvciBpbiBtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzW3NlbGVjdG9yXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5qcXVlcnkgPyBtYXRjaC5pbmRleChjdXIpID4gLTEgOiBqUXVlcnkoY3VyKS5pcyhtYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goeyBzZWxlY3Rvcjogc2VsZWN0b3IsIGVsZW06IGN1ciwgbGV2ZWw6IGxldmVsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBvcyA9IFBPUy50ZXN0KHNlbGVjdG9ycykgP1xuICAgICAgICAgICAgICAgIGpRdWVyeShzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0KSA6IG51bGw7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1ciA9IHRoaXNbaV07XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPyBwb3MuaW5kZXgoY3VyKSA+IC0xIDogalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VyIHx8ICFjdXIub3duZXJEb2N1bWVudCB8fCBjdXIgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0gcmV0Lmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKHJldCkgOiByZXQ7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhyZXQsIFwiY2xvc2VzdFwiLCBzZWxlY3RvcnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW5cbiAgICAgICAgLy8gdGhlIG1hdGNoZWQgc2V0IG9mIGVsZW1lbnRzXG4gICAgICAgIGluZGV4OiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgaWYgKCFlbGVtIHx8IHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5pbkFycmF5KHRoaXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IHJlY2VpdmVzIGEgc3RyaW5nLCB0aGUgc2VsZWN0b3IgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBub3RoaW5nLCB0aGUgc2libGluZ3MgYXJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA/IGpRdWVyeShlbGVtKSA6IHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuaW5BcnJheShcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcbiAgICAgICAgICAgICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHNldCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiA/XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCkgOlxuICAgICAgICAgICAgICAgIGpRdWVyeS5tYWtlQXJyYXkoc2VsZWN0b3IpLFxuICAgICAgICAgICAgICAgIGFsbCA9IGpRdWVyeS5tZXJnZSh0aGlzLmdldCgpLCBzZXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soaXNEaXNjb25uZWN0ZWQoc2V0WzBdKSB8fCBpc0Rpc2Nvbm5lY3RlZChhbGxbMF0pID9cbiAgICAgICAgICAgICAgICBhbGwgOlxuICAgICAgICAgICAgICAgIGpRdWVyeS51bmlxdWUoYWxsKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW5kU2VsZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHRoaXMucHJldk9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEEgcGFpbmZ1bGx5IHNpbXBsZSBjaGVjayB0byBzZWUgaWYgYW4gZWxlbWVudCBpcyBkaXNjb25uZWN0ZWRcbiAgICAvLyBmcm9tIGEgZG9jdW1lbnQgKHNob3VsZCBiZSBpbXByb3ZlZCwgd2hlcmUgZmVhc2libGUpLlxuICAgIGZ1bmN0aW9uIGlzRGlzY29ubmVjdGVkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlIHx8ICFub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMTtcbiAgICB9XG5cbiAgICBqUXVlcnkuZWFjaCh7XG4gICAgICAgIHBhcmVudDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uIChlbGVtLCBpLCB1bnRpbCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubnRoKGVsZW0sIDIsIFwibmV4dFNpYmxpbmdcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXY6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm50aChlbGVtLCAyLCBcInByZXZpb3VzU2libGluZ1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dEFsbDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZBbGw6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcInByZXZpb3VzU2libGluZ1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dFVudGlsOiBmdW5jdGlvbiAoZWxlbSwgaSwgdW50aWwpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwpO1xuICAgICAgICB9LFxuICAgICAgICBwcmV2VW50aWw6IGZ1bmN0aW9uIChlbGVtLCBpLCB1bnRpbCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwpO1xuICAgICAgICB9LFxuICAgICAgICBzaWJsaW5nczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuc2libGluZyhlbGVtLnBhcmVudE5vZGUuZmlyc3RDaGlsZCwgZWxlbSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5zaWJsaW5nKGVsZW0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcImlmcmFtZVwiKSA/XG4gICAgICAgICAgICAgICAgZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgZWxlbS5jb250ZW50V2luZG93LmRvY3VtZW50IDpcbiAgICAgICAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KGVsZW0uY2hpbGROb2Rlcyk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHVudGlsLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIHJldCA9IGpRdWVyeS5tYXAodGhpcywgZm4sIHVudGlsKTtcblxuICAgICAgICAgICAgaWYgKCFydW50aWwudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW50aWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCByZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSB0aGlzLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKHJldCkgOiByZXQ7XG5cbiAgICAgICAgICAgIGlmICgodGhpcy5sZW5ndGggPiAxIHx8IHJtdWx0aXNlbGVjdG9yLnRlc3Qoc2VsZWN0b3IpKSAmJiBycGFyZW50c3ByZXYudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHJldC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhyZXQsIG5hbWUsIHNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiLFwiKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZXhwciwgZWxlbXMsIG5vdCkge1xuICAgICAgICAgICAgaWYgKG5vdCkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihlbGVtc1swXSwgZXhwcikgPyBbZWxlbXNbMF1dIDogW10gOlxuICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXMoZXhwciwgZWxlbXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpcjogZnVuY3Rpb24gKGVsZW0sIGRpciwgdW50aWwpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gW10sIGN1ciA9IGVsZW1bZGlyXTtcbiAgICAgICAgICAgIHdoaWxlIChjdXIgJiYgY3VyLm5vZGVUeXBlICE9PSA5ICYmICh1bnRpbCA9PT0gdW5kZWZpbmVkIHx8IGN1ci5ub2RlVHlwZSAhPT0gMSB8fCAhalF1ZXJ5KGN1cikuaXModW50aWwpKSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKGN1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ciA9IGN1cltkaXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbnRoOiBmdW5jdGlvbiAoY3VyLCByZXN1bHQsIGRpciwgZWxlbSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IDE7XG4gICAgICAgICAgICB2YXIgbnVtID0gMDtcblxuICAgICAgICAgICAgZm9yICg7IGN1cjsgY3VyID0gY3VyW2Rpcl0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09PSAxICYmICsrbnVtID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpYmxpbmc6IGZ1bmN0aW9uIChuLCBlbGVtKSB7XG4gICAgICAgICAgICB2YXIgciA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuICAgIGZ1bmN0aW9uIHdpbm5vdyhlbGVtZW50cywgcXVhbGlmaWVyLCBrZWVwKSB7XG4gICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihxdWFsaWZpZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9ICEhcXVhbGlmaWVyLmNhbGwoZWxlbSwgaSwgZWxlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldFZhbCA9PT0ga2VlcDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocXVhbGlmaWVyLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtID09PSBxdWFsaWZpZXIpID09PSBrZWVwO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNTaW1wbGUudGVzdChxdWFsaWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5maWx0ZXIocXVhbGlmaWVyLCBmaWx0ZXJlZCwgIWtlZXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZmlsdGVyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIChqUXVlcnkuaW5BcnJheShlbGVtLCBxdWFsaWZpZXIpID49IDApID09PSBrZWVwO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuXG5cbiAgICB2YXIgcmlubGluZWpRdWVyeSA9IC8galF1ZXJ5XFxkKz1cIig/OlxcZCt8bnVsbClcIi9nLFxuICAgICAgICBybGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvLFxuICAgICAgICByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vaWcsXG4gICAgICAgIHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxuICAgICAgICBydGJvZHkgPSAvPHRib2R5L2ksXG4gICAgICAgIHJodG1sID0gLzx8JiM/XFx3KzsvLFxuICAgICAgICBybm9jYWNoZSA9IC88KD86c2NyaXB0fG9iamVjdHxlbWJlZHxvcHRpb258c3R5bGUpL2ksXG4gICAgICAgIHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSwgIC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZCAoaHRtbDUpXG4gICAgICAgIHJhY3Rpb24gPSAvXFw9KFtePVwiJz5cXHNdK1xcLyk+L2csXG4gICAgICAgIHdyYXBNYXAgPSB7XG4gICAgICAgICAgICBvcHRpb246IFsxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIl0sXG4gICAgICAgICAgICBsZWdlbmQ6IFsxLCBcIjxmaWVsZHNldD5cIiwgXCI8L2ZpZWxkc2V0PlwiXSxcbiAgICAgICAgICAgIHRoZWFkOiBbMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIl0sXG4gICAgICAgICAgICB0cjogWzIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCJdLFxuICAgICAgICAgICAgdGQ6IFszLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxcbiAgICAgICAgICAgIGNvbDogWzIsIFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLFxuICAgICAgICAgICAgYXJlYTogWzEsIFwiPG1hcD5cIiwgXCI8L21hcD5cIl0sXG4gICAgICAgICAgICBfZGVmYXVsdDogWzAsIFwiXCIsIFwiXCJdXG4gICAgICAgIH07XG5cbiAgICB3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG4gICAgd3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbiAgICB3cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuICAgIC8vIElFIGNhbid0IHNlcmlhbGl6ZSA8bGluaz4gYW5kIDxzY3JpcHQ+IHRhZ3Mgbm9ybWFsbHlcbiAgICBpZiAoIWpRdWVyeS5zdXBwb3J0Lmh0bWxTZXJpYWxpemUpIHtcbiAgICAgICAgd3JhcE1hcC5fZGVmYXVsdCA9IFsxLCBcImRpdjxkaXY+XCIsIFwiPC9kaXY+XCJdO1xuICAgIH1cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICB0ZXh0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50ZXh0KHRleHQuY2FsbCh0aGlzLCBpLCBzZWxmLnRleHQoKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09IFwib2JqZWN0XCIgJiYgdGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHkoKS5hcHBlbmQoKHRoaXNbMF0gJiYgdGhpc1swXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkudGV4dCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cmFwQWxsOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGh0bWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykud3JhcEFsbChodG1sLmNhbGwodGhpcywgaSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpc1swXSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG4gICAgICAgICAgICAgICAgdmFyIHdyYXAgPSBqUXVlcnkoaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSh0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzWzBdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcC5pbnNlcnRCZWZvcmUodGhpc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd3JhcC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsZW0uZmlyc3RDaGlsZCAmJiBlbGVtLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgICAgICAgICB9KS5hcHBlbmQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdyYXBJbm5lcjogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihodG1sKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBJbm5lcihodG1sLmNhbGwodGhpcywgaSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSwgY29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLndyYXBBbGwoaHRtbCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFwcGVuZChodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB3cmFwOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBBbGwoaHRtbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bndyYXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5Lm5vZGVOYW1lKHRoaXMsIFwiYm9keVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5lbmQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgdHJ1ZSwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgdHJ1ZSwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJlZm9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmYWxzZSwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXQgPSBqUXVlcnkoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICBzZXQucHVzaC5hcHBseShzZXQsIHRoaXMudG9BcnJheSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soc2V0LCBcImJlZm9yZVwiLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZhbHNlLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IHRoaXMucHVzaFN0YWNrKHRoaXMsIFwiYWZ0ZXJcIiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBzZXQucHVzaC5hcHBseShzZXQsIGpRdWVyeShhcmd1bWVudHNbMF0pLnRvQXJyYXkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBrZWVwRGF0YSBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHktLWRvIG5vdCBkb2N1bWVudFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChzZWxlY3Rvciwga2VlcERhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgalF1ZXJ5LmZpbHRlcihzZWxlY3RvciwgW2VsZW1dKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZWVwRGF0YSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoW2VsZW1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsZW0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUNoaWxkKGVsZW0uZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgICAgICAgICAgLy8gRG8gdGhlIGNsb25lXG4gICAgICAgICAgICB2YXIgcmV0ID0gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LnN1cHBvcnQubm9DbG9uZUV2ZW50ICYmICFqUXVlcnkuaXNYTUxEb2ModGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgY29waWVzIGV2ZW50cyBib3VuZCB2aWEgYXR0YWNoRXZlbnQgd2hlblxuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBjbG9uZU5vZGUuIENhbGxpbmcgZGV0YWNoRXZlbnQgb24gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb25lIHdpbGwgYWxzbyByZW1vdmUgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnbmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGdldCBhcm91bmQgdGhpcywgd2UgdXNlIGlubmVySFRNTC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhpcyBtZWFucyBzb21lIG1vZGlmaWNhdGlvbnMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBJRSB0aGF0IGFyZSBhY3R1YWxseSBvbmx5IHN0b3JlZFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBwcm9wZXJ0aWVzIHdpbGwgbm90IGJlIGNvcGllZCAoc3VjaCBhcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5hbWUgYXR0cmlidXRlIG9uIGFuIGlucHV0KS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSB0aGlzLm91dGVySFRNTCwgb3duZXJEb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFodG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRoaXMuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSBkaXYuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5jbGVhbihbaHRtbC5yZXBsYWNlKHJpbmxpbmVqUXVlcnksIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2UgaW4gSUUgOCB3aGVyZSBhY3Rpb249L3Rlc3QvPiBzZWxmLWNsb3NlcyBhIHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocmFjdGlvbiwgJz1cIiQxXCI+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJsZWFkaW5nV2hpdGVzcGFjZSwgXCJcIildLCBvd25lckRvY3VtZW50KVswXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcbiAgICAgICAgICAgIGlmIChldmVudHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudCh0aGlzLCByZXQpO1xuICAgICAgICAgICAgICAgIGNsb25lQ29weUV2ZW50KHRoaXMuZmluZChcIipcIiksIHJldC5maW5kKFwiKlwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcblxuICAgICAgICBodG1sOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgdGhpc1swXS5ub2RlVHlwZSA9PT0gMSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbMF0uaW5uZXJIVE1MLnJlcGxhY2UocmlubGluZWpRdWVyeSwgXCJcIikgOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub2NhY2hlLnRlc3QodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgKGpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlIHx8ICFybGVhZGluZ1doaXRlc3BhY2UudGVzdCh2YWx1ZSkpICYmXG4gICAgICAgICAgICAgICAgIXdyYXBNYXBbKHJ0YWdOYW1lLmV4ZWModmFsdWUpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEodGhpc1tpXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbaV0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2RcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5hcHBlbmQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBqUXVlcnkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaHRtbCh2YWx1ZS5jYWxsKHRoaXMsIGksIHNlbGYuaHRtbCgpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbXB0eSgpLmFwcGVuZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBlbGVtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBET00gYmVmb3JlIHRoZXkgYXJlIGluc2VydGVkXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gaGVscCBmaXggcmVwbGFjaW5nIGEgcGFyZW50IHdpdGggY2hpbGQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLCBvbGQgPSBzZWxmLmh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVwbGFjZVdpdGgodmFsdWUuY2FsbCh0aGlzLCBpLCBvbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeSh2YWx1ZSkuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0U2libGluZywgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KG5leHQpLmJlZm9yZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkocGFyZW50KS5hcHBlbmQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUoKSA6IHZhbHVlKSwgXCJyZXBsYWNlV2l0aFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9tTWFuaXA6IGZ1bmN0aW9uIChhcmdzLCB0YWJsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzLCBmaXJzdCwgdmFsdWUgPSBhcmdzWzBdLCBzY3JpcHRzID0gW10sIGZyYWdtZW50LCBwYXJlbnQ7XG5cbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuICAgICAgICAgICAgaWYgKCFqUXVlcnkuc3VwcG9ydC5jaGVja0Nsb25lICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHJjaGVja2VkLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS5kb21NYW5pcChhcmdzLCB0YWJsZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IHZhbHVlLmNhbGwodGhpcywgaSwgdGFibGUgPyBzZWxmLmh0bWwoKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tTWFuaXAoYXJncywgdGFibGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB2YWx1ZSAmJiB2YWx1ZS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gYSBmcmFnbWVudCwganVzdCB1c2UgdGhhdCBpbnN0ZWFkIG9mIGJ1aWxkaW5nIGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuc3VwcG9ydC5wYXJlbnROb2RlICYmIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDExICYmIHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHsgZnJhZ21lbnQ6IHBhcmVudCB9O1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGpRdWVyeS5idWlsZEZyYWdtZW50KGFyZ3MsIHRoaXMsIHNjcmlwdHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gcmVzdWx0cy5mcmFnbWVudDtcblxuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlID0gdGFibGUgJiYgalF1ZXJ5Lm5vZGVOYW1lKGZpcnN0LCBcInRyXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290KHRoaXNbaV0sIGZpcnN0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA+IDAgfHwgcmVzdWx0cy5jYWNoZWFibGUgfHwgdGhpcy5sZW5ndGggPiAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuY2xvbmVOb2RlKHRydWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goc2NyaXB0cywgZXZhbFNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcm9vdChlbGVtLCBjdXIpIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcInRhYmxlXCIpID9cbiAgICAgICAgICAgIChlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHxcbiAgICAgICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikpKSA6XG4gICAgICAgICAgICBlbGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KG9yaWcsIHJldCkge1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgcmV0LmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZU5hbWUgIT09IChvcmlnW2ldICYmIG9yaWdbaV0ubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IGpRdWVyeS5kYXRhKG9yaWdbaSsrXSksIGN1ckRhdGEgPSBqUXVlcnkuZGF0YSh0aGlzLCBvbGREYXRhKSwgZXZlbnRzID0gb2xkRGF0YSAmJiBvbGREYXRhLmV2ZW50cztcblxuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJEYXRhLmhhbmRsZTtcbiAgICAgICAgICAgICAgICBjdXJEYXRhLmV2ZW50cyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaGFuZGxlciBpbiBldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcywgdHlwZSwgZXZlbnRzW3R5cGVdW2hhbmRsZXJdLCBldmVudHNbdHlwZV1baGFuZGxlcl0uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGpRdWVyeS5idWlsZEZyYWdtZW50ID0gZnVuY3Rpb24gKGFyZ3MsIG5vZGVzLCBzY3JpcHRzKSB7XG4gICAgICAgIHZhciBmcmFnbWVudCwgY2FjaGVhYmxlLCBjYWNoZXJlc3VsdHMsXG4gICAgICAgICAgICBkb2MgPSAobm9kZXMgJiYgbm9kZXNbMF0gPyBub2Rlc1swXS5vd25lckRvY3VtZW50IHx8IG5vZGVzWzBdIDogZG9jdW1lbnQpO1xuXG4gICAgICAgIC8vIE9ubHkgY2FjaGUgXCJzbWFsbFwiICgxLzIgS0IpIHN0cmluZ3MgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYWluIGRvY3VtZW50XG4gICAgICAgIC8vIENsb25pbmcgb3B0aW9ucyBsb3NlcyB0aGUgc2VsZWN0ZWQgc3RhdGUsIHNvIGRvbid0IGNhY2hlIHRoZW1cbiAgICAgICAgLy8gSUUgNiBkb2Vzbid0IGxpa2UgaXQgd2hlbiB5b3UgcHV0IDxvYmplY3Q+IG9yIDxlbWJlZD4gZWxlbWVudHMgaW4gYSBmcmFnbWVudFxuICAgICAgICAvLyBBbHNvLCBXZWJLaXQgZG9lcyBub3QgY2xvbmUgJ2NoZWNrZWQnIGF0dHJpYnV0ZXMgb24gY2xvbmVOb2RlLCBzbyBkb24ndCBjYWNoZVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIgJiYgYXJnc1swXS5sZW5ndGggPCA1MTIgJiYgZG9jID09PSBkb2N1bWVudCAmJlxuICAgICAgICAgICAgIXJub2NhY2hlLnRlc3QoYXJnc1swXSkgJiYgKGpRdWVyeS5zdXBwb3J0LmNoZWNrQ2xvbmUgfHwgIXJjaGVja2VkLnRlc3QoYXJnc1swXSkpKSB7XG5cbiAgICAgICAgICAgIGNhY2hlYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBjYWNoZXJlc3VsdHMgPSBqUXVlcnkuZnJhZ21lbnRzW2FyZ3NbMF1dO1xuICAgICAgICAgICAgaWYgKGNhY2hlcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZXJlc3VsdHMgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBjYWNoZXJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgalF1ZXJ5LmNsZWFuKGFyZ3MsIGRvYywgZnJhZ21lbnQsIHNjcmlwdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlYWJsZSkge1xuICAgICAgICAgICAgalF1ZXJ5LmZyYWdtZW50c1thcmdzWzBdXSA9IGNhY2hlcmVzdWx0cyA/IGZyYWdtZW50IDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGZyYWdtZW50OiBmcmFnbWVudCwgY2FjaGVhYmxlOiBjYWNoZWFibGUgfTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmZyYWdtZW50cyA9IHt9O1xuXG4gICAgalF1ZXJ5LmVhY2goe1xuICAgICAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcbiAgICAgICAgcHJlcGVuZFRvOiBcInByZXBlbmRcIixcbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuICAgICAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuICAgICAgICByZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbiAgICB9LCBmdW5jdGlvbiAobmFtZSwgb3JpZ2luYWwpIHtcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gW10sIGluc2VydCA9IGpRdWVyeShzZWxlY3RvciksXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpc1swXS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMTEgJiYgcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmIGluc2VydC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRbb3JpZ2luYWxdKHRoaXNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5zZXJ0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbXMgPSAoaSA+IDAgPyB0aGlzLmNsb25lKHRydWUpIDogdGhpcykuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeShpbnNlcnRbaV0pW29yaWdpbmFsXShlbGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZWxlbXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhyZXQsIG5hbWUsIGluc2VydC5zZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgY2xlYW46IGZ1bmN0aW9uIChlbGVtcywgY29udGV4dCwgZnJhZ21lbnQsIHNjcmlwdHMpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgICAvLyAhY29udGV4dC5jcmVhdGVFbGVtZW50IGZhaWxzIGluIElFIHdpdGggYW4gZXJyb3IgYnV0IHJldHVybnMgdHlwZW9mICdvYmplY3QnXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuY3JlYXRlRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dFswXSAmJiBjb250ZXh0WzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtICs9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgaHRtbCBzdHJpbmcgaW50byBET00gbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgJiYgIXJodG1sLnRlc3QoZWxlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoZWxlbSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBcIlhIVE1MXCItc3R5bGUgdGFncyBpbiBhbGwgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW0ucmVwbGFjZShyeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaW0gd2hpdGVzcGFjZSwgb3RoZXJ3aXNlIGluZGV4T2Ygd29uJ3Qgd29yayBhcyBleHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gKHJ0YWdOYW1lLmV4ZWMoZWxlbSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcCA9IHdyYXBNYXBbdGFnXSB8fCB3cmFwTWFwLl9kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSB3cmFwWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdvIHRvIGh0bWwgYW5kIGJhY2ssIHRoZW4gcGVlbCBvZmYgZXh0cmEgd3JhcHBlcnNcbiAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHdyYXBbMV0gKyBlbGVtICsgd3JhcFsyXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSByaWdodCBkZXB0aFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGVwdGgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2ID0gZGl2Lmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJRSdzIGF1dG9pbnNlcnRlZCA8dGJvZHk+IGZyb20gdGFibGUgZnJhZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LnN1cHBvcnQudGJvZHkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIHdhcyBhIDx0YWJsZT4sICptYXkqIGhhdmUgc3B1cmlvdXMgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0JvZHkgPSBydGJvZHkudGVzdChlbGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Ym9keSA9IHRhZyA9PT0gXCJ0YWJsZVwiICYmICFoYXNCb2R5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmZpcnN0Q2hpbGQgJiYgZGl2LmZpcnN0Q2hpbGQuY2hpbGROb2RlcyA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIHdhcyBhIGJhcmUgPHRoZWFkPiBvciA8dGZvb3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBbMV0gPT09IFwiPHRhYmxlPlwiICYmICFoYXNCb2R5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5jaGlsZE5vZGVzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gdGJvZHkubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Lm5vZGVOYW1lKHRib2R5W2pdLCBcInRib2R5XCIpICYmICF0Ym9keVtqXS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Ym9keVtqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRib2R5W2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElFIGNvbXBsZXRlbHkga2lsbHMgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZW4gaW5uZXJIVE1MIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkuc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSAmJiBybGVhZGluZ1doaXRlc3BhY2UudGVzdChlbGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2Lmluc2VydEJlZm9yZShjb250ZXh0LmNyZWF0ZVRleHROb2RlKHJsZWFkaW5nV2hpdGVzcGFjZS5leGVjKGVsZW0pWzBdKSwgZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGRpdi5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGpRdWVyeS5tZXJnZShyZXQsIGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgcmV0W2ldOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcmlwdHMgJiYgalF1ZXJ5Lm5vZGVOYW1lKHJldFtpXSwgXCJzY3JpcHRcIikgJiYgKCFyZXRbaV0udHlwZSB8fCByZXRbaV0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInRleHQvamF2YXNjcmlwdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0cy5wdXNoKHJldFtpXS5wYXJlbnROb2RlID8gcmV0W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmV0W2ldKSA6IHJldFtpXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRbaV0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuc3BsaWNlLmFwcGx5KHJldCwgW2kgKyAxLCAwXS5jb25jYXQoalF1ZXJ5Lm1ha2VBcnJheShyZXRbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIikpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChyZXRbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFuRGF0YTogZnVuY3Rpb24gKGVsZW1zKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSwgaWQsIGNhY2hlID0galF1ZXJ5LmNhY2hlLFxuICAgICAgICAgICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcbiAgICAgICAgICAgICAgICBkZWxldGVFeHBhbmRvID0galF1ZXJ5LnN1cHBvcnQuZGVsZXRlRXhwYW5kbztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVOYW1lICYmIGpRdWVyeS5ub0RhdGFbZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZCA9IGVsZW1balF1ZXJ5LmV4cGFuZG9dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBjYWNoZVtpZF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gZGF0YS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbFt0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKGVsZW0sIHR5cGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlRXhwYW5kbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1balF1ZXJ5LmV4cGFuZG9dO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbS5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGpRdWVyeS5leHBhbmRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBldmFsU2NyaXB0KGksIGVsZW0pIHtcbiAgICAgICAgaWYgKGVsZW0uc3JjKSB7XG4gICAgICAgICAgICBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiBlbGVtLnNyYyxcbiAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwic2NyaXB0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgalF1ZXJ5Lmdsb2JhbEV2YWwoZWxlbS50ZXh0IHx8IGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lckhUTUwgfHwgXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG5cbiAgICB2YXIgcmFscGhhID0gL2FscGhhXFwoW14pXSpcXCkvaSxcbiAgICAgICAgcm9wYWNpdHkgPSAvb3BhY2l0eT0oW14pXSopLyxcbiAgICAgICAgcmRhc2hBbHBoYSA9IC8tKFthLXpdKS9pZyxcbiAgICAgICAgcnVwcGVyID0gLyhbQS1aXSkvZyxcbiAgICAgICAgcm51bXB4ID0gL14tP1xcZCsoPzpweCk/JC9pLFxuICAgICAgICBybnVtID0gL14tP1xcZC8sXG5cbiAgICAgICAgY3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG4gICAgICAgIGNzc1dpZHRoID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdLFxuICAgICAgICBjc3NIZWlnaHQgPSBbXCJUb3BcIiwgXCJCb3R0b21cIl0sXG4gICAgICAgIGN1ckNTUyxcblxuICAgICAgICAvLyBjYWNoZSBjaGVjayBmb3IgZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSxcblxuICAgICAgICBmY2FtZWxDYXNlID0gZnVuY3Rpb24gKGFsbCwgbGV0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH07XG5cbiAgICBqUXVlcnkuZm4uY3NzID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIFNldHRpbmcgJ3VuZGVmaW5lZCcgaXMgYSBuby1vcFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqUXVlcnkuYWNjZXNzKHRoaXMsIG5hbWUsIHZhbHVlLCB0cnVlLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSwgdmFsdWUpIDpcbiAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcbiAgICAgICAgY3NzSG9va3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChlbGVtLCBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKGVsZW0sIFwib3BhY2l0eVwiLCBcIm9wYWNpdHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXhjbHVkZSB0aGUgZm9sbG93aW5nIGNzcyBwcm9wZXJ0aWVzIHRvIGFkZCBweFxuICAgICAgICBjc3NOdW1iZXI6IHtcbiAgICAgICAgICAgIFwiekluZGV4XCI6IHRydWUsXG4gICAgICAgICAgICBcImZvbnRXZWlnaHRcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJ6b29tXCI6IHRydWUsXG4gICAgICAgICAgICBcImxpbmVIZWlnaHRcIjogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcbiAgICAgICAgLy8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuICAgICAgICBjc3NQcm9wczoge1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGZsb2F0IGNzcyBwcm9wZXJ0eVxuICAgICAgICAgICAgXCJmbG9hdFwiOiBqUXVlcnkuc3VwcG9ydC5jc3NGbG9hdCA/IFwiY3NzRmxvYXRcIiA6IFwic3R5bGVGbG9hdFwiXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcbiAgICAgICAgc3R5bGU6IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG4gICAgICAgICAgICB2YXIgcmV0LCBvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UobmFtZSksXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlLCBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07XG5cbiAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbb3JpZ05hbWVdIHx8IG9yaWdOYW1lO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgTmFOIGFuZCBudWxsIHZhbHVlcyBhcmVuJ3Qgc2V0LiBTZWU6ICM3MTE2XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAhalF1ZXJ5LmNzc051bWJlcltvcmlnTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gXCJweFwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICghaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyYXBwZWQgdG8gcHJldmVudCBJRSBmcm9tIHRocm93aW5nIGVycm9ycyB3aGVuICdpbnZhbGlkJyB2YWx1ZXMgYXJlIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVzIGJ1ZyAjNTUwOVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICAgICAgICAgIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgZmFsc2UsIGV4dHJhKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNzczogZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGV4dHJhKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcbiAgICAgICAgICAgIHZhciByZXQsIG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShuYW1lKSxcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07XG5cbiAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbb3JpZ05hbWVdIHx8IG9yaWdOYW1lO1xuXG4gICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCB0cnVlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyQ1NTKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1ckNTUyhlbGVtLCBuYW1lLCBvcmlnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQSBtZXRob2QgZm9yIHF1aWNrbHkgc3dhcHBpbmcgaW4vb3V0IENTUyBwcm9wZXJ0aWVzIHRvIGdldCBjb3JyZWN0IGNhbGN1bGF0aW9uc1xuICAgICAgICBzd2FwOiBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBvbGQgPSB7fTtcblxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvbGRbbmFtZV0gPSBlbGVtLnN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKGVsZW0pO1xuXG4gICAgICAgICAgICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9sZFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYW1lbENhc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZGFzaEFscGhhLCBmY2FtZWxDYXNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gREVQUkVDQVRFRCwgVXNlIGpRdWVyeS5jc3MoKSBpbnN0ZWFkXG4gICAgalF1ZXJ5LmN1ckNTUyA9IGpRdWVyeS5jc3M7XG5cbiAgICBqUXVlcnkuZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzW25hbWVdID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQsIGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5vZmZzZXRXaWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZ2V0V0goZWxlbSwgbmFtZSwgZXh0cmEpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3dhcChlbGVtLCBjc3NTaG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZ2V0V0goZWxlbSwgbmFtZSwgZXh0cmEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJudW1weC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgbmVnYXRpdmUgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgIzE1OTlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgaWYgKCFqUXVlcnkuc3VwcG9ydC5vcGFjaXR5KSB7XG4gICAgICAgIGpRdWVyeS5jc3NIb29rcy5vcGFjaXR5ID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSB1c2VzIGZpbHRlcnMgZm9yIG9wYWNpdHlcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9wYWNpdHkudGVzdCgoY29tcHV0ZWQgJiYgZWxlbS5jdXJyZW50U3R5bGUgPyBlbGVtLmN1cnJlbnRTdHlsZS5maWx0ZXIgOiBlbGVtLnN0eWxlLmZpbHRlcikgfHwgXCJcIikgP1xuICAgICAgICAgICAgICAgICAgICAocGFyc2VGbG9hdChSZWdFeHAuJDEpIC8gMTAwKSArIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCA/IFwiMVwiIDogXCJcIjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICAgICAgICAgIC8vIElFIGhhcyB0cm91YmxlIHdpdGggb3BhY2l0eSBpZiBpdCBkb2VzIG5vdCBoYXZlIGxheW91dFxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGl0IGJ5IHNldHRpbmcgdGhlIHpvb20gbGV2ZWxcbiAgICAgICAgICAgICAgICBzdHlsZS56b29tID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgYWxwaGEgZmlsdGVyIHRvIHNldCB0aGUgb3BhY2l0eVxuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0galF1ZXJ5LmlzTmFOKHZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgIFwiXCIgOlxuICAgICAgICAgICAgICAgICAgICBcImFscGhhKG9wYWNpdHk9XCIgKyB2YWx1ZSAqIDEwMCArIFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBzdHlsZS5maWx0ZXIgfHwgXCJcIjtcblxuICAgICAgICAgICAgICAgIHN0eWxlLmZpbHRlciA9IHJhbHBoYS50ZXN0KGZpbHRlcikgP1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIucmVwbGFjZShyYWxwaGEsIG9wYWNpdHkpIDpcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZmlsdGVyICsgJyAnICsgb3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICBjdXJDU1MgPSBmdW5jdGlvbiAoZWxlbSwgbmV3TmFtZSwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHJldCwgZGVmYXVsdFZpZXcsIGNvbXB1dGVkU3R5bGU7XG5cbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UocnVwcGVyLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoIShkZWZhdWx0VmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGNvbXB1dGVkU3R5bGUgPSBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZWxlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSkge1xuICAgICAgICBjdXJDU1MgPSBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIGxlZnQsIHJzTGVmdCwgcmV0ID0gZWxlbS5jdXJyZW50U3R5bGUgJiYgZWxlbS5jdXJyZW50U3R5bGVbbmFtZV0sIHN0eWxlID0gZWxlbS5zdHlsZTtcblxuICAgICAgICAgICAgLy8gRnJvbSB0aGUgYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1xuICAgICAgICAgICAgLy8gaHR0cDovL2VyaWsuZWFlLm5ldC9hcmNoaXZlcy8yMDA3LzA3LzI3LzE4LjU0LjE1LyNjb21tZW50LTEwMjI5MVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgcmVndWxhciBwaXhlbCBudW1iZXJcbiAgICAgICAgICAgIC8vIGJ1dCBhIG51bWJlciB0aGF0IGhhcyBhIHdlaXJkIGVuZGluZywgd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHBpeGVsc1xuICAgICAgICAgICAgaWYgKCFybnVtcHgudGVzdChyZXQpICYmIHJudW0udGVzdChyZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzdHlsZS5sZWZ0O1xuICAgICAgICAgICAgICAgIHJzTGVmdCA9IGVsZW0ucnVudGltZVN0eWxlLmxlZnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG4gICAgICAgICAgICAgICAgZWxlbS5ydW50aW1lU3R5bGUubGVmdCA9IGVsZW0uY3VycmVudFN0eWxlLmxlZnQ7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiAocmV0IHx8IDApO1xuICAgICAgICAgICAgICAgIHJldCA9IHN0eWxlLnBpeGVsTGVmdCArIFwicHhcIjtcblxuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICBlbGVtLnJ1bnRpbWVTdHlsZS5sZWZ0ID0gcnNMZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdIKGVsZW0sIG5hbWUsIGV4dHJhKSB7XG4gICAgICAgIHZhciB3aGljaCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGNzc1dpZHRoIDogY3NzSGVpZ2h0LFxuICAgICAgICAgICAgdmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIGlmIChleHRyYSA9PT0gXCJib3JkZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGpRdWVyeS5lYWNoKHdoaWNoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWV4dHJhKSB7XG4gICAgICAgICAgICAgICAgdmFsIC09IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhlbGVtLCBcInBhZGRpbmdcIiArIHRoaXMpKSB8fCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0cmEgPT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgICAgICAgICB2YWwgKz0gcGFyc2VGbG9hdChqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luXCIgKyB0aGlzKSkgfHwgMDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWwgLT0gcGFyc2VGbG9hdChqUXVlcnkuY3NzKGVsZW0sIFwiYm9yZGVyXCIgKyB0aGlzICsgXCJXaWR0aFwiKSkgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBpZiAoalF1ZXJ5LmV4cHIgJiYgalF1ZXJ5LmV4cHIuZmlsdGVycykge1xuICAgICAgICBqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbGVtLm9mZnNldFdpZHRoLCBoZWlnaHQgPSBlbGVtLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgcmV0dXJuICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHx8ICghalF1ZXJ5LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzICYmIChlbGVtLnN0eWxlLmRpc3BsYXkgfHwgalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikpID09PSBcIm5vbmVcIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oZWxlbSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cblxuXG4gICAgdmFyIGpzYyA9IGpRdWVyeS5ub3coKSxcbiAgICAgICAgcnNjcmlwdCA9IC88c2NyaXB0XFxiW148XSooPzooPyE8XFwvc2NyaXB0Pik8W148XSopKjxcXC9zY3JpcHQ+L2dpLFxuICAgICAgICByc2VsZWN0VGV4dGFyZWEgPSAvXig/OnNlbGVjdHx0ZXh0YXJlYSkvaSxcbiAgICAgICAgcmlucHV0ID0gL14oPzpjb2xvcnxkYXRlfGRhdGV0aW1lfGVtYWlsfGhpZGRlbnxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFuZ2V8c2VhcmNofHRlbHx0ZXh0fHRpbWV8dXJsfHdlZWspJC9pLFxuICAgICAgICBybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRHxERUxFVEUpJC8sXG4gICAgICAgIHJicmFja2V0ID0gL1xcW1xcXSQvLFxuICAgICAgICBqc3JlID0gL1xcPVxcPygmfCQpLyxcbiAgICAgICAgcnF1ZXJ5ID0gL1xcPy8sXG4gICAgICAgIHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcbiAgICAgICAgcnVybCA9IC9eKFxcdys6KT9cXC9cXC8oW15cXC8/I10rKS8sXG4gICAgICAgIHIyMCA9IC8lMjAvZyxcbiAgICAgICAgcmhhc2ggPSAvIy4qJC8sXG5cbiAgICAgICAgLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxuICAgICAgICBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9sb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhIHJlcXVlc3QgaWYgbm8gZWxlbWVudHMgYXJlIGJlaW5nIHJlcXVlc3RlZFxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZiA9IHVybC5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgICAgIGlmIChvZmYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHVybC5zbGljZShvZmYsIHVybC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5zbGljZSgwLCBvZmYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGEgR0VUIHJlcXVlc3RcbiAgICAgICAgICAgIHZhciB0eXBlID0gXCJHRVRcIjtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgd2FzIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBqUXVlcnkucGFyYW0ocGFyYW1zLCBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiUE9TVFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHRoZSByZW1vdGUgZG9jdW1lbnRcbiAgICAgICAgICAgIGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImh0bWxcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIChyZXMsIHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCBpbmplY3QgdGhlIEhUTUwgaW50byBhbGwgdGhlIG1hdGNoZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJzdWNjZXNzXCIgfHwgc3RhdHVzID09PSBcIm5vdG1vZGlmaWVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBpZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaHRtbChzZWxlY3RvciA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgZGl2IHRvIGhvbGQgdGhlIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkoXCI8ZGl2PlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmplY3QgdGhlIGNvbnRlbnRzIG9mIHRoZSBkb2N1bWVudCBpbiwgcmVtb3ZpbmcgdGhlIHNjcmlwdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgYW55ICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzIGluIElFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQocmVzLnJlc3BvbnNlVGV4dC5yZXBsYWNlKHJzY3JpcHQsIFwiXCIpKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvY2F0ZSB0aGUgc3BlY2lmaWVkIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHNlbGVjdG9yKSA6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QsIGp1c3QgaW5qZWN0IHRoZSBmdWxsIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVhY2goY2FsbGJhY2ssIFtyZXMucmVzcG9uc2VUZXh0LCBzdGF0dXMsIHJlc10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSh0aGlzLmVsZW1lbnRzKSA6IHRoaXM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICYmICF0aGlzLmRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jaGVja2VkIHx8IHJzZWxlY3RUZXh0YXJlYS50ZXN0KHRoaXMubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlucHV0LnRlc3QodGhpcy50eXBlKSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpLCBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkodGhpcykudmFsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzQXJyYXkodmFsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWwsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsIH07XG4gICAgICAgICAgICAgICAgfSkuZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG4gICAgalF1ZXJ5LmVhY2goXCJhamF4U3RhcnQgYWpheFN0b3AgYWpheENvbXBsZXRlIGFqYXhFcnJvciBhamF4U3VjY2VzcyBhamF4U2VuZFwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24gKGksIG8pIHtcbiAgICAgICAgalF1ZXJ5LmZuW29dID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmQobywgZik7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAodXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSkge1xuICAgICAgICAgICAgLy8gc2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXRlZFxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFqYXgoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5nZXQodXJsLCBudWxsLCBjYWxsYmFjaywgXCJzY3JpcHRcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SlNPTjogZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3N0OiBmdW5jdGlvbiAodXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSkge1xuICAgICAgICAgICAgLy8gc2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXRlZFxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhamF4U2V0dXA6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZChqUXVlcnkuYWpheFNldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWpheFNldHRpbmdzOiB7XG4gICAgICAgICAgICB1cmw6IGxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICBnbG9iYWw6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgICAgICAgICBwcm9jZXNzRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHRpbWVvdXQ6IDAsXG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgdXNlcm5hbWU6IG51bGwsXG4gICAgICAgICAgICBwYXNzd29yZDogbnVsbCxcbiAgICAgICAgICAgIHRyYWRpdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZW4gYnkgY2FsbGluZyBqUXVlcnkuYWpheFNldHVwXG4gICAgICAgICAgICB4aHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjY2VwdHM6IHtcbiAgICAgICAgICAgICAgICB4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuICAgICAgICAgICAgICAgIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gICAgICAgICAgICAgICAgc2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdFwiLFxuICAgICAgICAgICAgICAgIGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgICAgICAgICAgX2RlZmF1bHQ6IFwiKi8qXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhamF4OiBmdW5jdGlvbiAob3JpZ1NldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIGpRdWVyeS5hamF4U2V0dGluZ3MsIG9yaWdTZXR0aW5ncyksXG4gICAgICAgICAgICAgICAganNvbnAsIHN0YXR1cywgZGF0YSwgdHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpLCBub0NvbnRlbnQgPSBybm9Db250ZW50LnRlc3QodHlwZSk7XG5cbiAgICAgICAgICAgIHMudXJsID0gcy51cmwucmVwbGFjZShyaGFzaCwgXCJcIik7XG5cbiAgICAgICAgICAgIC8vIFVzZSBvcmlnaW5hbCAobm90IGV4dGVuZGVkKSBjb250ZXh0IG9iamVjdCBpZiBpdCB3YXMgcHJvdmlkZWRcbiAgICAgICAgICAgIHMuY29udGV4dCA9IG9yaWdTZXR0aW5ncyAmJiBvcmlnU2V0dGluZ3MuY29udGV4dCAhPSBudWxsID8gb3JpZ1NldHRpbmdzLmNvbnRleHQgOiBzO1xuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcbiAgICAgICAgICAgIGlmIChzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcy5kYXRhID0galF1ZXJ5LnBhcmFtKHMuZGF0YSwgcy50cmFkaXRpb25hbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBKU09OUCBQYXJhbWV0ZXIgQ2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAocy5kYXRhVHlwZSA9PT0gXCJqc29ucFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqc3JlLnRlc3Qocy51cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnVybCArPSAocnF1ZXJ5LnRlc3Qocy51cmwpID8gXCImXCIgOiBcIj9cIikgKyAocy5qc29ucCB8fCBcImNhbGxiYWNrXCIpICsgXCI9P1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcy5kYXRhIHx8ICFqc3JlLnRlc3Qocy5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBzLmRhdGEgPSAocy5kYXRhID8gcy5kYXRhICsgXCImXCIgOiBcIlwiKSArIChzLmpzb25wIHx8IFwiY2FsbGJhY2tcIikgKyBcIj0/XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMuZGF0YVR5cGUgPSBcImpzb25cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnVpbGQgdGVtcG9yYXJ5IEpTT05QIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAocy5kYXRhVHlwZSA9PT0gXCJqc29uXCIgJiYgKHMuZGF0YSAmJiBqc3JlLnRlc3Qocy5kYXRhKSB8fCBqc3JlLnRlc3Qocy51cmwpKSkge1xuICAgICAgICAgICAgICAgIGpzb25wID0gcy5qc29ucENhbGxiYWNrIHx8IChcImpzb25wXCIgKyBqc2MrKyk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSA9PyBzZXF1ZW5jZSBib3RoIGluIHRoZSBxdWVyeSBzdHJpbmcgYW5kIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgaWYgKHMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBzLmRhdGEgPSAocy5kYXRhICsgXCJcIikucmVwbGFjZShqc3JlLCBcIj1cIiArIGpzb25wICsgXCIkMVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzLnVybCA9IHMudXJsLnJlcGxhY2UoanNyZSwgXCI9XCIgKyBqc29ucCArIFwiJDFcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYSBKU09OUCBzdHlsZSByZXNwb25zZSBpcyBleGVjdXRlZCBwcm9wZXJseVxuICAgICAgICAgICAgICAgIHMuZGF0YVR5cGUgPSBcInNjcmlwdFwiO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIEpTT05QLXN0eWxlIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tSnNvbnAgPSB3aW5kb3dbanNvbnBdO1xuXG4gICAgICAgICAgICAgICAgd2luZG93W2pzb25wXSA9IGZ1bmN0aW9uICh0bXApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmhhbmRsZVN1Y2Nlc3MocywgeGhyLCBzdGF0dXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaGFuZGxlQ29tcGxldGUocywgeGhyLCBzdGF0dXMsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihjdXN0b21Kc29ucCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUpzb25wKHRtcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdhcmJhZ2UgY29sbGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93W2pzb25wXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2pzb25wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGpzb25wRXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzLmRhdGFUeXBlID09PSBcInNjcmlwdFwiICYmIHMuY2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzLmNhY2hlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzLmNhY2hlID09PSBmYWxzZSAmJiB0eXBlID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRzID0galF1ZXJ5Lm5vdygpO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHJlcGxhY2luZyBfPSBpZiBpdCBpcyB0aGVyZVxuICAgICAgICAgICAgICAgIHZhciByZXQgPSBzLnVybC5yZXBsYWNlKHJ0cywgXCIkMV89XCIgKyB0cyk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBub3RoaW5nIHdhcyByZXBsYWNlZCwgYWRkIHRpbWVzdGFtcCB0byB0aGUgZW5kXG4gICAgICAgICAgICAgICAgcy51cmwgPSByZXQgKyAoKHJldCA9PT0gcy51cmwpID8gKHJxdWVyeS50ZXN0KHMudXJsKSA/IFwiJlwiIDogXCI/XCIpICsgXCJfPVwiICsgdHMgOiBcIlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybCBmb3IgZ2V0IHJlcXVlc3RzXG4gICAgICAgICAgICBpZiAocy5kYXRhICYmIHR5cGUgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgICAgICBzLnVybCArPSAocnF1ZXJ5LnRlc3Qocy51cmwpID8gXCImXCIgOiBcIj9cIikgKyBzLmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcbiAgICAgICAgICAgIGlmIChzLmdsb2JhbCAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWF0Y2hlcyBhbiBhYnNvbHV0ZSBVUkwsIGFuZCBzYXZlcyB0aGUgZG9tYWluXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBydXJsLmV4ZWMocy51cmwpLFxuICAgICAgICAgICAgICAgIHJlbW90ZSA9IHBhcnRzICYmIChwYXJ0c1sxXSAmJiBwYXJ0c1sxXSAhPT0gbG9jYXRpb24ucHJvdG9jb2wgfHwgcGFydHNbMl0gIT09IGxvY2F0aW9uLmhvc3QpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSByZXF1ZXN0aW5nIGEgcmVtb3RlIGRvY3VtZW50XG4gICAgICAgICAgICAvLyBhbmQgdHJ5aW5nIHRvIGxvYWQgSlNPTiBvciBTY3JpcHQgd2l0aCBhIEdFVFxuICAgICAgICAgICAgaWYgKHMuZGF0YVR5cGUgPT09IFwic2NyaXB0XCIgJiYgdHlwZSA9PT0gXCJHRVRcIiAmJiByZW1vdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICAgICAgaWYgKHMuc2NyaXB0Q2hhcnNldCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuY2hhcnNldCA9IHMuc2NyaXB0Q2hhcnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NyaXB0LnNyYyA9IHMudXJsO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIFNjcmlwdCBsb2FkaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFqc29ucCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCBoYW5kbGVycyBmb3IgYWxsIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb25lICYmICghdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBcImxvYWRlZFwiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5oYW5kbGVTdWNjZXNzKHMsIHhociwgc3RhdHVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaGFuZGxlQ29tcGxldGUocywgeGhyLCBzdGF0dXMsIGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1lbW9yeSBsZWFrIGluIElFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkICYmIHNjcmlwdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIGFwcGVuZENoaWxkICB0byBjaXJjdW12ZW50IGFuIElFNiBidWcuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhcmlzZXMgd2hlbiBhIGJhc2Ugbm9kZSBpcyB1c2VkICgjMjcwOSBhbmQgIzQzNzgpLlxuICAgICAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGhhbmRsZSBldmVyeXRoaW5nIHVzaW5nIHRoZSBzY3JpcHQgZWxlbWVudCBpbmplY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdERvbmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdFxuICAgICAgICAgICAgdmFyIHhociA9IHMueGhyKCk7XG5cbiAgICAgICAgICAgIGlmICgheGhyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPcGVuIHRoZSBzb2NrZXRcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgbnVsbCB1c2VybmFtZSwgZ2VuZXJhdGVzIGEgbG9naW4gcG9wdXAgb24gT3BlcmEgKCMyODY1KVxuICAgICAgICAgICAgaWYgKHMudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICB4aHIub3Blbih0eXBlLCBzLnVybCwgcy5hc3luYywgcy51c2VybmFtZSwgcy5wYXNzd29yZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhoci5vcGVuKHR5cGUsIHMudXJsLCBzLmFzeW5jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmVlZCBhbiBleHRyYSB0cnkvY2F0Y2ggZm9yIGNyb3NzIGRvbWFpbiByZXF1ZXN0cyBpbiBGaXJlZm94IDNcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGNvbnRlbnQtdHlwZSBpZiBkYXRhIHNwZWNpZmllZCBhbmQgY29udGVudC1ib2R5IGlzIHZhbGlkIGZvciB0aGlzIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoKHMuZGF0YSAhPSBudWxsICYmICFub0NvbnRlbnQpIHx8IChvcmlnU2V0dGluZ3MgJiYgb3JpZ1NldHRpbmdzLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgICAgICAgIGlmIChzLmlmTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5sYXN0TW9kaWZpZWRbcy51cmxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbcy51cmxdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuZXRhZ1tzLnVybF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1tzLnVybF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGhlYWRlciBzbyB0aGUgY2FsbGVkIHNjcmlwdCBrbm93cyB0aGF0IGl0J3MgYW4gWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHNlbmQgdGhlIGhlYWRlciBpZiBpdCdzIG5vdCBhIHJlbW90ZSBYSFJcbiAgICAgICAgICAgICAgICBpZiAoIXJlbW90ZSkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgcy5kYXRhVHlwZSAmJiBzLmFjY2VwdHNbcy5kYXRhVHlwZV0gP1xuICAgICAgICAgICAgICAgICAgICBzLmFjY2VwdHNbcy5kYXRhVHlwZV0gKyBcIiwgKi8qOyBxPTAuMDFcIiA6XG4gICAgICAgICAgICAgICAgICAgIHMuYWNjZXB0cy5fZGVmYXVsdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChoZWFkZXJFcnJvcikgeyB9XG5cbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcbiAgICAgICAgICAgIGlmIChzLmJlZm9yZVNlbmQgJiYgcy5iZWZvcmVTZW5kLmNhbGwocy5jb250ZXh0LCB4aHIsIHMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuICAgICAgICAgICAgICAgIGlmIChzLmdsb2JhbCAmJiBqUXVlcnkuYWN0aXZlLS0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjbG9zZSBvcGVuZGVkIHNvY2tldFxuICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHMuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnRyaWdnZXJHbG9iYWwocywgXCJhamF4U2VuZFwiLCBbeGhyLCBzXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIGEgcmVzcG9uc2UgdG8gY29tZSBiYWNrXG4gICAgICAgICAgICB2YXIgb25yZWFkeXN0YXRlY2hhbmdlID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChpc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVxdWVzdCB3YXMgYWJvcnRlZFxuICAgICAgICAgICAgICAgIGlmICgheGhyIHx8IHhoci5yZWFkeVN0YXRlID09PSAwIHx8IGlzVGltZW91dCA9PT0gXCJhYm9ydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhIGRvZXNuJ3QgY2FsbCBvbnJlYWR5c3RhdGVjaGFuZ2UgYmVmb3JlIHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2Ugc2ltdWxhdGUgdGhlIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0RG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmhhbmRsZUNvbXBsZXRlKHMsIHhociwgc3RhdHVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3REb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGpRdWVyeS5ub29wO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRyYW5zZmVyIGlzIGNvbXBsZXRlIGFuZCB0aGUgZGF0YSBpcyBhdmFpbGFibGUsIG9yIHRoZSByZXF1ZXN0IHRpbWVkIG91dFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlcXVlc3REb25lICYmIHhociAmJiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgfHwgaXNUaW1lb3V0ID09PSBcInRpbWVvdXRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0galF1ZXJ5Lm5vb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gaXNUaW1lb3V0ID09PSBcInRpbWVvdXRcIiA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcInRpbWVvdXRcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAhalF1ZXJ5Lmh0dHBTdWNjZXNzKHhocikgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXJyb3JcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5pZk1vZGlmaWVkICYmIGpRdWVyeS5odHRwTm90TW9kaWZpZWQoeGhyLCBzLnVybCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vdG1vZGlmaWVkXCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyTXNnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYXRjaCBmb3IsIGFuZCBjYXRjaCwgWE1MIGRvY3VtZW50IHBhcnNlIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBkYXRhIChydW5zIHRoZSB4bWwgdGhyb3VnaCBodHRwRGF0YSByZWdhcmRsZXNzIG9mIGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBqUXVlcnkuaHR0cERhdGEoeGhyLCBzLmRhdGFUeXBlLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJwYXJzZXJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZyA9IHBhcnNlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWwgb3Igbm90bW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJzdWNjZXNzXCIgfHwgc3RhdHVzID09PSBcIm5vdG1vZGlmaWVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpTT05QIGhhbmRsZXMgaXRzIG93biBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWpzb25wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmhhbmRsZVN1Y2Nlc3MocywgeGhyLCBzdGF0dXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmhhbmRsZUVycm9yKHMsIHhociwgc3RhdHVzLCBlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSB0aGUgY29tcGxldGUgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqc29ucCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmhhbmRsZUNvbXBsZXRlKHMsIHhociwgc3RhdHVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVvdXQgPT09IFwidGltZW91dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGFib3J0IGhhbmRsZXIsIGlmIHdlIGNhbiAoSUUgNiBkb2Vzbid0IGFsbG93IGl0LCBidXQgdGhhdCdzIE9LKVxuICAgICAgICAgICAgLy8gT3BlcmEgZG9lc24ndCBmaXJlIG9ucmVhZHlzdGF0ZWNoYW5nZSBhdCBhbGwgb24gYWJvcnRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEFib3J0ID0geGhyLmFib3J0O1xuICAgICAgICAgICAgICAgIHhoci5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8geGhyLmFib3J0IGluIElFNyBpcyBub3QgYSBuYXRpdmUgSlMgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGRvZXMgbm90IGhhdmUgYSBjYWxsIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIgJiYgb2xkQWJvcnQuY2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQWJvcnQuY2FsbCh4aHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb25yZWFkeXN0YXRlY2hhbmdlKFwiYWJvcnRcIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGFib3J0RXJyb3IpIHsgfVxuXG4gICAgICAgICAgICAvLyBUaW1lb3V0IGNoZWNrZXJcbiAgICAgICAgICAgIGlmIChzLmFzeW5jICYmIHMudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGhhcHBlbmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyICYmICFyZXF1ZXN0RG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25yZWFkeXN0YXRlY2hhbmdlKFwidGltZW91dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHMudGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIGRhdGFcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQobm9Db250ZW50IHx8IHMuZGF0YSA9PSBudWxsID8gbnVsbCA6IHMuZGF0YSk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNlbmRFcnJvcikge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5oYW5kbGVFcnJvcihzLCB4aHIsIG51bGwsIHNlbmRFcnJvcik7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIGpRdWVyeS5oYW5kbGVDb21wbGV0ZShzLCB4aHIsIHN0YXR1cywgZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcmVmb3ggMS41IGRvZXNuJ3QgZmlyZSBzdGF0ZWNoYW5nZSBmb3Igc3luYyByZXF1ZXN0c1xuICAgICAgICAgICAgaWYgKCFzLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgb25yZWFkeXN0YXRlY2hhbmdlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJldHVybiBYTUxIdHRwUmVxdWVzdCB0byBhbGxvdyBhYm9ydGluZyB0aGUgcmVxdWVzdCBldGMuXG4gICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4gICAgICAgIC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xuICAgICAgICBwYXJhbTogZnVuY3Rpb24gKGEsIHRyYWRpdGlvbmFsKSB7XG4gICAgICAgICAgICB2YXIgcyA9IFtdLCBhZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUoKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIHNbcy5sZW5ndGhdID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuICAgICAgICAgICAgaWYgKHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkoYSkgfHwgYS5qcXVlcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcbiAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaChhLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAgICAgICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJlZml4IGluIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4LCBhW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuICAgICAgICAgICAgcmV0dXJuIHMuam9pbihcIiZcIikucmVwbGFjZShyMjAsIFwiK1wiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRQYXJhbXMocHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQpIHtcbiAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG4gICAgICAgICAgICBqUXVlcnkuZWFjaChvYmosIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICAgICAgICAgIGFkZChwcmVmaXgsIHYpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXJyYXkgaXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgaW5kZXggdG8gcmVzb2x2ZSBkZXNlcmlhbGl6YXRpb24gYW1iaWd1aXR5IGlzc3Vlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHJhY2sgKGFzIG9mIDEuMC4wKSBjYW4ndCBjdXJyZW50bHkgZGVzZXJpYWxpemVcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVzdGVkIGFycmF5cyBwcm9wZXJseSwgYW5kIGF0dGVtcHRpbmcgdG8gZG8gc28gbWF5IGNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyIGVycm9yLiBQb3NzaWJsZSBmaXhlcyBhcmUgdG8gbW9kaWZ5IHJhY2snc1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXNlcmlhbGl6YXRpb24gYWxnb3JpdGhtIG9yIHRvIHByb3ZpZGUgYW4gb3B0aW9uIG9yIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZm9yY2UgYXJyYXkgc2VyaWFsaXphdGlvbiB0byBiZSBzaGFsbG93LlxuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyBcIltcIiArICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiB8fCBqUXVlcnkuaXNBcnJheSh2KSA/IGkgOiBcIlwiKSArIFwiXVwiLCB2LCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2UgaWYgKCF0cmFkaXRpb25hbCAmJiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRW1wdHlPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgICAgIGFkZChwcmVmaXgsIFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaChvYmosIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArIFwiW1wiICsgayArIFwiXVwiLCB2LCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuICAgICAgICAgICAgYWRkKHByZWZpeCwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgc3RpbGwgb24gdGhlIGpRdWVyeSBvYmplY3QuLi4gZm9yIG5vd1xuICAgIC8vIFdhbnQgdG8gbW92ZSB0aGlzIHRvIGpRdWVyeS5hamF4IHNvbWUgZGF5XG4gICAgalF1ZXJ5LmV4dGVuZCh7XG5cbiAgICAgICAgLy8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG4gICAgICAgIGFjdGl2ZTogMCxcblxuICAgICAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG4gICAgICAgIGxhc3RNb2RpZmllZDoge30sXG4gICAgICAgIGV0YWc6IHt9LFxuXG4gICAgICAgIGhhbmRsZUVycm9yOiBmdW5jdGlvbiAocywgeGhyLCBzdGF0dXMsIGUpIHtcbiAgICAgICAgICAgIC8vIElmIGEgbG9jYWwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgZmlyZSBpdFxuICAgICAgICAgICAgaWYgKHMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzLmVycm9yLmNhbGwocy5jb250ZXh0LCB4aHIsIHN0YXR1cywgZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcmUgdGhlIGdsb2JhbCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHMuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnRyaWdnZXJHbG9iYWwocywgXCJhamF4RXJyb3JcIiwgW3hociwgcywgZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVN1Y2Nlc3M6IGZ1bmN0aW9uIChzLCB4aHIsIHN0YXR1cywgZGF0YSkge1xuICAgICAgICAgICAgLy8gSWYgYSBsb2NhbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBmaXJlIGl0IGFuZCBwYXNzIGl0IHRoZSBkYXRhXG4gICAgICAgICAgICBpZiAocy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgcy5zdWNjZXNzLmNhbGwocy5jb250ZXh0LCBkYXRhLCBzdGF0dXMsIHhocik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcmUgdGhlIGdsb2JhbCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHMuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LnRyaWdnZXJHbG9iYWwocywgXCJhamF4U3VjY2Vzc1wiLCBbeGhyLCBzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQ29tcGxldGU6IGZ1bmN0aW9uIChzLCB4aHIsIHN0YXR1cykge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyByZXN1bHRcbiAgICAgICAgICAgIGlmIChzLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcy5jb21wbGV0ZS5jYWxsKHMuY29udGV4dCwgeGhyLCBzdGF0dXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgcmVxdWVzdCB3YXMgY29tcGxldGVkXG4gICAgICAgICAgICBpZiAocy5nbG9iYWwpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkudHJpZ2dlckdsb2JhbChzLCBcImFqYXhDb21wbGV0ZVwiLCBbeGhyLCBzXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuICAgICAgICAgICAgaWYgKHMuZ2xvYmFsICYmIGpRdWVyeS5hY3RpdmUtLSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpZ2dlckdsb2JhbDogZnVuY3Rpb24gKHMsIHR5cGUsIGFyZ3MpIHtcbiAgICAgICAgICAgIChzLmNvbnRleHQgJiYgcy5jb250ZXh0LnVybCA9PSBudWxsID8galF1ZXJ5KHMuY29udGV4dCkgOiBqUXVlcnkuZXZlbnQpLnRyaWdnZXIodHlwZSwgYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiBhbiBYTUxIdHRwUmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCBvciBub3RcbiAgICAgICAgaHR0cFN1Y2Nlc3M6IGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgZXJyb3Igc29tZXRpbWVzIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDQgc28gdHJlYXQgaXQgYXMgc3VjY2Vzcywgc2VlICMxNDUwXG4gICAgICAgICAgICAgICAgcmV0dXJuICF4aHIuc3RhdHVzICYmIGxvY2F0aW9uLnByb3RvY29sID09PSBcImZpbGU6XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzID09PSAzMDQgfHwgeGhyLnN0YXR1cyA9PT0gMTIyMztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiBhbiBYTUxIdHRwUmVxdWVzdCByZXR1cm5zIE5vdE1vZGlmaWVkXG4gICAgICAgIGh0dHBOb3RNb2RpZmllZDogZnVuY3Rpb24gKHhociwgdXJsKSB7XG4gICAgICAgICAgICB2YXIgbGFzdE1vZGlmaWVkID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSxcbiAgICAgICAgICAgICAgICBldGFnID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiRXRhZ1wiKTtcblxuICAgICAgICAgICAgaWYgKGxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbdXJsXSA9IGxhc3RNb2RpZmllZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV0YWcpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXRhZ1t1cmxdID0gZXRhZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPT09IDMwNDtcbiAgICAgICAgfSxcblxuICAgICAgICBodHRwRGF0YTogZnVuY3Rpb24gKHhociwgdHlwZSwgcykge1xuICAgICAgICAgICAgdmFyIGN0ID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgeG1sID0gdHlwZSA9PT0gXCJ4bWxcIiB8fCAhdHlwZSAmJiBjdC5pbmRleE9mKFwieG1sXCIpID49IDAsXG4gICAgICAgICAgICAgICAgZGF0YSA9IHhtbCA/IHhoci5yZXNwb25zZVhNTCA6IHhoci5yZXNwb25zZVRleHQ7XG5cbiAgICAgICAgICAgIGlmICh4bWwgJiYgZGF0YS5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5lcnJvcihcInBhcnNlcmVycm9yXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGxvdyBhIHByZS1maWx0ZXJpbmcgZnVuY3Rpb24gdG8gc2FuaXRpemUgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyBzIGlzIGNoZWNrZWQgdG8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgaWYgKHMgJiYgcy5kYXRhRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHMuZGF0YUZpbHRlcihkYXRhLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGZpbHRlciBjYW4gYWN0dWFsbHkgcGFyc2UgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIEphdmFTY3JpcHQgb2JqZWN0LCBpZiBKU09OIGlzIHVzZWQuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwianNvblwiIHx8ICF0eXBlICYmIGN0LmluZGV4T2YoXCJqc29uXCIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGpRdWVyeS5wYXJzZUpTT04oZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgXCJzY3JpcHRcIiwgZXZhbCBpdCBpbiBnbG9iYWwgY29udGV4dFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzY3JpcHRcIiB8fCAhdHlwZSAmJiBjdC5pbmRleE9mKFwiamF2YXNjcmlwdFwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBDcmVhdGUgdGhlIHJlcXVlc3Qgb2JqZWN0OyBNaWNyb3NvZnQgZmFpbGVkIHRvIHByb3Blcmx5XG4gICAgICogaW1wbGVtZW50IHRoZSBYTUxIdHRwUmVxdWVzdCBpbiBJRTcgKGNhbid0IHJlcXVlc3QgbG9jYWwgZmlsZXMpLFxuICAgICAqIHNvIHdlIHVzZSB0aGUgQWN0aXZlWE9iamVjdCB3aGVuIGl0IGlzIGF2YWlsYWJsZVxuICAgICAqIEFkZGl0aW9uYWxseSBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgaW4gSUU3L0lFOCBzb1xuICAgICAqIHdlIG5lZWQgYSBmYWxsYmFjay5cbiAgICAgKi9cbiAgICBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSBcImZpbGU6XCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHhockVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChhY3RpdmVFcnJvcikgeyB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRG9lcyB0aGlzIGJyb3dzZXIgc3VwcG9ydCBYSFIgcmVxdWVzdHM/XG4gICAgalF1ZXJ5LnN1cHBvcnQuYWpheCA9ICEhalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuXG5cblxuICAgIHZhciBlbGVtZGlzcGxheSA9IHt9LFxuICAgICAgICByZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcbiAgICAgICAgcmZ4bnVtID0gL14oWytcXC1dPSk/KFtcXGQrLlxcLV0rKSguKikkLyxcbiAgICAgICAgdGltZXJJZCxcbiAgICAgICAgZnhBdHRycyA9IFtcbiAgICAgICAgICAgIC8vIGhlaWdodCBhbmltYXRpb25zXG4gICAgICAgICAgICBbXCJoZWlnaHRcIiwgXCJtYXJnaW5Ub3BcIiwgXCJtYXJnaW5Cb3R0b21cIiwgXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiXSxcbiAgICAgICAgICAgIC8vIHdpZHRoIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIFtcIndpZHRoXCIsIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblJpZ2h0XCIsIFwicGFkZGluZ0xlZnRcIiwgXCJwYWRkaW5nUmlnaHRcIl0sXG4gICAgICAgICAgICAvLyBvcGFjaXR5IGFuaW1hdGlvbnNcbiAgICAgICAgICAgIFtcIm9wYWNpdHlcIl1cbiAgICAgICAgXTtcblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBzaG93OiBmdW5jdGlvbiAoc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChzcGVlZCB8fCBzcGVlZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoZ2VuRngoXCJzaG93XCIsIDMpLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LmRhdGEodGhpc1tpXSwgXCJvbGRkaXNwbGF5XCIpICYmIHRoaXNbaV0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbaV0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBqUXVlcnkuY3NzKHRoaXNbaV0sIFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kYXRhKHRoaXNbaV0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheSh0aGlzW2ldLm5vZGVOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0uc3R5bGUuZGlzcGxheSA9IGpRdWVyeS5kYXRhKHRoaXNbaV0sIFwib2xkZGlzcGxheVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHNwZWVkIHx8IHNwZWVkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShnZW5GeChcImhpZGVcIiwgMyksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5ID0galF1ZXJ5LmNzcyh0aGlzW2ldLCBcImRpc3BsYXlcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BsYXkgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGF0YSh0aGlzW2ldLCBcIm9sZGRpc3BsYXlcIiwgZGlzcGxheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3BcbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTYXZlIHRoZSBvbGQgdG9nZ2xlIGZ1bmN0aW9uXG4gICAgICAgIF90b2dnbGU6IGpRdWVyeS5mbi50b2dnbGUsXG5cbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiAoZm4sIGZuMiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBib29sID0gdHlwZW9mIGZuID09PSBcImJvb2xlYW5cIjtcblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGZuKSAmJiBqUXVlcnkuaXNGdW5jdGlvbihmbjIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm4gPT0gbnVsbCB8fCBib29sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gYm9vbCA/IGZuIDogalF1ZXJ5KHRoaXMpLmlzKFwiOmhpZGRlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpW3N0YXRlID8gXCJzaG93XCIgOiBcImhpZGVcIl0oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoZ2VuRngoXCJ0b2dnbGVcIiwgMyksIGZuLCBmbjIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmFkZVRvOiBmdW5jdGlvbiAoc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoXCI6aGlkZGVuXCIpLmNzcyhcIm9wYWNpdHlcIiwgMCkuc2hvdygpLmVuZCgpXG4gICAgICAgICAgICAgICAgLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgb3B0YWxsID0galF1ZXJ5LnNwZWVkKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0VtcHR5T2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChvcHRhbGwuY29tcGxldGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tvcHRhbGwucXVldWUgPT09IGZhbHNlID8gXCJlYWNoXCIgOiBcInF1ZXVlXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBYWFgg4oCYdGhpc+KAmSBkb2VzIG5vdCBhbHdheXMgaGF2ZSBhIG5vZGVOYW1lIHdoZW4gcnVubmluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IHN1aXRlXG5cbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0galF1ZXJ5LmV4dGVuZCh7fSwgb3B0YWxsKSwgcCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbGVtZW50ID0gdGhpcy5ub2RlVHlwZSA9PT0gMSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuID0gaXNFbGVtZW50ICYmIGpRdWVyeSh0aGlzKS5pcyhcIjpoaWRkZW5cIiksXG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKHApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwICE9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wW25hbWVdID0gcHJvcFtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wW3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcFtwXSA9PT0gXCJoaWRlXCIgJiYgaGlkZGVuIHx8IHByb3BbcF0gPT09IFwic2hvd1wiICYmICFoaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHQuY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VsZW1lbnQgJiYgKHAgPT09IFwiaGVpZ2h0XCIgfHwgcCA9PT0gXCJ3aWR0aFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHQub3ZlcmZsb3cgPSBbdGhpcy5zdHlsZS5vdmVyZmxvdywgdGhpcy5zdHlsZS5vdmVyZmxvd1gsIHRoaXMuc3R5bGUub3ZlcmZsb3dZXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbnMgb24gaW5saW5lIGVsZW1lbnRzIHRoYXQgYXJlIGhhdmluZyB3aWR0aC9oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmNzcyh0aGlzLCBcImRpc3BsYXlcIikgPT09IFwiaW5saW5lXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKHRoaXMsIFwiZmxvYXRcIikgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkuc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5KHRoaXMubm9kZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlubGluZS1sZXZlbCBlbGVtZW50cyBhY2NlcHQgaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jay1sZXZlbCBlbGVtZW50cyBuZWVkIHRvIGJlIGlubGluZSB3aXRoIGxheW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGxheSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuem9vbSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkocHJvcFtwXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSAoaWYgbmVlZGVkKSBhbmQgYWRkIHRvIHNwZWNpYWxFYXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcHQuc3BlY2lhbEVhc2luZyA9IG9wdC5zcGVjaWFsRWFzaW5nIHx8IHt9KVtwXSA9IHByb3BbcF1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wW3BdID0gcHJvcFtwXVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHQub3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcHQuY3VyQW5pbSA9IGpRdWVyeS5leHRlbmQoe30sIHByb3ApO1xuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2gocHJvcCwgZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IG5ldyBqUXVlcnkuZngoc2VsZiwgb3B0LCBuYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmZ4dHlwZXMudGVzdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlW3ZhbCA9PT0gXCJ0b2dnbGVcIiA/IGhpZGRlbiA/IFwic2hvd1wiIDogXCJoaWRlXCIgOiB2YWxdKHByb3ApO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSByZnhudW0uZXhlYyh2YWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZS5jdXIodHJ1ZSkgfHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBhcnNlRmxvYXQocGFydHNbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0ID0gcGFydHNbM10gfHwgXCJweFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHN0YXJ0aW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuaXQgIT09IFwicHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoc2VsZiwgbmFtZSwgKGVuZCB8fCAxKSArIHVuaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9ICgoZW5kIHx8IDEpIC8gZS5jdXIodHJ1ZSkpICogc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShzZWxmLCBuYW1lLCBzdGFydCArIHVuaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoKHBhcnRzWzFdID09PSBcIi09XCIgPyAtMSA6IDEpICogZW5kKSArIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY3VzdG9tKHN0YXJ0LCBlbmQsIHVuaXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY3VzdG9tKHN0YXJ0LCB2YWwsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgSlMgc3RyaWN0IGNvbXBsaWFuY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIChjbGVhclF1ZXVlLCBnb3RvRW5kKSB7XG4gICAgICAgICAgICB2YXIgdGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuICAgICAgICAgICAgaWYgKGNsZWFyUXVldWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlKFtdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyBpbiByZXZlcnNlIG9yZGVyIHNvIGFueXRoaW5nIGFkZGVkIHRvIHRoZSBxdWV1ZSBkdXJpbmcgdGhlIGxvb3AgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aW1lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyc1tpXS5lbGVtID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ290b0VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIHRoZSBuZXh0IHN0ZXAgdG8gYmUgdGhlIGxhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnNbaV0odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZFxuICAgICAgICAgICAgaWYgKCFnb3RvRW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdlbkZ4KHR5cGUsIG51bSkge1xuICAgICAgICB2YXIgb2JqID0ge307XG5cbiAgICAgICAgalF1ZXJ5LmVhY2goZnhBdHRycy5jb25jYXQuYXBwbHkoW10sIGZ4QXR0cnMuc2xpY2UoMCwgbnVtKSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9ialt0aGlzXSA9IHR5cGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xuICAgIGpRdWVyeS5lYWNoKHtcbiAgICAgICAgc2xpZGVEb3duOiBnZW5GeChcInNob3dcIiwgMSksXG4gICAgICAgIHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiLCAxKSxcbiAgICAgICAgc2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIsIDEpLFxuICAgICAgICBmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcbiAgICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9XG4gICAgfSwgZnVuY3Rpb24gKG5hbWUsIHByb3BzKSB7XG4gICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgIHNwZWVkOiBmdW5jdGlvbiAoc3BlZWQsIGVhc2luZywgZm4pIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKHt9LCBzcGVlZCkgOiB7XG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzRnVuY3Rpb24oc3BlZWQpICYmIHNwZWVkLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBzcGVlZCxcbiAgICAgICAgICAgICAgICBlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKGVhc2luZykgJiYgZWFzaW5nXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvcHQuZHVyYXRpb24gPSBqUXVlcnkuZngub2ZmID8gMCA6IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgPyBvcHQuZHVyYXRpb24gOlxuICAgICAgICAgICAgICAgIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1tvcHQuZHVyYXRpb25dIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuICAgICAgICAgICAgLy8gUXVldWVpbmdcbiAgICAgICAgICAgIG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG4gICAgICAgICAgICBvcHQuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5xdWV1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLmRlcXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKG9wdC5vbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdC5vbGQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gb3B0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGVhc2luZzoge1xuICAgICAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAocCwgbiwgZmlyc3ROdW0sIGRpZmYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3ROdW0gKyBkaWZmICogcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzd2luZzogZnVuY3Rpb24gKHAsIG4sIGZpcnN0TnVtLCBkaWZmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoLU1hdGguY29zKHAgKiBNYXRoLlBJKSAvIDIpICsgMC41KSAqIGRpZmYgKyBmaXJzdE51bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0aW1lcnM6IFtdLFxuXG4gICAgICAgIGZ4OiBmdW5jdGlvbiAoZWxlbSwgb3B0aW9ucywgcHJvcCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICAgICAgICB0aGlzLnByb3AgPSBwcm9wO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMub3JpZykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub3JpZyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIGpRdWVyeS5meC5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8vIFNpbXBsZSBmdW5jdGlvbiBmb3Igc2V0dGluZyBhIHN0eWxlIHZhbHVlXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKGpRdWVyeS5meC5zdGVwW3RoaXMucHJvcF0gfHwgalF1ZXJ5LmZ4LnN0ZXAuX2RlZmF1bHQpKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzaXplXG4gICAgICAgIGN1cjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbVt0aGlzLnByb3BdICE9IG51bGwgJiYgKCF0aGlzLmVsZW0uc3R5bGUgfHwgdGhpcy5lbGVtLnN0eWxlW3RoaXMucHJvcF0gPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtW3RoaXMucHJvcF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByID0gcGFyc2VGbG9hdChqUXVlcnkuY3NzKHRoaXMuZWxlbSwgdGhpcy5wcm9wKSk7XG4gICAgICAgICAgICByZXR1cm4gciAmJiByID4gLTEwMDAwID8gciA6IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU3RhcnQgYW4gYW5pbWF0aW9uIGZyb20gb25lIG51bWJlciB0byBhbm90aGVyXG4gICAgICAgIGN1c3RvbTogZnVuY3Rpb24gKGZyb20sIHRvLCB1bml0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IGpRdWVyeS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBmcm9tO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSB0bztcbiAgICAgICAgICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgdGhpcy51bml0IHx8IFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMubm93ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5zdGF0ZSA9IDA7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgZnggPSBqUXVlcnkuZng7XG4gICAgICAgICAgICBmdW5jdGlvbiB0KGdvdG9FbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zdGVwKGdvdG9FbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0LmVsZW0gPSB0aGlzLmVsZW07XG5cbiAgICAgICAgICAgIGlmICh0KCkgJiYgalF1ZXJ5LnRpbWVycy5wdXNoKHQpICYmICF0aW1lcklkKSB7XG4gICAgICAgICAgICAgICAgdGltZXJJZCA9IHNldEludGVydmFsKGZ4LnRpY2ssIGZ4LmludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTaW1wbGUgJ3Nob3cnIGZ1bmN0aW9uXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoZXJlIHdlIHN0YXJ0ZWQsIHNvIHRoYXQgd2UgY2FuIGdvIGJhY2sgdG8gaXQgbGF0ZXJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcmlnW3RoaXMucHJvcF0gPSBqUXVlcnkuc3R5bGUodGhpcy5lbGVtLCB0aGlzLnByb3ApO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNob3cgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBCZWdpbiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBzdGFydCBhdCBhIHNtYWxsIHdpZHRoL2hlaWdodCB0byBhdm9pZCBhbnlcbiAgICAgICAgICAgIC8vIGZsYXNoIG9mIGNvbnRlbnRcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tKHRoaXMucHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHRoaXMucHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwLCB0aGlzLmN1cigpKTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgYnkgc2hvd2luZyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgalF1ZXJ5KHRoaXMuZWxlbSkuc2hvdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNpbXBsZSAnaGlkZScgZnVuY3Rpb25cbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmVtZW1iZXIgd2hlcmUgd2Ugc3RhcnRlZCwgc28gdGhhdCB3ZSBjYW4gZ28gYmFjayB0byBpdCBsYXRlclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9yaWdbdGhpcy5wcm9wXSA9IGpRdWVyeS5zdHlsZSh0aGlzLmVsZW0sIHRoaXMucHJvcCk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlkZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEJlZ2luIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIHRoaXMuY3VzdG9tKHRoaXMuY3VyKCksIDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEVhY2ggc3RlcCBvZiBhbiBhbmltYXRpb25cbiAgICAgICAgc3RlcDogZnVuY3Rpb24gKGdvdG9FbmQpIHtcbiAgICAgICAgICAgIHZhciB0ID0galF1ZXJ5Lm5vdygpLCBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGdvdG9FbmQgfHwgdCA+PSB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKyB0aGlzLnN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gdGhpcy5lbmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmN1ckFuaW1bdGhpcy5wcm9wXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMub3B0aW9ucy5jdXJBbmltKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VyQW5pbVtpXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmZsb3cgIT0gbnVsbCAmJiAhalF1ZXJ5LnN1cHBvcnQuc2hyaW5rV3JhcEJsb2Nrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmVsZW0sIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaChbXCJcIiwgXCJYXCIsIFwiWVwiXSwgZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVbXCJvdmVyZmxvd1wiICsgdmFsdWVdID0gb3B0aW9ucy5vdmVyZmxvd1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgdGhlIGVsZW1lbnQgaWYgdGhlIFwiaGlkZVwiIG9wZXJhdGlvbiB3YXMgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzLmVsZW0pLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwcm9wZXJ0aWVzLCBpZiB0aGUgaXRlbSBoYXMgYmVlbiBoaWRkZW4gb3Igc2hvd25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlIHx8IHRoaXMub3B0aW9ucy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwIGluIHRoaXMub3B0aW9ucy5jdXJBbmltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN0eWxlKHRoaXMuZWxlbSwgcCwgdGhpcy5vcHRpb25zLm9yaWdbcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgY29tcGxldGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNvbXBsZXRlLmNhbGwodGhpcy5lbGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0IC0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG4gLyB0aGlzLm9wdGlvbnMuZHVyYXRpb247XG5cbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBlYXNpbmcgZnVuY3Rpb24sIGRlZmF1bHRzIHRvIHN3aW5nXG4gICAgICAgICAgICAgICAgdmFyIHNwZWNpYWxFYXNpbmcgPSB0aGlzLm9wdGlvbnMuc3BlY2lhbEVhc2luZyAmJiB0aGlzLm9wdGlvbnMuc3BlY2lhbEVhc2luZ1t0aGlzLnByb3BdO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0RWFzaW5nID0gdGhpcy5vcHRpb25zLmVhc2luZyB8fCAoalF1ZXJ5LmVhc2luZy5zd2luZyA/IFwic3dpbmdcIiA6IFwibGluZWFyXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0galF1ZXJ5LmVhc2luZ1tzcGVjaWFsRWFzaW5nIHx8IGRlZmF1bHRFYXNpbmddKHRoaXMuc3RhdGUsIG4sIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3cgPSB0aGlzLnN0YXJ0ICsgKCh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpICogdGhpcy5wb3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgbmV4dCBzdGVwIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBqUXVlcnkuZXh0ZW5kKGpRdWVyeS5meCwge1xuICAgICAgICB0aWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRpbWVyc1tpXSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGltZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5meC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZXJ2YWw6IDEzLFxuXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgICAgICAgICB0aW1lcklkID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBzcGVlZHM6IHtcbiAgICAgICAgICAgIHNsb3c6IDYwMCxcbiAgICAgICAgICAgIGZhc3Q6IDIwMCxcbiAgICAgICAgICAgIC8vIERlZmF1bHQgc3BlZWRcbiAgICAgICAgICAgIF9kZWZhdWx0OiA0MDBcbiAgICAgICAgfSxcblxuICAgICAgICBzdGVwOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiBmdW5jdGlvbiAoZngpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoZnguZWxlbSwgXCJvcGFjaXR5XCIsIGZ4Lm5vdyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfZGVmYXVsdDogZnVuY3Rpb24gKGZ4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ4LmVsZW0uc3R5bGUgJiYgZnguZWxlbS5zdHlsZVtmeC5wcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ4LmVsZW0uc3R5bGVbZngucHJvcF0gPSAoZngucHJvcCA9PT0gXCJ3aWR0aFwiIHx8IGZ4LnByb3AgPT09IFwiaGVpZ2h0XCIgPyBNYXRoLm1heCgwLCBmeC5ub3cpIDogZngubm93KSArIGZ4LnVuaXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnguZWxlbVtmeC5wcm9wXSA9IGZ4Lm5vdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChqUXVlcnkuZXhwciAmJiBqUXVlcnkuZXhwci5maWx0ZXJzKSB7XG4gICAgICAgIGpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KG5vZGVOYW1lKSB7XG4gICAgICAgIGlmICghZWxlbWRpc3BsYXlbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGpRdWVyeShcIjxcIiArIG5vZGVOYW1lICsgXCI+XCIpLmFwcGVuZFRvKFwiYm9keVwiKSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5ID0gZWxlbS5jc3MoXCJkaXNwbGF5XCIpO1xuXG4gICAgICAgICAgICBlbGVtLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZGlzcGxheSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1kaXNwbGF5W25vZGVOYW1lXSA9IGRpc3BsYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWRpc3BsYXlbbm9kZU5hbWVdO1xuICAgIH1cblxuXG5cblxuICAgIHZhciBydGFibGUgPSAvXnQoPzphYmxlfGR8aCkkL2ksXG4gICAgICAgIHJyb290ID0gL14oPzpib2R5fGh0bWwpJC9pO1xuXG4gICAgaWYgKFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgIGpRdWVyeS5mbi5vZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdLCBib3g7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBvcHRpb25zLCBpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFlbGVtIHx8ICFlbGVtLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW0gPT09IGVsZW0ub3duZXJEb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5vZmZzZXQuYm9keU9mZnNldChlbGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICAgICAgICAgIHZhciBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgZGVhbGluZyB3aXRoIGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG4gICAgICAgICAgICBpZiAoIWJveCB8fCAhalF1ZXJ5LmNvbnRhaW5zKGRvY0VsZW0sIGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJveCB8fCB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYm9keSA9IGRvYy5ib2R5LFxuICAgICAgICAgICAgICAgIHdpbiA9IGdldFdpbmRvdyhkb2MpLFxuICAgICAgICAgICAgICAgIGNsaWVudFRvcCA9IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDAsXG4gICAgICAgICAgICAgICAgY2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSAod2luLnBhZ2VZT2Zmc2V0IHx8IGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsICYmIGRvY0VsZW0uc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wKSxcbiAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gKHdpbi5wYWdlWE9mZnNldCB8fCBqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCAmJiBkb2NFbGVtLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0KSxcbiAgICAgICAgICAgICAgICB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wLFxuICAgICAgICAgICAgICAgIGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xuXG4gICAgICAgICAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgalF1ZXJ5LmZuLm9mZnNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBvcHRpb25zLCBpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFlbGVtIHx8ICFlbGVtLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW0gPT09IGVsZW0ub3duZXJEb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5vZmZzZXQuYm9keU9mZnNldChlbGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgalF1ZXJ5Lm9mZnNldC5pbml0aWFsaXplKCk7XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCwgcHJldk9mZnNldFBhcmVudCA9IGVsZW0sXG4gICAgICAgICAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LCBjb21wdXRlZFN0eWxlLCBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBib2R5ID0gZG9jLmJvZHksIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3LFxuICAgICAgICAgICAgICAgIHByZXZDb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcgPyBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpIDogZWxlbS5jdXJyZW50U3R5bGUsXG4gICAgICAgICAgICAgICAgdG9wID0gZWxlbS5vZmZzZXRUb3AsIGxlZnQgPSBlbGVtLm9mZnNldExlZnQ7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbSAhPT0gYm9keSAmJiBlbGVtICE9PSBkb2NFbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5vZmZzZXQuc3VwcG9ydHNGaXhlZFBvc2l0aW9uICYmIHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRTdHlsZSA9IGRlZmF1bHRWaWV3ID8gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKSA6IGVsZW0uY3VycmVudFN0eWxlO1xuICAgICAgICAgICAgICAgIHRvcCAtPSBlbGVtLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBsZWZ0IC09IGVsZW0uc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wICs9IGVsZW0ub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ICs9IGVsZW0ub2Zmc2V0TGVmdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Lm9mZnNldC5kb2VzTm90QWRkQm9yZGVyICYmICEoalF1ZXJ5Lm9mZnNldC5kb2VzQWRkQm9yZGVyRm9yVGFibGVBbmRDZWxscyAmJiBydGFibGUudGVzdChlbGVtLm5vZGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCArPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICs9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcmV2T2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Lm9mZnNldC5zdWJ0cmFjdHNCb3JkZXJGb3JPdmVyZmxvd05vdFZpc2libGUgJiYgY29tcHV0ZWRTdHlsZS5vdmVyZmxvdyAhPT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wICs9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCArPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcInJlbGF0aXZlXCIgfHwgcHJldkNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICB0b3AgKz0gYm9keS5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgbGVmdCArPSBib2R5Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqUXVlcnkub2Zmc2V0LnN1cHBvcnRzRml4ZWRQb3NpdGlvbiAmJiBwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgdG9wICs9IE1hdGgubWF4KGRvY0VsZW0uc2Nyb2xsVG9wLCBib2R5LnNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgbGVmdCArPSBNYXRoLm1heChkb2NFbGVtLnNjcm9sbExlZnQsIGJvZHkuc2Nyb2xsTGVmdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgalF1ZXJ5Lm9mZnNldCA9IHtcbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBpbm5lckRpdiwgY2hlY2tEaXYsIHRhYmxlLCB0ZCwgYm9keU1hcmdpblRvcCA9IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhib2R5LCBcIm1hcmdpblRvcFwiKSkgfHwgMCxcbiAgICAgICAgICAgICAgICBodG1sID0gXCI8ZGl2IHN0eWxlPSdwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7bWFyZ2luOjA7Ym9yZGVyOjVweCBzb2xpZCAjMDAwO3BhZGRpbmc6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnPjxkaXY+PC9kaXY+PC9kaXY+PHRhYmxlIHN0eWxlPSdwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7bWFyZ2luOjA7Ym9yZGVyOjVweCBzb2xpZCAjMDAwO3BhZGRpbmc6MDt3aWR0aDoxcHg7aGVpZ2h0OjFweDsnIGNlbGxwYWRkaW5nPScwJyBjZWxsc3BhY2luZz0nMCc+PHRyPjx0ZD48L3RkPjwvdHI+PC90YWJsZT5cIjtcblxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZChjb250YWluZXIuc3R5bGUsIHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdG9wOiAwLCBsZWZ0OiAwLCBtYXJnaW46IDAsIGJvcmRlcjogMCwgd2lkdGg6IFwiMXB4XCIsIGhlaWdodDogXCIxcHhcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9KTtcblxuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICBib2R5Lmluc2VydEJlZm9yZShjb250YWluZXIsIGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICBpbm5lckRpdiA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgY2hlY2tEaXYgPSBpbm5lckRpdi5maXJzdENoaWxkO1xuICAgICAgICAgICAgdGQgPSBpbm5lckRpdi5uZXh0U2libGluZy5maXJzdENoaWxkLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIHRoaXMuZG9lc05vdEFkZEJvcmRlciA9IChjaGVja0Rpdi5vZmZzZXRUb3AgIT09IDUpO1xuICAgICAgICAgICAgdGhpcy5kb2VzQWRkQm9yZGVyRm9yVGFibGVBbmRDZWxscyA9ICh0ZC5vZmZzZXRUb3AgPT09IDUpO1xuXG4gICAgICAgICAgICBjaGVja0Rpdi5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgICAgICAgIGNoZWNrRGl2LnN0eWxlLnRvcCA9IFwiMjBweFwiO1xuXG4gICAgICAgICAgICAvLyBzYWZhcmkgc3VidHJhY3RzIHBhcmVudCBib3JkZXIgd2lkdGggaGVyZSB3aGljaCBpcyA1cHhcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNGaXhlZFBvc2l0aW9uID0gKGNoZWNrRGl2Lm9mZnNldFRvcCA9PT0gMjAgfHwgY2hlY2tEaXYub2Zmc2V0VG9wID09PSAxNSk7XG4gICAgICAgICAgICBjaGVja0Rpdi5zdHlsZS5wb3NpdGlvbiA9IGNoZWNrRGl2LnN0eWxlLnRvcCA9IFwiXCI7XG5cbiAgICAgICAgICAgIGlubmVyRGl2LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIGlubmVyRGl2LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXG4gICAgICAgICAgICB0aGlzLnN1YnRyYWN0c0JvcmRlckZvck92ZXJmbG93Tm90VmlzaWJsZSA9IChjaGVja0Rpdi5vZmZzZXRUb3AgPT09IC01KTtcblxuICAgICAgICAgICAgdGhpcy5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCA9IChib2R5Lm9mZnNldFRvcCAhPT0gYm9keU1hcmdpblRvcCk7XG5cbiAgICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGJvZHkgPSBjb250YWluZXIgPSBpbm5lckRpdiA9IGNoZWNrRGl2ID0gdGFibGUgPSB0ZCA9IG51bGw7XG4gICAgICAgICAgICBqUXVlcnkub2Zmc2V0LmluaXRpYWxpemUgPSBqUXVlcnkubm9vcDtcbiAgICAgICAgfSxcblxuICAgICAgICBib2R5T2Zmc2V0OiBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgICAgdmFyIHRvcCA9IGJvZHkub2Zmc2V0VG9wLCBsZWZ0ID0gYm9keS5vZmZzZXRMZWZ0O1xuXG4gICAgICAgICAgICBqUXVlcnkub2Zmc2V0LmluaXRpYWxpemUoKTtcblxuICAgICAgICAgICAgaWYgKGpRdWVyeS5vZmZzZXQuZG9lc05vdEluY2x1ZGVNYXJnaW5JbkJvZHlPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0b3AgKz0gcGFyc2VGbG9hdChqUXVlcnkuY3NzKGJvZHksIFwibWFyZ2luVG9wXCIpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGxlZnQgKz0gcGFyc2VGbG9hdChqUXVlcnkuY3NzKGJvZHksIFwibWFyZ2luTGVmdFwiKSkgfHwgMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uIChlbGVtLCBvcHRpb25zLCBpKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBqUXVlcnkuY3NzKGVsZW0sIFwicG9zaXRpb25cIik7XG5cbiAgICAgICAgICAgIC8vIHNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJFbGVtID0galF1ZXJ5KGVsZW0pLFxuICAgICAgICAgICAgICAgIGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgY3VyQ1NTVG9wID0galF1ZXJ5LmNzcyhlbGVtLCBcInRvcFwiKSxcbiAgICAgICAgICAgICAgICBjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyhlbGVtLCBcImxlZnRcIiksXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24gPSAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiBqUXVlcnkuaW5BcnJheSgnYXV0bycsIFtjdXJDU1NUb3AsIGN1ckNTU0xlZnRdKSA+IC0xKSxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IHt9LCBjdXJQb3NpdGlvbiA9IHt9LCBjdXJUb3AsIGN1ckxlZnQ7XG5cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGFic29sdXRlXG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VyVG9wID0gY2FsY3VsYXRlUG9zaXRpb24gPyBjdXJQb3NpdGlvbi50b3AgOiBwYXJzZUludChjdXJDU1NUb3AsIDEwKSB8fCAwO1xuICAgICAgICAgICAgY3VyTGVmdCA9IGNhbGN1bGF0ZVBvc2l0aW9uID8gY3VyUG9zaXRpb24ubGVmdCA6IHBhcnNlSW50KGN1ckNTU0xlZnQsIDEwKSB8fCAwO1xuXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jYWxsKGVsZW0sIGksIGN1ck9mZnNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMudG9wID0gKG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCkgKyBjdXJUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5sZWZ0ID0gKG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0KSArIGN1ckxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcInVzaW5nXCIgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXNpbmcuY2FsbChlbGVtLCBwcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ckVsZW0uY3NzKHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpc1swXSxcblxuICAgICAgICAgICAgICAgIC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKSxcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjb3JyZWN0IG9mZnNldHNcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpLFxuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHJyb290LnRlc3Qob2Zmc2V0UGFyZW50WzBdLm5vZGVOYW1lKSA/IHsgdG9wOiAwLCBsZWZ0OiAwIH0gOiBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IGVsZW1lbnQgbWFyZ2luc1xuICAgICAgICAgICAgLy8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnRcbiAgICAgICAgICAgIC8vIGFyZSB0aGUgc2FtZSBpbiBTYWZhcmkgY2F1c2luZyBvZmZzZXQubGVmdCB0byBpbmNvcnJlY3RseSBiZSAwXG4gICAgICAgICAgICBvZmZzZXQudG9wIC09IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpblRvcFwiKSkgfHwgMDtcbiAgICAgICAgICAgIG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpbkxlZnRcIikpIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0LnRvcCArPSBwYXJzZUZsb2F0KGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50WzBdLCBcImJvcmRlclRvcFdpZHRoXCIpKSB8fCAwO1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0gcGFyc2VGbG9hdChqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJMZWZ0V2lkdGhcIikpIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHRoZSB0d28gb2Zmc2V0c1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgKCFycm9vdC50ZXN0KG9mZnNldFBhcmVudC5ub2RlTmFtZSkgJiYgalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbiAgICBqUXVlcnkuZWFjaChbXCJMZWZ0XCIsIFwiVG9wXCJdLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gXCJzY3JvbGxcIiArIG5hbWU7XG5cbiAgICAgICAgalF1ZXJ5LmZuW21ldGhvZF0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF0sIHdpbjtcblxuICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgc2Nyb2xsIG9mZnNldFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4gPSBnZXRXaW5kb3codGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbFRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpID8gdmFsIDogalF1ZXJ5KHdpbikuc2Nyb2xsTGVmdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPyB2YWwgOiBqUXVlcnkod2luKS5zY3JvbGxUb3AoKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2RdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpbiA9IGdldFdpbmRvdyhlbGVtKTtcblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgc2Nyb2xsIG9mZnNldFxuICAgICAgICAgICAgICAgIHJldHVybiB3aW4gPyAoXCJwYWdlWE9mZnNldFwiIGluIHdpbikgPyB3aW5baSA/IFwicGFnZVlPZmZzZXRcIiA6IFwicGFnZVhPZmZzZXRcIl0gOlxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCAmJiB3aW4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W21ldGhvZF0gfHxcbiAgICAgICAgICAgICAgICAgICAgd2luLmRvY3VtZW50LmJvZHlbbWV0aG9kXSA6XG4gICAgICAgICAgICAgICAgICAgIGVsZW1bbWV0aG9kXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkuaXNXaW5kb3coZWxlbSkgP1xuICAgICAgICAgICAgZWxlbSA6XG4gICAgICAgICAgICBlbGVtLm5vZGVUeXBlID09PSA5ID9cbiAgICAgICAgICAgICAgICBlbGVtLmRlZmF1bHRWaWV3IHx8IGVsZW0ucGFyZW50V2luZG93IDpcbiAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICB9XG5cblxuXG5cbiAgICAvLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbiAgICBqUXVlcnkuZWFjaChbXCJIZWlnaHRcIiwgXCJXaWR0aFwiXSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcblxuICAgICAgICB2YXIgdHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBpbm5lckhlaWdodCBhbmQgaW5uZXJXaWR0aFxuICAgICAgICBqUXVlcnkuZm5bXCJpbm5lclwiICsgbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXSA/XG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChqUXVlcnkuY3NzKHRoaXNbMF0sIHR5cGUsIFwicGFkZGluZ1wiKSkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGhcbiAgICAgICAgalF1ZXJ5LmZuW1wib3V0ZXJcIiArIG5hbWVdID0gZnVuY3Rpb24gKG1hcmdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0gP1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyh0aGlzWzBdLCB0eXBlLCBtYXJnaW4gPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIikpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIGpRdWVyeS5mblt0eXBlXSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgICAvLyBHZXQgd2luZG93IHdpZHRoIG9yIGhlaWdodFxuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xuICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemUgPT0gbnVsbCA/IG51bGwgOiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmW3R5cGVdKHNpemUuY2FsbCh0aGlzLCBpLCBzZWxmW3R5cGVdKCkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5pc1dpbmRvdyhlbGVtKSA/XG4gICAgICAgICAgICAgICAgLy8gRXZlcnlvbmUgZWxzZSB1c2UgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IG9yIGRvY3VtZW50LmJvZHkgZGVwZW5kaW5nIG9uIFF1aXJrcyB2cyBTdGFuZGFyZHMgbW9kZVxuICAgICAgICAgICAgICAgIGVsZW0uZG9jdW1lbnQuY29tcGF0TW9kZSA9PT0gXCJDU1MxQ29tcGF0XCIgJiYgZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIiArIG5hbWVdIHx8XG4gICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudC5ib2R5W1wiY2xpZW50XCIgKyBuYW1lXSA6XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG4gICAgICAgICAgICAgICAgKGVsZW0ubm9kZVR5cGUgPT09IDkpID8gLy8gaXMgaXQgYSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0sIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIiArIG5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5W1wic2Nyb2xsXCIgKyBuYW1lXSwgZWxlbS5kb2N1bWVudEVsZW1lbnRbXCJzY3JvbGxcIiArIG5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5W1wib2Zmc2V0XCIgKyBuYW1lXSwgZWxlbS5kb2N1bWVudEVsZW1lbnRbXCJvZmZzZXRcIiArIG5hbWVdXG4gICAgICAgICAgICAgICAgICAgICkgOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBvciBzZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGpRdWVyeS5jc3MoZWxlbSwgdHlwZSkpIDpcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQgKGRlZmF1bHQgdG8gcGl4ZWxzIGlmIHZhbHVlIGlzIHVuaXRsZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3ModHlwZSwgdHlwZW9mIHNpemUgPT09IFwic3RyaW5nXCIgPyBzaXplIDogc2l6ZSArIFwicHhcIik7XG4gICAgICAgIH07XG5cbiAgICB9KTtcblxuXG59KSh3aW5kb3cpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB3aW5kb3cualF1ZXJ5U0cgPSBqUXVlcnkubm9Db25mbGljdCh0cnVlKTtcblxufSkuY2FsbCh0aGlzKTsiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogbGluZSAxLCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuZGl2I3NlbGVjdG9yZ2FkZ2V0X21haW4ge1xcbiAgICBhemltdXRoOiBjZW50ZXIgIWltcG9ydGFudDtcXG4gICAgYmFja2dyb3VuZC1hdHRhY2htZW50OiBzY3JvbGwgIWltcG9ydGFudDtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwJSAwJSAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0ICFpbXBvcnRhbnQ7XFxuICAgIGJvcmRlci1jb2xsYXBzZTogc2VwYXJhdGUgIWltcG9ydGFudDtcXG4gICAgYm9yZGVyLXNwYWNpbmc6IDAgIWltcG9ydGFudDtcXG4gICAgYm90dG9tOiBhdXRvICFpbXBvcnRhbnQ7XFxuICAgIGNhcHRpb24tc2lkZTogdG9wICFpbXBvcnRhbnQ7XFxuICAgIGNsZWFyOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIGNsaXA6IGF1dG8gIWltcG9ydGFudDtcXG4gICAgY29sb3I6IGJsYWNrICFpbXBvcnRhbnQ7XFxuICAgIGNvbnRlbnQ6IG5vcm1hbCAhaW1wb3J0YW50O1xcbiAgICBjb3VudGVyLWluY3JlbWVudDogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBjb3VudGVyLXJlc2V0OiBub25lICFpbXBvcnRhbnQ7XFxuICAgIGN1cnNvcjogYXV0byAhaW1wb3J0YW50O1xcbiAgICBkaXJlY3Rpb246IGx0ciAhaW1wb3J0YW50O1xcbiAgICBlbGV2YXRpb246IGxldmVsICFpbXBvcnRhbnQ7XFxuICAgIGVtcHR5LWNlbGxzOiBzaG93ICFpbXBvcnRhbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmICFpbXBvcnRhbnQ7XFxuICAgIGZvbnQtdmFyaWFudDogbm9ybWFsICFpbXBvcnRhbnQ7XFxuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWwgIWltcG9ydGFudDtcXG4gICAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxuICAgIGxlZnQ6IGF1dG8gIWltcG9ydGFudDtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IG5vcm1hbCAhaW1wb3J0YW50O1xcbiAgICBsaW5lLWhlaWdodDogbm9ybWFsICFpbXBvcnRhbnQ7XFxuICAgIGxpc3Qtc3R5bGUtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgbGlzdC1zdHlsZS1wb3NpdGlvbjogb3V0c2lkZSAhaW1wb3J0YW50O1xcbiAgICBsaXN0LXN0eWxlLXR5cGU6IGRpc2MgIWltcG9ydGFudDtcXG4gICAgbWF4LWhlaWdodDogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBtYXgtd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgbWluLWhlaWdodDogMCAhaW1wb3J0YW50O1xcbiAgICBtaW4td2lkdGg6IDAgIWltcG9ydGFudDtcXG4gICAgb3JwaGFuczogMiAhaW1wb3J0YW50O1xcbiAgICBvdXRsaW5lLWNvbG9yOiBpbnZlcnQgIWltcG9ydGFudDtcXG4gICAgb3V0bGluZS1zdHlsZTogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBvdXRsaW5lLXdpZHRoOiBtZWRpdW0gIWltcG9ydGFudDtcXG4gICAgb3ZlcmZsb3c6IHZpc2libGUgIWltcG9ydGFudDtcXG4gICAgcGFnZS1icmVhay1hZnRlcjogYXV0byAhaW1wb3J0YW50O1xcbiAgICBwYWdlLWJyZWFrLWJlZm9yZTogYXV0byAhaW1wb3J0YW50O1xcbiAgICBwYWdlLWJyZWFrLWluc2lkZTogYXV0byAhaW1wb3J0YW50O1xcbiAgICB0YWJsZS1sYXlvdXQ6IGF1dG8gIWltcG9ydGFudDtcXG4gICAgdGV4dC1hbGlnbjogbGVmdCAhaW1wb3J0YW50O1xcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcXG4gICAgdGV4dC1pbmRlbnQ6IDAgIWltcG9ydGFudDtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmUgIWltcG9ydGFudDtcXG4gICAgdG9wOiBhdXRvICFpbXBvcnRhbnQ7XFxuICAgIHVuaWNvZGUtYmlkaTogbm9ybWFsICFpbXBvcnRhbnQ7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZSAhaW1wb3J0YW50O1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7XFxuICAgIHdoaXRlLXNwYWNlOiBub3JtYWwgIWltcG9ydGFudDtcXG4gICAgd2lkb3dzOiAyICFpbXBvcnRhbnQ7XFxuICAgIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxuICAgIHdvcmQtc3BhY2luZzogbm9ybWFsICFpbXBvcnRhbnQ7XFxuICAgIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xcbiAgICB6LWluZGV4OiA5OTk5OTk5ICFpbXBvcnRhbnQ7XFxuICAgIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7XFxuICAgIHJpZ2h0OiA1cHggIWltcG9ydGFudDtcXG4gICAgbWFyZ2luOiA1cHggIWltcG9ydGFudDtcXG4gICAgcGFkZGluZzogNXB4ICFpbXBvcnRhbnQ7XFxuICAgIGZvbnQtc2l6ZTogMTRweCAhaW1wb3J0YW50O1xcbiAgICBmbG9hdDogbm9uZSAhaW1wb3J0YW50O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjayAhaW1wb3J0YW50O1xcbiAgICBmb250LXN0eWxlOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlICFpbXBvcnRhbnQ7XFxuICAgIHRleHQtYWxpZ246IGxlZnQgIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSA3MSwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbmRpdiNzZWxlY3RvcmdhZGdldF9tYWluICosXFxuLnNlbGVjdG9yZ2FkZ2V0X2NsZWFuLFxcbi5zZWxlY3RvcmdhZGdldF9jbGVhbiAqIHtcXG4gICAgYXppbXV0aDogY2VudGVyO1xcbiAgICBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IHNjcm9sbDtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCUgMCU7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQ7XFxuICAgIGJvcmRlci1jb2xsYXBzZTogc2VwYXJhdGU7XFxuICAgIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgICBib3R0b206IGF1dG87XFxuICAgIGNhcHRpb24tc2lkZTogdG9wO1xcbiAgICBjbGVhcjogbm9uZTtcXG4gICAgY2xpcDogYXV0bztcXG4gICAgY29sb3I6IGJsYWNrO1xcbiAgICBjb250ZW50OiBub3JtYWw7XFxuICAgIGNvdW50ZXItaW5jcmVtZW50OiBub25lO1xcbiAgICBjb3VudGVyLXJlc2V0OiBub25lO1xcbiAgICBjdXJzb3I6IGF1dG87XFxuICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICBlbGV2YXRpb246IGxldmVsO1xcbiAgICBlbXB0eS1jZWxsczogc2hvdztcXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtdmFyaWFudDogbm9ybWFsO1xcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgICBoZWlnaHQ6IGF1dG87XFxuICAgIGxlZnQ6IGF1dG87XFxuICAgIGxldHRlci1zcGFjaW5nOiBub3JtYWw7XFxuICAgIGxpbmUtaGVpZ2h0OiBub3JtYWw7XFxuICAgIGxpc3Qtc3R5bGUtaW1hZ2U6IG5vbmU7XFxuICAgIGxpc3Qtc3R5bGUtcG9zaXRpb246IG91dHNpZGU7XFxuICAgIGxpc3Qtc3R5bGUtdHlwZTogZGlzYztcXG4gICAgbWF4LWhlaWdodDogbm9uZTtcXG4gICAgbWF4LXdpZHRoOiBub25lO1xcbiAgICBtaW4taGVpZ2h0OiAwO1xcbiAgICBtaW4td2lkdGg6IDA7XFxuICAgIG9ycGhhbnM6IDI7XFxuICAgIG91dGxpbmUtY29sb3I6IGludmVydDtcXG4gICAgb3V0bGluZS1zdHlsZTogbm9uZTtcXG4gICAgb3V0bGluZS13aWR0aDogbWVkaXVtO1xcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgcGFnZS1icmVhay1hZnRlcjogYXV0bztcXG4gICAgcGFnZS1icmVhay1iZWZvcmU6IGF1dG87XFxuICAgIHBhZ2UtYnJlYWstaW5zaWRlOiBhdXRvO1xcbiAgICB0YWJsZS1sYXlvdXQ6IGF1dG87XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgdGV4dC1pbmRlbnQ6IDA7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgICB0b3A6IGF1dG87XFxuICAgIHVuaWNvZGUtYmlkaTogbm9ybWFsO1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICAgIHdpZG93czogMjtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIHdvcmQtc3BhY2luZzogbm9ybWFsO1xcbiAgICByaWdodDogMHB4O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICAgIGZvbnQtc3R5bGU6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDEzNiwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbi5zZWxlY3RvcmdhZGdldF9jbGVhbiBhIHtcXG4gICAgY29sb3I6IGJsdWU7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcblxcbi8qIGxpbmUgMTQyLCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuZGl2I3NlbGVjdG9yZ2FkZ2V0X21haW4gLnNlbGVjdG9yZ2FkZ2V0X2lucHV0X2ZpZWxkIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBtYXJnaW46IDAgN3B4IDAgMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2RlZGVkZTtcXG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlZWU7XFxuICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2VlZTtcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJMdWNpZGEgR3JhbmRlXFxcIiwgVGFob21hLCBBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZjtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICBjb2xvcjogIzU2NTY1NjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBwYWRkaW5nOiA1cHggOHB4IDZweCA3cHg7XFxufVxcblxcblxcbi8qIGxpbmUgMTYxLCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuZGl2I3NlbGVjdG9yZ2FkZ2V0X21haW4gLnNlbGVjdG9yZ2FkZ2V0X3dpemFyZCAuc2VsZWN0b3JnYWRnZXRfaW5wdXRfZmllbGQge1xcbiAgICBtYXJnaW46IDdweCAzcHggN3B4IDNweDtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICAgIGRpc3BsYXk6IGlubGluZTtcXG59XFxuXFxuXFxuLyogbGluZSAxNjcsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG5kaXYjc2VsZWN0b3JnYWRnZXRfbWFpbiAuc2VsZWN0b3JnYWRnZXRfcHJvbXB0IHtcXG4gICAgbWFyZ2luOiAzcHggMHB4IDNweCAwcHg7XFxuICAgIGZvbnQtZmFtaWx5OiBcXFwiTHVjaWRhIEdyYW5kZVxcXCIsIFRhaG9tYSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmbG9hdDogbm9uZTtcXG59XFxuXFxuXFxuLyogbGluZSAxNzQsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG5kaXYjc2VsZWN0b3JnYWRnZXRfbWFpbiAuc2VsZWN0b3JnYWRnZXRfd2l6YXJkICNzZWxlY3RvcmdhZGdldF9wYXRoX2ZpZWxkIHtcXG4gICAgbWFyZ2luOiA1cHggMHB4O1xcbiAgICBjbGVhcjogYm90aDtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG5cXG4vKiBsaW5lIDE4MSwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbi5zZWxlY3RvcmdhZGdldF9zZWxlY3RlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMwRjAgIWltcG9ydGFudDtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDE4NiwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbi5zZWxlY3RvcmdhZGdldF9zdWdnZXN0ZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkY1ICFpbXBvcnRhbnQ7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAxOTEsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4uc2VsZWN0b3JnYWRnZXRfYm9yZGVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XFxuICAgIHotaW5kZXg6IDk5OTk5OSAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZSAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBvcmFuZ2UgIWltcG9ydGFudDtcXG4gICAgbWFyZ2luOiAwcHggIWltcG9ydGFudDtcXG4gICAgcGFkZGluZzogMHB4ICFpbXBvcnRhbnQ7XFxuICAgIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7XFxuICAgIGZsb2F0OiBub25lICFpbXBvcnRhbnQ7XFxuICAgIGJvcmRlcjogMCAhaW1wb3J0YW50O1xcbiAgICBmb250LXN0eWxlOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIG91dGxpbmU6IDAgIWltcG9ydGFudDtcXG4gICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lICFpbXBvcnRhbnQ7XFxuICAgIHRleHQtYWxpZ246IGxlZnQgIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAyMDcsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4uc2VsZWN0b3JnYWRnZXRfYm90dG9tX2JvcmRlciB7XFxuICAgIGZvbnQtc2l6ZTogMTBweCAhaW1wb3J0YW50O1xcbiAgICBwYWRkaW5nOiAycHggMHB4IDJweCA1cHggIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAyMTIsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4uc2VsZWN0b3JnYWRnZXRfYm9yZGVyX3JlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGMDAgIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAyMTksIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4uc2VsZWN0b3JnYWRnZXRfcmVqZWN0ZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjAwICFpbXBvcnRhbnQ7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAyMjUsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG5pbWcuc2VsZWN0b3JnYWRnZXRfcmVqZWN0ZWQge1xcbiAgICBib3JkZXI6IDVweCBzb2xpZCAjRjAwICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjI5LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuaW1nLnNlbGVjdG9yZ2FkZ2V0X3N1Z2dlc3RlZCB7XFxuICAgIGJvcmRlcjogNXB4IHNvbGlkICNGRjUgIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAyMzMsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG5pbWcuc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWQge1xcbiAgICBib3JkZXI6IDVweCBzb2xpZCAjMEYwICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjM4LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuI3NlbGVjdG9yZ2FkZ2V0X21haW4uc2VsZWN0b3JnYWRnZXRfdG9wIHtcXG4gICAgdG9wOiA1cHggIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLyogbGluZSAyNDIsIGxpYi9jc3Mvc2VsZWN0b3JnYWRnZXQuY3NzLnNjc3MgKi9cXG5cXG4jc2VsZWN0b3JnYWRnZXRfbWFpbi5zZWxlY3RvcmdhZGdldF9ib3R0b20ge1xcbiAgICBib3R0b206IDVweCAhaW1wb3J0YW50O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDI0NiwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbiNzZWxlY3RvcmdhZGdldF9tYWluIGlucHV0IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4ICFpbXBvcnRhbnQ7XFxuICAgIGZvbnQtc2l6ZTogMTVweCAhaW1wb3J0YW50O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDI1MSwgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbiNzZWxlY3RvcmdhZGdldF9wYXRoX2ZpZWxkIHtcXG4gICAgd2lkdGg6IDQwMHB4ICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbi8qIGxpbmUgMjU1LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuI3NlbGVjdG9yZ2FkZ2V0X21haW4gLnNlbGVjdG9yZ2FkZ2V0X25ld19saW5lIHtcXG4gICAgY2xlYXI6IGJvdGg7XFxufVxcblxcblxcbi8qIGxpbmUgMjU5LCBsaWIvY3NzL3NlbGVjdG9yZ2FkZ2V0LmNzcy5zY3NzICovXFxuXFxuI3NlbGVjdG9yZ2FkZ2V0X21haW4gLnNlbGVjdG9yZ2FkZ2V0X29wdGlvbiB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG5cXG4vKiBsaW5lIDI2MywgbGliL2Nzcy9zZWxlY3RvcmdhZGdldC5jc3Muc2NzcyAqL1xcblxcbiNzZWxlY3RvcmdhZGdldF9tYWluIC5zZWxlY3RvcmdhZGdldF9zZWxlY3RlZF9vcHRpb24ge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgIGlmIChlcnJvckxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIHZhciBlcnJvckxpc3RlbmVyO1xuXG4gICAgLy8gQWRkaW5nIGFuIGVycm9yIGxpc3RlbmVyIGlzIG5vdCBvcHRpb25hbCBiZWNhdXNlXG4gICAgLy8gaWYgYW4gZXJyb3IgaXMgdGhyb3duIG9uIGFuIGV2ZW50IGVtaXR0ZXIgd2UgY2Fubm90XG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIGFjdHVhbCBldmVudCB3ZSBhcmUgd2FpdGluZyB3aWxsXG4gICAgLy8gYmUgZmlyZWQuIFRoZSByZXN1bHQgY291bGQgYmUgYSBzaWxlbnQgd2F5IHRvIGNyZWF0ZVxuICAgIC8vIG1lbW9yeSBvciBmaWxlIGRlc2NyaXB0b3IgbGVha3MsIHdoaWNoIGlzIHNvbWV0aGluZ1xuICAgIC8vIHdlIHNob3VsZCBhdm9pZC5cbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcblxuICAgICAgZW1pdHRlci5vbmNlKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGVtaXR0ZXIub25jZShuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgfSk7XG59XG4iLCIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbmltcG9ydCBsaXN0VG9TdHlsZXMgZnJvbSAnLi9saXN0VG9TdHlsZXMnXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIG9wdGlvbnMgPSBudWxsXG52YXIgc3NySWRLZXkgPSAnZGF0YS12dWUtc3NyLWlkJ1xuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRTdHlsZXNDbGllbnQgKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uLCBfb3B0aW9ucykge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbJyArIHNzcklkS2V5ICsgJ349XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG4gIGlmIChvcHRpb25zLnNzcklkKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShzc3JJZEtleSwgb2JqLmlkKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG4iLCIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuIiwiaW1wb3J0IHsgU2VsZWN0b3JHYWRnZXQgfSBmcm9tIFwiQHNwaWRlci1ydWxlZ2VuL3ZlbmRvclwiXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnXG5pbXBvcnQgeyBnZXRVcmxzIH0gZnJvbSBcIi4vdXRpbHNcIlxuXG5jb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG5TZWxlY3RvckdhZGdldC5wcm90b3R5cGUuZW1pdHRlciA9IGVtaXR0ZXJcblxuY29uc3QgcG9ydCA9IGNocm9tZS5ydW50aW1lLmNvbm5lY3Qoe1xuICAgIG5hbWU6ICdjb250ZW50LXNjcmlwdCdcbn0pXG5cbnBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKGhhbmRsZU1lc3NhZ2VGcm9tRGV2dG9vbHMpXG5wb3J0Lm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcihoYW5kbGVEaXNjb25uZWN0KVxuXG5sZXQgcGF0aFN0b3JlID0gJydcblxuZW1pdHRlci5vbihcInNldFBhdGhcIiwgKGUpID0+IHtcbiAgICBpZiAocGF0aFN0b3JlICE9PSBlKSB7XG4gICAgICAgIHBhdGhTdG9yZSA9IGVcbiAgICAgICAgc2VuZE1lc3NhZ2VUb0RldnRvb2xzKHsgdHlwZTogXCJzZWxlY3Rvcjp1cGRhdGVcIiwgdmFsdWU6IGUgfSlcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBzZW5kTWVzc2FnZVRvRGV2dG9vbHMobXNnKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZShtc2cpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2VGcm9tRGV2dG9vbHMoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzZWxlY3Rvcjpsb2FkXCI6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImJhY2tlbmQgLSBsb2FkIHBhdGg6IFwiLCBlLnZhbHVlKVxuICAgICAgICAgICAgLy8gZW5zdXJlIG9wZW5cbiAgICAgICAgICAgIGNvbnN0IHNnID0gU2VsZWN0b3JHYWRnZXQudG9nZ2xlT3BlbigpXG4gICAgICAgICAgICBwYXRoU3RvcmUgPSBzZy5yZWZyZXNoRnJvbVBhdGgoeyB2YWx1ZTogZS52YWx1ZSB9KVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcInNlbGVjdG9yOmRlYWN0aXZlXCI6XG4gICAgICAgICAgICBTZWxlY3RvckdhZGdldC50b2dnbGVDbG9zZSgpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIFwibG9jYXRpb246aHJlZlwiOlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBlLnZhbHVlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIFwiZXh0cmFjdDp1cmxzXCI6XG4gICAgICAgICAgICBzZW5kTWVzc2FnZVRvRGV2dG9vbHMoeyB0eXBlOiBcImV4dHJhY3RlZDp1cmxzXCIsIHZhbHVlOiBnZXRVcmxzKGUudmFsdWUpIH0pXG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgIFNlbGVjdG9yR2FkZ2V0LnRvZ2dsZUNsb3NlKClcbn1cblxuIiwiZXhwb3J0IGZ1bmN0aW9uIGdldFVybHMoY3NzU2VsZWN0b3IpIHtcbiAgICBjb25zdCBkb21MaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjc3NTZWxlY3RvcilcbiAgICBjb25zdCB1cmxzID0gW11cbiAgICBjb25zdCBoYXNTZWVuID0gbmV3IFNldCgpXG5cbiAgICBmdW5jdGlvbiBjYihub2RlKSB7XG4gICAgICAgIGlmIChoYXNTZWVuLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYXNTZWVuLmFkZChub2RlKVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdBJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IChub2RlLmhyZWYgfHwgJycpLnRyaW0oKVxuICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJscy5wdXNoKHVybClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGRvbUl0ZW0gb2YgZG9tTGlzdCkge1xuICAgICAgICBkb21UcmF2ZXJzZShkb21JdGVtLCBjYilcbiAgICB9XG4gICAgcmV0dXJuIHVybHM7XG59XG5cbmZ1bmN0aW9uIGRvbVRyYXZlcnNlKGRvbUl0ZW0sIGNiKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBkb21JdGVtLmNoaWxkTm9kZXNcbiAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBnb0ludG8gPSBjYihub2RlKVxuICAgICAgICAgICAgaWYgKGdvSW50bykge1xuICAgICAgICAgICAgICAgIGRvbVRyYXZlcnNlKG5vZGUsIGNiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSJdLCJzb3VyY2VSb290IjoiIn0=